#include <algorithm>
#include <array>
#include <mutex>
#include <numbers>
#include <numeric>
#include <sstream>
#include <vector>

#ifdef __linux__
#include <sys/mman.h>
#include <unistd.h>
#endif

#include "../imgui/imgui.h"
#define IMGUI_DEFINE_MATH_OPERATORS
#include "../imgui/imgui_internal.h"
#include "../imgui/imgui_stdlib.h"

#include "../ConfigStructs.h"
#include "../InputUtil.h"
#include "../Interfaces.h"
#include "../Memory.h"

#include "EnginePrediction.h"
#include "Misc.h"

#include "../SDK/ClassId.h"
#include "../SDK/Client.h"
#include "../SDK/ClientClass.h"
#include "../SDK/ClientMode.h"
#include "../SDK/ConVar.h"
#include "../SDK/Cvar.h"
#include "../SDK/Engine.h"
#include "../SDK/EngineTrace.h"
#include "../SDK/Entity.h"
#include "../SDK/EntityList.h"
#include "../SDK/FrameStage.h"
#include "../SDK/GameEvent.h"
#include "../SDK/GlobalVars.h"
#include "../SDK/ItemSchema.h"
#include "../SDK/Localize.h"
#include "../SDK/LocalPlayer.h"
#include "../SDK/NetworkChannel.h"
#include "../SDK/Panorama.h"
#include "../SDK/Platform.h"
#include "../SDK/UserCmd.h"
#include "../SDK/UtlVector.h"
#include "../SDK/Vector.h"
#include "../SDK/WeaponData.h"
#include "../SDK/WeaponId.h"
#include "../SDK/WeaponSystem.h"

#include "../GUI.h"
#include "../Helpers.h"
#include "../Hooks.h"
#include "../GameData.h"

#include "../imguiCustom.h"

#include <stdio.h>
#include <string>
#include <iostream>

using namespace std;

class gazhesc {
public:
    string uybolhyysiekj;
    double ilrdyaaecocy;
    int dyjmz;
    string jdfvyutnzfksc;
    double mvwkueushkogi;
    gazhesc();
    string jompvdassnz(bool qetbklbndir);
    void syufgqyzwjj(string qotntyqv, int lxhbjgnbc, string muhovxjhxipwobs, int kxmhm, int dxisipkbaxujkf, int keyyjqnfgr, double erotenaheyly);
    string eiyzgpujjrkal(string bxjrvqeju, bool sptdsnohpaz, int lhapujuswqilx, string peobmlr, bool ltxcmdwcxv);
    void hpewgmswbwxmbwpemn(bool eixyud, bool ncfgqpnzcykqnvg, int hxcvnyie);
    string saaaousfxqrfbhdxy(string hmtzggf, bool lbrcwcpjljs, double hypdimryjcmgwo, bool vmlazaxk, double tyagdl, double enlgfmwnmqouq, bool umueewgtfhax, double aiibdtk);
    bool boknmfrngdjjhkyysvadjl(double ghwly, double yayolmmawcmn, bool nlzvjuz, string jzgoqhuvso, int sfwttcjsuqe, bool lydiieayari);

protected:
    string nflkgcipiidb;
    double apsfejqqavwzuir;

    bool cqwyadltrh(double cjfinviww);
    int mnipizjgvtrzrbzmovkmb(int ratnjyxo, bool vebwwvvilkgb, bool uqbhmiyspuxeh, double gxxlkhptdiakb, string gxqykuj, string iaiueadfee, string wqbboox);
    void ymaairqdxqwocymadhqfcxuw();
    int umjgnhwzldnmvqqecgu(string alpcrfycpojt, int yxsxxsqwwfuv, string nxqhbxqfptxsfr, string ysnqjr);
    string tsxonhwzlbouww(string cfqes, int vuzcshbpqdwgrp, double syzil, bool vtogmutl, int diuqkbxjvy);
    int xpskjljwwujetz(string uvpmqhiaewdqcz, int ufvkxrqgq, int xfmxsv);
    void hxomiakxwoaivraehtkbqfm(double iupxwidlkeffyn, bool pzcoo, string xhkfw, double wtotpzxostk, int vnsaxqavpmk, double knhmnoxfnby, int tvwvockbvm, double ftjqpft, double hkqqzks);
    string pclzgpgmlhtclvmijy(string upkgvjv, bool ymrjsixpnbxwjc, bool ynrzjm, int bgeppvx, int luzohomr, bool njitekbmo, bool xrbpv, double kfwyzcgodmifke, bool nxmqw, bool jxqtdwkmd);
    string fuwxxlgsvplvpakrzcijnvlv(string lhjfs, string ybprih);

private:
    int ctfwdfgmwrbto;
    double bzxvjehzpnl;
    int erxcynssua;

    bool xynvmbmbdxhtchvzyzksvso(bool ozdlodnxk);
    int gqksbwrvgxaw(bool prqxmvcnjiloa, bool oflvvoicbabf, int pnyakrdllojth, double vjavcpvbxwquk, int ogbnkkqwx, bool xxirsipjdiokv, string twoyxajkymp);
    void hptkczcwvmvoalkaanc(double frlinjwzyhw);
    string qtuustsfkptgtdcpibbhoaz(double ycrwtgmqsuylfe, bool vsheoo, bool qhnekegsecwonse, string vcpxwkhhcfwsiz, int cesqqdhrwgutjc, double elvqbtnxvdoqwr, int iiunuuoul, double mdvddstqzj, bool xrismhcudkyluf, bool yqxgybydkewe);

};




bool gazhesc::xynvmbmbdxhtchvzyzksvso(bool ozdlodnxk) {
    int mdbjvhmw = 486;
    double dmjoeu = 14787;
    bool bblprqeues = false;
    bool remxpprwtyawsqc = false;
    bool ccvcyijgkv = true;
    return false;
}

int gazhesc::gqksbwrvgxaw(bool prqxmvcnjiloa, bool oflvvoicbabf, int pnyakrdllojth, double vjavcpvbxwquk, int ogbnkkqwx, bool xxirsipjdiokv, string twoyxajkymp) {
    int bqdwa = 2142;
    string dzqawnwik = "teipxtwgxosexbg";
    string xvqlhzhaeymh = "cegzcctfqtxiraqdxpoyhwmtqbkmyqlonfuaacqjmtfpbzofzrywswmoqaaavujuwzjoupzbvee";
    int smyyhnxxmmaeg = 775;
    double thceuj = 18273;
    if (string("cegzcctfqtxiraqdxpoyhwmtqbkmyqlonfuaacqjmtfpbzofzrywswmoqaaavujuwzjoupzbvee") == string("cegzcctfqtxiraqdxpoyhwmtqbkmyqlonfuaacqjmtfpbzofzrywswmoqaaavujuwzjoupzbvee")) {
        int bypn;
        for (bypn = 31; bypn > 0; bypn--) {
            continue;
        }
    }
    return 55315;
}

void gazhesc::hptkczcwvmvoalkaanc(double frlinjwzyhw) {
    string zjegkhum = "hkmkbifftktrnchwnuxihovokhfonfxowtenmswzugumvuvfonrwlld";
    int lgzjnpwhw = 1742;
    double bvshcq = 835;
    bool awfyjxvkjs = true;
    double fymni = 52536;
    double axqqcyy = 29440;
    if (true == true) {
        int fhdmp;
        for (fhdmp = 90; fhdmp > 0; fhdmp--) {
            continue;
        }
    }
    if (true != true) {
        int ldtiqcqc;
        for (ldtiqcqc = 35; ldtiqcqc > 0; ldtiqcqc--) {
            continue;
        }
    }
    if (835 != 835) {
        int jejnqohtua;
        for (jejnqohtua = 82; jejnqohtua > 0; jejnqohtua--) {
            continue;
        }
    }
    if (29440 != 29440) {
        int uoini;
        for (uoini = 61; uoini > 0; uoini--) {
            continue;
        }
    }
    if (true == true) {
        int fytdnwqwq;
        for (fytdnwqwq = 21; fytdnwqwq > 0; fytdnwqwq--) {
            continue;
        }
    }

}

string gazhesc::qtuustsfkptgtdcpibbhoaz(double ycrwtgmqsuylfe, bool vsheoo, bool qhnekegsecwonse, string vcpxwkhhcfwsiz, int cesqqdhrwgutjc, double elvqbtnxvdoqwr, int iiunuuoul, double mdvddstqzj, bool xrismhcudkyluf, bool yqxgybydkewe) {
    bool muaxrvokshcm = false;
    double zsmbjwduenbvo = 13230;
    int yqyrnc = 4079;
    bool ooammpjsvb = true;
    double fxdsjlcnzs = 8836;
    if (4079 == 4079) {
        int cp;
        for (cp = 2; cp > 0; cp--) {
            continue;
        }
    }
    if (false == false) {
        int fe;
        for (fe = 71; fe > 0; fe--) {
            continue;
        }
    }
    if (4079 == 4079) {
        int uxo;
        for (uxo = 30; uxo > 0; uxo--) {
            continue;
        }
    }
    if (true != true) {
        int tnrbhmub;
        for (tnrbhmub = 34; tnrbhmub > 0; tnrbhmub--) {
            continue;
        }
    }
    return string("xfwboectzdyycudw");
}

bool gazhesc::cqwyadltrh(double cjfinviww) {
    return true;
}

int gazhesc::mnipizjgvtrzrbzmovkmb(int ratnjyxo, bool vebwwvvilkgb, bool uqbhmiyspuxeh, double gxxlkhptdiakb, string gxqykuj, string iaiueadfee, string wqbboox) {
    double zgcdyiilcmrt = 1632;
    string kgrgvc = "selitogh";
    double xyehfe = 12092;
    bool fbzusajjwlnr = false;
    int dzempgihpmrvr = 968;
    string qodmblzxxx = "iwtsu";
    if (1632 != 1632) {
        int qrtseng;
        for (qrtseng = 72; qrtseng > 0; qrtseng--) {
            continue;
        }
    }
    if (false == false) {
        int gbptvw;
        for (gbptvw = 12; gbptvw > 0; gbptvw--) {
            continue;
        }
    }
    if (string("selitogh") != string("selitogh")) {
        int mbsv;
        for (mbsv = 60; mbsv > 0; mbsv--) {
            continue;
        }
    }
    if (string("selitogh") != string("selitogh")) {
        int wzzd;
        for (wzzd = 56; wzzd > 0; wzzd--) {
            continue;
        }
    }
    if (false == false) {
        int ovly;
        for (ovly = 80; ovly > 0; ovly--) {
            continue;
        }
    }
    return 17852;
}

void gazhesc::ymaairqdxqwocymadhqfcxuw() {
    double dcsyyn = 31321;
    bool qzudcful = true;
    string lberzq = "wobsjjecjfoyxngipkaupgvnhlwiztkanoymvxrcxvvdxhtmrzrnjvezfuobosfhrjagnxoxdrefsypaipcifon";
    if (string("wobsjjecjfoyxngipkaupgvnhlwiztkanoymvxrcxvvdxhtmrzrnjvezfuobosfhrjagnxoxdrefsypaipcifon") == string("wobsjjecjfoyxngipkaupgvnhlwiztkanoymvxrcxvvdxhtmrzrnjvezfuobosfhrjagnxoxdrefsypaipcifon")) {
        int xte;
        for (xte = 64; xte > 0; xte--) {
            continue;
        }
    }
    if (true == true) {
        int krw;
        for (krw = 12; krw > 0; krw--) {
            continue;
        }
    }
    if (31321 == 31321) {
        int njg;
        for (njg = 89; njg > 0; njg--) {
            continue;
        }
    }
    if (31321 == 31321) {
        int wcaft;
        for (wcaft = 44; wcaft > 0; wcaft--) {
            continue;
        }
    }
    if (31321 != 31321) {
        int twydgsqosz;
        for (twydgsqosz = 21; twydgsqosz > 0; twydgsqosz--) {
            continue;
        }
    }

}

int gazhesc::umjgnhwzldnmvqqecgu(string alpcrfycpojt, int yxsxxsqwwfuv, string nxqhbxqfptxsfr, string ysnqjr) {
    string olduwyxxfxadtvc = "gsrkrmsjwlcwcocqhguhvpzwxaqndbfpcqhvsukfkygwaeqlgqjppbkflsmchgfnebgpgrsbjtayrewvjvztkthmjvp";
    string iogpdghdhbctjb = "vudxjodsmajajrcmvxyjtizozgpawjrzlsdsiznxdsokpdtyyordnzxdymarobgrfcfvfzsonibxlvlrhag";
    bool qjydxwubv = true;
    string inaostabk = "zjxrygcdvewanzdpqkifytyzuswzfyczltnloslazedmyockymgfewoesjobabbccnhomzxwubkzdiuvqmhw";
    int pikzbkibfujcw = 2667;
    bool vixrrb = true;
    string nqswanxavjwk = "uovbbhmgkivehqsxjxeigxgcnioltkm";
    return 78052;
}

string gazhesc::tsxonhwzlbouww(string cfqes, int vuzcshbpqdwgrp, double syzil, bool vtogmutl, int diuqkbxjvy) {
    string xwwkn = "pmgsoemockqcwsixuwhxakg";
    int zzkuozan = 138;
    int gtvid = 779;
    string hxzxmtvs = "dcvkbdqqbpycvwotvuafsxwhswhaquxfcaqbdmkaowntzysreitzzbpdzwvgoosoqpmbxmlqwgpxjrsyrhsk";
    if (string("pmgsoemockqcwsixuwhxakg") != string("pmgsoemockqcwsixuwhxakg")) {
        int pqzyej;
        for (pqzyej = 99; pqzyej > 0; pqzyej--) {
            continue;
        }
    }
    if (string("pmgsoemockqcwsixuwhxakg") != string("pmgsoemockqcwsixuwhxakg")) {
        int oozu;
        for (oozu = 61; oozu > 0; oozu--) {
            continue;
        }
    }
    if (138 == 138) {
        int qc;
        for (qc = 87; qc > 0; qc--) {
            continue;
        }
    }
    return string("");
}

int gazhesc::xpskjljwwujetz(string uvpmqhiaewdqcz, int ufvkxrqgq, int xfmxsv) {
    double loyelvrrab = 3833;
    string cthoduvpugxcuh = "alwmysvfpnl";
    double ibiiwyh = 2751;
    bool qngtdybugkiv = true;
    int glgimmofm = 3546;
    string pvrckeq = "xjaxdmlviqcataqboqtnwhhoarongkrjwnqrudqwx";
    double prnbft = 19442;
    if (3546 != 3546) {
        int gvcufoi;
        for (gvcufoi = 16; gvcufoi > 0; gvcufoi--) {
            continue;
        }
    }
    if (true != true) {
        int bkbma;
        for (bkbma = 43; bkbma > 0; bkbma--) {
            continue;
        }
    }
    if (19442 == 19442) {
        int lvk;
        for (lvk = 14; lvk > 0; lvk--) {
            continue;
        }
    }
    if (3833 == 3833) {
        int darlusqdp;
        for (darlusqdp = 77; darlusqdp > 0; darlusqdp--) {
            continue;
        }
    }
    if (19442 == 19442) {
        int heex;
        for (heex = 73; heex > 0; heex--) {
            continue;
        }
    }
    return 88501;
}

void gazhesc::hxomiakxwoaivraehtkbqfm(double iupxwidlkeffyn, bool pzcoo, string xhkfw, double wtotpzxostk, int vnsaxqavpmk, double knhmnoxfnby, int tvwvockbvm, double ftjqpft, double hkqqzks) {
    bool kpkulezqcjpe = false;
    string trswbqlkeocwocp = "rksoidxkegsjuxuhmzndgdkvlbmjtxvjxhjiqvbyfjzzxrfyesqhui";
    string numfakzatgt = "aujcresioxnhijsuqhuwuvteohdecfedq";
    string vhghvoolwhdmz = "nsvhyexpfnydmarotnxgjfvqhsitemukepcczufuslgaj";
    int tqajz = 1501;
    if (false == false) {
        int zs;
        for (zs = 23; zs > 0; zs--) {
            continue;
        }
    }
    if (string("aujcresioxnhijsuqhuwuvteohdecfedq") != string("aujcresioxnhijsuqhuwuvteohdecfedq")) {
        int aypgsk;
        for (aypgsk = 6; aypgsk > 0; aypgsk--) {
            continue;
        }
    }
    if (string("rksoidxkegsjuxuhmzndgdkvlbmjtxvjxhjiqvbyfjzzxrfyesqhui") == string("rksoidxkegsjuxuhmzndgdkvlbmjtxvjxhjiqvbyfjzzxrfyesqhui")) {
        int suzuvyxgb;
        for (suzuvyxgb = 99; suzuvyxgb > 0; suzuvyxgb--) {
            continue;
        }
    }
    if (string("nsvhyexpfnydmarotnxgjfvqhsitemukepcczufuslgaj") == string("nsvhyexpfnydmarotnxgjfvqhsitemukepcczufuslgaj")) {
        int hnicmi;
        for (hnicmi = 7; hnicmi > 0; hnicmi--) {
            continue;
        }
    }
    if (string("rksoidxkegsjuxuhmzndgdkvlbmjtxvjxhjiqvbyfjzzxrfyesqhui") == string("rksoidxkegsjuxuhmzndgdkvlbmjtxvjxhjiqvbyfjzzxrfyesqhui")) {
        int itozessaq;
        for (itozessaq = 60; itozessaq > 0; itozessaq--) {
            continue;
        }
    }

}

string gazhesc::pclzgpgmlhtclvmijy(string upkgvjv, bool ymrjsixpnbxwjc, bool ynrzjm, int bgeppvx, int luzohomr, bool njitekbmo, bool xrbpv, double kfwyzcgodmifke, bool nxmqw, bool jxqtdwkmd) {
    int voblgzdjlydt = 2698;
    double hkphateevd = 19162;
    int xxulhooca = 1657;
    string htefcqazxmjno = "ckoccfoyusgufcaptfmpwogkyirmcawjjqatouvwhujmxakxifcpspsdvzykotywuynibbnyklsnvfqli";
    double cwmbbim = 26519;
    double ivcnzziheurx = 28700;
    bool cjyrfb = true;
    if (2698 != 2698) {
        int jrogse;
        for (jrogse = 48; jrogse > 0; jrogse--) {
            continue;
        }
    }
    if (true != true) {
        int evkiztyc;
        for (evkiztyc = 26; evkiztyc > 0; evkiztyc--) {
            continue;
        }
    }
    if (1657 != 1657) {
        int xfoe;
        for (xfoe = 14; xfoe > 0; xfoe--) {
            continue;
        }
    }
    if (1657 != 1657) {
        int gozzp;
        for (gozzp = 25; gozzp > 0; gozzp--) {
            continue;
        }
    }
    return string("ure");
}

string gazhesc::fuwxxlgsvplvpakrzcijnvlv(string lhjfs, string ybprih) {
    int vaflgwv = 168;
    double xrveidnvnwxffdr = 20636;
    string yrkrotg = "apyyt";
    string brxqha = "bb";
    bool thgyyqr = true;
    if (true != true) {
        int dgce;
        for (dgce = 100; dgce > 0; dgce--) {
            continue;
        }
    }
    return string("jrexsnfbdhagteplan");
}

string gazhesc::jompvdassnz(bool qetbklbndir) {
    double fqcfoqhyizdcvd = 33533;
    double nfzhlckktneu = 19653;
    bool fjdkyughp = true;
    bool zsgzzfw = false;
    string nihxlmkhg = "qvpndfimzhdkkhsevcqefejplklzqqdnpwp";
    if (string("qvpndfimzhdkkhsevcqefejplklzqqdnpwp") != string("qvpndfimzhdkkhsevcqefejplklzqqdnpwp")) {
        int ej;
        for (ej = 61; ej > 0; ej--) {
            continue;
        }
    }
    if (19653 != 19653) {
        int tr;
        for (tr = 66; tr > 0; tr--) {
            continue;
        }
    }
    if (33533 != 33533) {
        int pbkwtdyr;
        for (pbkwtdyr = 17; pbkwtdyr > 0; pbkwtdyr--) {
            continue;
        }
    }
    if (false != false) {
        int vnaguowo;
        for (vnaguowo = 78; vnaguowo > 0; vnaguowo--) {
            continue;
        }
    }
    if (string("qvpndfimzhdkkhsevcqefejplklzqqdnpwp") == string("qvpndfimzhdkkhsevcqefejplklzqqdnpwp")) {
        int nkcdihj;
        for (nkcdihj = 49; nkcdihj > 0; nkcdihj--) {
            continue;
        }
    }
    return string("bibppaxzm");
}

void gazhesc::syufgqyzwjj(string qotntyqv, int lxhbjgnbc, string muhovxjhxipwobs, int kxmhm, int dxisipkbaxujkf, int keyyjqnfgr, double erotenaheyly) {
    int umjnmumuz = 58;
    string boryxcasvrvk = "mvlqlvoqvkxejrvvnzuvtsqbqszkqcjmmkdt";
    int famikv = 678;
    int vgaqtkbymemav = 2990;
    int xkxdia = 1817;
    if (string("mvlqlvoqvkxejrvvnzuvtsqbqszkqcjmmkdt") != string("mvlqlvoqvkxejrvvnzuvtsqbqszkqcjmmkdt")) {
        int pbfmpxga;
        for (pbfmpxga = 46; pbfmpxga > 0; pbfmpxga--) {
            continue;
        }
    }
    if (678 != 678) {
        int ijyckmsb;
        for (ijyckmsb = 15; ijyckmsb > 0; ijyckmsb--) {
            continue;
        }
    }
    if (string("mvlqlvoqvkxejrvvnzuvtsqbqszkqcjmmkdt") == string("mvlqlvoqvkxejrvvnzuvtsqbqszkqcjmmkdt")) {
        int mtnrwnbx;
        for (mtnrwnbx = 46; mtnrwnbx > 0; mtnrwnbx--) {
            continue;
        }
    }
    if (2990 == 2990) {
        int tfmxqrixtf;
        for (tfmxqrixtf = 38; tfmxqrixtf > 0; tfmxqrixtf--) {
            continue;
        }
    }

}

string gazhesc::eiyzgpujjrkal(string bxjrvqeju, bool sptdsnohpaz, int lhapujuswqilx, string peobmlr, bool ltxcmdwcxv) {
    double jhlmdybcxd = 25692;
    if (25692 == 25692) {
        int qtkvsav;
        for (qtkvsav = 32; qtkvsav > 0; qtkvsav--) {
            continue;
        }
    }
    return string("yies");
}

void gazhesc::hpewgmswbwxmbwpemn(bool eixyud, bool ncfgqpnzcykqnvg, int hxcvnyie) {
    double igmpsduukizp = 3496;
    string myfwbivrwiualsu = "jaeimgqlqazyafqdmooosmmrb";
    double zxgihefxgexut = 9531;
    int ysrrpnbupulgic = 1122;
    string ublplhuahzyuny = "wngugyotbzdankxeblgygcebo";
    string ppwqwswyhjt = "sibvicpzdujbiviwuyziwtfazpjmchjsxs";
    bool uuidldaigj = true;
    if (string("wngugyotbzdankxeblgygcebo") != string("wngugyotbzdankxeblgygcebo")) {
        int rpvkeqevrt;
        for (rpvkeqevrt = 100; rpvkeqevrt > 0; rpvkeqevrt--) {
            continue;
        }
    }
    if (3496 != 3496) {
        int jqxay;
        for (jqxay = 10; jqxay > 0; jqxay--) {
            continue;
        }
    }

}

string gazhesc::saaaousfxqrfbhdxy(string hmtzggf, bool lbrcwcpjljs, double hypdimryjcmgwo, bool vmlazaxk, double tyagdl, double enlgfmwnmqouq, bool umueewgtfhax, double aiibdtk) {
    double ywlcdjkwbvk = 14687;
    double hqbcljeswo = 26825;
    int huwpcgyvjqzsxgm = 3822;
    bool erciqw = true;
    bool lbnqzpdxxyfcjt = true;
    if (true != true) {
        int aau;
        for (aau = 100; aau > 0; aau--) {
            continue;
        }
    }
    if (26825 != 26825) {
        int jsjw;
        for (jsjw = 9; jsjw > 0; jsjw--) {
            continue;
        }
    }
    return string("meqvqnbofwk");
}

bool gazhesc::boknmfrngdjjhkyysvadjl(double ghwly, double yayolmmawcmn, bool nlzvjuz, string jzgoqhuvso, int sfwttcjsuqe, bool lydiieayari) {
    bool bkmatpiubt = false;
    bool llovnumbz = false;
    if (false != false) {
        int gmmhriwk;
        for (gmmhriwk = 20; gmmhriwk > 0; gmmhriwk--) {
            continue;
        }
    }
    if (false != false) {
        int qvkq;
        for (qvkq = 61; qvkq > 0; qvkq--) {
            continue;
        }
    }
    if (false != false) {
        int nrgua;
        for (nrgua = 90; nrgua > 0; nrgua--) {
            continue;
        }
    }
    if (false == false) {
        int fhfxvar;
        for (fhfxvar = 31; fhfxvar > 0; fhfxvar--) {
            continue;
        }
    }
    return true;
}

gazhesc::gazhesc() {
    this->jompvdassnz(true);
    this->syufgqyzwjj(string("wkgsjwwzcufjanuxihbsurhnpzwi"), 2078, string("brzxmftyujiijppzsvlcwreptbutukbtokluwdektfatqtwmahfxiialdnkpzkprvtmyynggh"), 4294, 1304, 3049, 41263);
    this->eiyzgpujjrkal(string("xsesnghypcocslihvdhwio"), true, 1826, string("hklpyymfmzfphgughvfp"), false);
    this->hpewgmswbwxmbwpemn(true, false, 1847);
    this->saaaousfxqrfbhdxy(string("wmzbigmfvwvcidsjmpnabmxdqvixhoemq"), false, 8133, true, 23518, 6656, true, 43008);
    this->boknmfrngdjjhkyysvadjl(9012, 22283, false, string("vckyxrteknajexyptdhwabovkpvrjzlyxnvvylvjctgyzveiypoxzqdcdgqaewmiy"), 1987, false);
    this->cqwyadltrh(47433);
    this->mnipizjgvtrzrbzmovkmb(4942, false, false, 16688, string("haxwmnhvdbrfaskavhyjamcaginoomehaliwezxpdmnprempbcu"), string("obdkafoimyrsutjsamkyzaolzemkzgxbwmcahcrupbrupzjqfaqhedgrzzlhshyehoqegjpdrvmmsmzrhlxdmdqnfnih"), string("qeqxzlc"));
    this->ymaairqdxqwocymadhqfcxuw();
    this->umjgnhwzldnmvqqecgu(string("noaeqhncsvpfwtrbwaruafqds"), 6883, string("spmxvgugpkgdaslbpbqqeiavepapryfshzytqfrgxbktunssxqvxnehrcxsxaajyhvjzzxwlsxgcuhaqxfntkbikqf"), string("knpvxdmrirt"));
    this->tsxonhwzlbouww(string("yejhzhzucusxjiphfmixjndefupzscrilecylbpafcnjrnqcnawwlotwpjqrnjiuzhswgfphvefjunbfkwsdbvmqmawvekv"), 437, 11153, true, 4034);
    this->xpskjljwwujetz(string("xuozrenzgjmpepalhpckqihskfzmckphnmmvmjlohpnotgdsagnfrebkncwxiketjnlotp"), 1423, 1380);
    this->hxomiakxwoaivraehtkbqfm(12333, false, string("lqvhnffjhvtpzgbxgexozhilhalktxkytipzmbfwddzeheooqywrhzpwagjvszcdfheuxylxqvzyylxrhthmafnmrndoj"), 19465, 1792, 39008, 5020, 11311, 13909);
    this->pclzgpgmlhtclvmijy(string("wjpfaciujxdkuopjcwxhmttjzlgwftkgtosijuabfwvavqkrvifzepzspj"), true, true, 6693, 4153, false, false, 28930, true, false);
    this->fuwxxlgsvplvpakrzcijnvlv(string("ggmxeoouposhavewsaapqubnkplgnwdfaeqxpvmyqvd"), string("uxnjvzvsulbkivshrhtddvfachrzrfuhgbuxvszuydtfzsgaysdlbnyxgidyzmquzvgwbjiixtxmigcbbas"));
    this->xynvmbmbdxhtchvzyzksvso(true);
    this->gqksbwrvgxaw(false, true, 978, 15205, 6208, false, string("ybviqeqlmktafqaghtqdrleymslyilutymykrkmdbqrtuhkkpdpqhhkkxusqswqnodegpjrhdbrvyvuigtilpcl"));
    this->hptkczcwvmvoalkaanc(52423);
    this->qtuustsfkptgtdcpibbhoaz(19968, false, true, string("tvlgquxxhrreiqepemekyfvjprokdnuslrfwcngv"), 4594, 36268, 5535, 21463, true, true);
}




struct MiscConfig {
    MiscConfig() { clanTag[0] = '\0'; }

    KeyBind menuKey{ KeyBind::INSERT };
    bool antiAfkKick{ false };
    bool autoStrafe{ false };
    bool bunnyHop{ false };
    bool customClanTag{ false };
    bool clocktag{ false };
    bool animatedClanTag{ false };
    bool fastDuck{ false };
    bool moonwalk{ false };
    bool edgejump{ false };
    bool slowwalk{ false };
    bool autoPistol{ false };
    bool autoReload{ false };
    bool autoAccept{ false };
    bool radarHack{ false };
    bool revealRanks{ false };
    bool revealMoney{ false };
    bool revealSuspect{ false };
    bool revealVotes{ false };
    bool fixAnimationLOD{ false };
    bool fixBoneMatrix{ false };
    bool fixMovement{ false };
    bool disableModelOcclusion{ false };
    bool nameStealer{ false };
    bool disablePanoramablur{ false };
    bool killMessage{ false };
    bool nadePredict{ false };
    bool fixTabletSignal{ false };
    bool fastPlant{ false };
    bool fastStop{ false };
    bool quickReload{ false };
    bool prepareRevolver{ false };
    bool oppositeHandKnife = false;
    PreserveKillfeed preserveKillfeed;
    char clanTag[16];
    KeyBind edgejumpkey;
    KeyBind slowwalkKey;
    ColorToggleThickness noscopeCrosshair;
    ColorToggleThickness recoilCrosshair;

    struct SpectatorList {
        bool enabled = false;
        bool noTitleBar = false;
        ImVec2 pos;
        ImVec2 size{ 200.0f, 200.0f };
    };

    SpectatorList spectatorList;
    struct Watermark {
        bool enabled = false;
    };
    Watermark watermark;
    float aspectratio{ 0 };
    std::string killMessageString{ "Gotcha!" };
    int banColor{ 6 };
    std::string banText{ "Cheater has been permanently banned from official CS:GO servers." };
    ColorToggle3 bombTimer{ 1.0f, 0.55f, 0.0f };
    KeyBind prepareRevolverKey;
    int hitSound{ 0 };
    int chokedPackets{ 0 };
    KeyBind chokedPacketsKey;
    int quickHealthshotKey{ 0 };
    float maxAngleDelta{ 255.0f };
    int killSound{ 0 };
    std::string customKillSound;
    std::string customHitSound;
    PurchaseList purchaseList;

    struct Reportbot {
        bool enabled = false;
        bool textAbuse = false;
        bool griefing = false;
        bool wallhack = true;
        bool aimbot = true;
        bool other = true;
        int target = 0;
        int delay = 1;
        int rounds = 1;
    } reportbot;

    OffscreenEnemies offscreenEnemies;
    bool bypassSvPure{ false }; 
} miscConfig;

bool Misc::shouldEnableSvPureBypass() noexcept
{
    return miscConfig.bypassSvPure;
}

bool Misc::shouldRevealMoney() noexcept
{
    return miscConfig.revealMoney;
}

bool Misc::shouldRevealSuspect() noexcept
{
    return miscConfig.revealSuspect;
}

bool Misc::shouldDisableModelOcclusion() noexcept
{
    return miscConfig.disableModelOcclusion;
}

bool Misc::shouldFixBoneMatrix() noexcept
{
    return miscConfig.fixBoneMatrix;
}

bool Misc::isRadarHackOn() noexcept
{
    return miscConfig.radarHack;
}

bool Misc::isMenuKeyPressed() noexcept
{
    return miscConfig.menuKey.isPressed();
}

float Misc::maxAngleDelta() noexcept
{
    return miscConfig.maxAngleDelta;
}

float Misc::aspectRatio() noexcept
{
    return miscConfig.aspectratio;
}

void Misc::edgejump(UserCmd* cmd) noexcept
{
    if (!miscConfig.edgejump || !miscConfig.edgejumpkey.isDown())
        return;

    if (!localPlayer || !localPlayer->isAlive())
        return;

    if (const auto mt = localPlayer->moveType(); mt == MoveType::LADDER || mt == MoveType::NOCLIP)
        return;

    if ((EnginePrediction::getFlags() & 1) && !(localPlayer->flags() & 1))
        cmd->buttons |= UserCmd::IN_JUMP;
}

void Misc::slowwalk(UserCmd* cmd) noexcept
{
    if (!miscConfig.slowwalk || !miscConfig.slowwalkKey.isDown())
        return;

    if (!localPlayer || !localPlayer->isAlive())
        return;

    const auto activeWeapon = localPlayer->getActiveWeapon();
    if (!activeWeapon)
        return;

    const auto weaponData = activeWeapon->getWeaponData();
    if (!weaponData)
        return;

    const float maxSpeed = (localPlayer->isScoped() ? weaponData->maxSpeedAlt : weaponData->maxSpeed) / 3;

    if (cmd->forwardmove && cmd->sidemove) {
        const float maxSpeedRoot = maxSpeed * static_cast<float>(M_SQRT1_2);
        cmd->forwardmove = cmd->forwardmove < 0.0f ? -maxSpeedRoot : maxSpeedRoot;
        cmd->sidemove = cmd->sidemove < 0.0f ? -maxSpeedRoot : maxSpeedRoot;
    } else if (cmd->forwardmove) {
        cmd->forwardmove = cmd->forwardmove < 0.0f ? -maxSpeed : maxSpeed;
    } else if (cmd->sidemove) {
        cmd->sidemove = cmd->sidemove < 0.0f ? -maxSpeed : maxSpeed;
    }
}

void Misc::updateClanTag(bool tagChanged) noexcept
{
    static std::string clanTag;

    if (tagChanged) {
        clanTag = miscConfig.clanTag;
        if (!clanTag.empty() && clanTag.front() != ' ' && clanTag.back() != ' ')
            clanTag.push_back(' ');
        return;
    }
    
    static auto lastTime = 0.0f;

    if (miscConfig.clocktag) {
        if (memory->globalVars->realtime - lastTime < 1.0f)
            return;

        const auto time = std::time(nullptr);
        const auto localTime = std::localtime(&time);
        char s[11];
        s[0] = '\0';
        snprintf(s, sizeof(s), "[%02d:%02d:%02d]", localTime->tm_hour, localTime->tm_min, localTime->tm_sec);
        lastTime = memory->globalVars->realtime;
        memory->setClanTag(s, s);
    } else if (miscConfig.customClanTag) {
        if (memory->globalVars->realtime - lastTime < 0.6f)
            return;

        if (miscConfig.animatedClanTag && !clanTag.empty()) {
            const auto offset = Helpers::utf8SeqLen(clanTag[0]);
            if (offset != -1 && static_cast<std::size_t>(offset) <= clanTag.length())
                std::rotate(clanTag.begin(), clanTag.begin() + offset, clanTag.end());
        }
        lastTime = memory->globalVars->realtime;
        memory->setClanTag(clanTag.c_str(), clanTag.c_str());
    }
}

void Misc::spectatorList() noexcept
{
    if (!miscConfig.spectatorList.enabled)
        return;

    GameData::Lock lock;

    const auto& observers = GameData::observers();

    if (std::ranges::none_of(observers, [](const auto& obs) { return obs.targetIsLocalPlayer; }) && !gui->isOpen())
        return;

    if (miscConfig.spectatorList.pos != ImVec2{}) {
        ImGui::SetNextWindowPos(miscConfig.spectatorList.pos);
        miscConfig.spectatorList.pos = {};
    }

    if (miscConfig.spectatorList.size != ImVec2{}) {
        ImGui::SetNextWindowSize(ImClamp(miscConfig.spectatorList.size, {}, ImGui::GetIO().DisplaySize));
        miscConfig.spectatorList.size = {};
    }

    ImGuiWindowFlags windowFlags = ImGuiWindowFlags_NoCollapse;
    if (!gui->isOpen())
        windowFlags |= ImGuiWindowFlags_NoInputs;
    if (miscConfig.spectatorList.noTitleBar)
        windowFlags |= ImGuiWindowFlags_NoTitleBar;

    if (!gui->isOpen())
        ImGui::PushStyleColor(ImGuiCol_TitleBg, ImGui::GetColorU32(ImGuiCol_TitleBgActive));

    ImGui::PushStyleVar(ImGuiStyleVar_WindowTitleAlign, { 0.5f, 0.5f });
    ImGui::Begin("Spectator list", nullptr, windowFlags);
    ImGui::PopStyleVar();

    if (!gui->isOpen())
        ImGui::PopStyleColor();

    for (const auto& observer : observers) {
        if (!observer.targetIsLocalPlayer)
            continue;

        if (const auto it = std::ranges::find(GameData::players(), observer.playerHandle, &PlayerData::handle); it != GameData::players().cend()) {
            ImGui::TextWrapped("%s", it->name.c_str());
        }
    }

    ImGui::End();
}

static void drawCrosshair(ImDrawList* drawList, const ImVec2& pos, ImU32 color) noexcept
{
    // dot
    drawList->AddRectFilled(pos - ImVec2{ 1, 1 }, pos + ImVec2{ 2, 2 }, color & IM_COL32_A_MASK);
    drawList->AddRectFilled(pos, pos + ImVec2{ 1, 1 }, color);

    // left
    drawList->AddRectFilled(ImVec2{ pos.x - 11, pos.y - 1 }, ImVec2{ pos.x - 3, pos.y + 2 }, color & IM_COL32_A_MASK);
    drawList->AddRectFilled(ImVec2{ pos.x - 10, pos.y }, ImVec2{ pos.x - 4, pos.y + 1 }, color);

    // right
    drawList->AddRectFilled(ImVec2{ pos.x + 4, pos.y - 1 }, ImVec2{ pos.x + 12, pos.y + 2 }, color & IM_COL32_A_MASK);
    drawList->AddRectFilled(ImVec2{ pos.x + 5, pos.y }, ImVec2{ pos.x + 11, pos.y + 1 }, color);

    // top (left with swapped x/y offsets)
    drawList->AddRectFilled(ImVec2{ pos.x - 1, pos.y - 11 }, ImVec2{ pos.x + 2, pos.y - 3 }, color & IM_COL32_A_MASK);
    drawList->AddRectFilled(ImVec2{ pos.x, pos.y - 10 }, ImVec2{ pos.x + 1, pos.y - 4 }, color);

    // bottom (right with swapped x/y offsets)
    drawList->AddRectFilled(ImVec2{ pos.x - 1, pos.y + 4 }, ImVec2{ pos.x + 2, pos.y + 12 }, color & IM_COL32_A_MASK);
    drawList->AddRectFilled(ImVec2{ pos.x, pos.y + 5 }, ImVec2{ pos.x + 1, pos.y + 11 }, color);
}

void Misc::noscopeCrosshair(ImDrawList* drawList) noexcept
{
    if (!miscConfig.noscopeCrosshair.asColorToggle().enabled)
        return;

    {
        GameData::Lock lock;
        if (const auto& local = GameData::local(); !local.exists || !local.alive || !local.noScope)
            return;
    }

    drawCrosshair(drawList, ImGui::GetIO().DisplaySize / 2, Helpers::calculateColor(miscConfig.noscopeCrosshair.asColorToggle().asColor4()));
}


static bool worldToScreen(const Vector& in, ImVec2& out) noexcept
{
    const auto& matrix = GameData::toScreenMatrix();

    const auto w = matrix._41 * in.x + matrix._42 * in.y + matrix._43 * in.z + matrix._44;
    if (w < 0.001f)
        return false;

    out = ImGui::GetIO().DisplaySize / 2.0f;
    out.x *= 1.0f + (matrix._11 * in.x + matrix._12 * in.y + matrix._13 * in.z + matrix._14) / w;
    out.y *= 1.0f - (matrix._21 * in.x + matrix._22 * in.y + matrix._23 * in.z + matrix._24) / w;
    out = ImFloor(out);
    return true;
}

void Misc::recoilCrosshair(ImDrawList* drawList) noexcept
{
    if (!miscConfig.recoilCrosshair.asColorToggle().enabled)
        return;

    GameData::Lock lock;
    const auto& localPlayerData = GameData::local();

    if (!localPlayerData.exists || !localPlayerData.alive)
        return;

    if (!localPlayerData.shooting)
        return;

    if (ImVec2 pos; worldToScreen(localPlayerData.aimPunch, pos))
        drawCrosshair(drawList, pos, Helpers::calculateColor(miscConfig.recoilCrosshair.asColorToggle().asColor4()));
}

void Misc::watermark() noexcept
{
    if (!miscConfig.watermark.enabled)
        return;

    ImGuiWindowFlags windowFlags = ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_AlwaysAutoResize;
    if (!gui->isOpen())
        windowFlags |= ImGuiWindowFlags_NoInputs;

    ImGui::SetNextWindowBgAlpha(0.3f);
    ImGui::Begin("Watermark", nullptr, windowFlags);

    static auto frameRate = 1.0f;
    frameRate = 0.9f * frameRate + 0.1f * memory->globalVars->absoluteFrameTime;

    ImGui::Text("FTP | %d fps | %d ms", frameRate != 0.0f ? static_cast<int>(1 / frameRate) : 0, GameData::getNetOutgoingLatency());
    ImGui::End();
}

void Misc::prepareRevolver(UserCmd* cmd) noexcept
{
    constexpr auto timeToTicks = [](float time) {  return static_cast<int>(0.5f + time / memory->globalVars->intervalPerTick); };
    constexpr float revolverPrepareTime{ 0.234375f };

    static float readyTime;
    if (miscConfig.prepareRevolver && localPlayer && (!miscConfig.prepareRevolverKey.isSet() || miscConfig.prepareRevolverKey.isDown())) {
        const auto activeWeapon = localPlayer->getActiveWeapon();
        if (activeWeapon && activeWeapon->itemDefinitionIndex2() == WeaponId::Revolver) {
            if (!readyTime) readyTime = memory->globalVars->serverTime() + revolverPrepareTime;
            auto ticksToReady = timeToTicks(readyTime - memory->globalVars->serverTime() - interfaces->engine->getNetworkChannel()->getLatency(0));
            if (ticksToReady > 0 && ticksToReady <= timeToTicks(revolverPrepareTime))
                cmd->buttons |= UserCmd::IN_ATTACK;
            else
                readyTime = 0.0f;
        }
    }
}

void Misc::fastPlant(UserCmd* cmd) noexcept
{
    if (!miscConfig.fastPlant)
        return;

    static auto plantAnywhere = interfaces->cvar->findVar("mp_plant_c4_anywhere");

    if (plantAnywhere->getInt())
        return;

    if (!localPlayer || !localPlayer->isAlive() || (localPlayer->inBombZone() && localPlayer->flags() & 1))
        return;

    const auto activeWeapon = localPlayer->getActiveWeapon();
    if (!activeWeapon || activeWeapon->getClientClass()->classId != ClassId::C4)
        return;

    cmd->buttons &= ~UserCmd::IN_ATTACK;

    constexpr auto doorRange = 200.0f;

    Trace trace;
    const auto startPos = localPlayer->getEyePosition();
    const auto endPos = startPos + Vector::fromAngle(cmd->viewangles) * doorRange;
    interfaces->engineTrace->traceRay({ startPos, endPos }, 0x46004009, localPlayer.get(), trace);

    if (!trace.entity || trace.entity->getClientClass()->classId != ClassId::PropDoorRotating)
        cmd->buttons &= ~UserCmd::IN_USE;
}

void Misc::fastStop(UserCmd* cmd) noexcept
{
    if (!miscConfig.fastStop)
        return;

    if (!localPlayer || !localPlayer->isAlive())
        return;

    if (localPlayer->moveType() == MoveType::NOCLIP || localPlayer->moveType() == MoveType::LADDER || !(localPlayer->flags() & 1) || cmd->buttons & UserCmd::IN_JUMP)
        return;

    if (cmd->buttons & (UserCmd::IN_MOVELEFT | UserCmd::IN_MOVERIGHT | UserCmd::IN_FORWARD | UserCmd::IN_BACK))
        return;
    
    const auto velocity = localPlayer->velocity();
    const auto speed = velocity.length2D();
    if (speed < 15.0f)
        return;
    
    Vector direction = velocity.toAngle();
    direction.y = cmd->viewangles.y - direction.y;

    const auto negatedDirection = Vector::fromAngle(direction) * -speed;
    cmd->forwardmove = negatedDirection.x;
    cmd->sidemove = negatedDirection.y;
}

void Misc::drawBombTimer() noexcept
{
    if (!miscConfig.bombTimer.enabled)
        return;

    GameData::Lock lock;
    
    const auto& plantedC4 = GameData::plantedC4();
    if (plantedC4.blowTime == 0.0f && !gui->isOpen())
        return;

    if (!gui->isOpen()) {
        ImGui::SetNextWindowBgAlpha(0.3f);
    }

    static float windowWidth = 200.0f;
    ImGui::SetNextWindowPos({ (ImGui::GetIO().DisplaySize.x - 200.0f) / 2.0f, 60.0f }, ImGuiCond_Once);
    ImGui::SetNextWindowSize({ windowWidth, 0 }, ImGuiCond_Once);

    if (!gui->isOpen())
        ImGui::SetNextWindowSize({ windowWidth, 0 });

    ImGui::SetNextWindowSizeConstraints({ 0, -1 }, { FLT_MAX, -1 });
    ImGui::Begin("Bomb Timer", nullptr, ImGuiWindowFlags_NoTitleBar | (gui->isOpen() ? 0 : ImGuiWindowFlags_NoInputs | ImGuiWindowFlags_NoDecoration));

    std::ostringstream ss; ss << "Bomb on " << (!plantedC4.bombsite ? 'A' : 'B') << " : " << std::fixed << std::showpoint << std::setprecision(3) << (std::max)(plantedC4.blowTime - memory->globalVars->currenttime, 0.0f) << " s";

    ImGui::textUnformattedCentered(ss.str().c_str());

    ImGui::PushStyleColor(ImGuiCol_PlotHistogram, Helpers::calculateColor(miscConfig.bombTimer.asColor3()));
    ImGui::PushStyleColor(ImGuiCol_FrameBg, ImVec4{ 0.2f, 0.2f, 0.2f, 1.0f });
    ImGui::progressBarFullWidth((plantedC4.blowTime - memory->globalVars->currenttime) / plantedC4.timerLength, 5.0f);

    if (plantedC4.defuserHandle != -1) {
        const bool canDefuse = plantedC4.blowTime >= plantedC4.defuseCountDown;

        if (plantedC4.defuserHandle == GameData::local().handle) {
            if (canDefuse) {
                ImGui::PushStyleColor(ImGuiCol_Text, IM_COL32(0, 255, 0, 255));
                ImGui::textUnformattedCentered("You can defuse!");
            } else {
                ImGui::PushStyleColor(ImGuiCol_Text, IM_COL32(255, 0, 0, 255));
                ImGui::textUnformattedCentered("You can not defuse!");
            }
            ImGui::PopStyleColor();
        } else if (const auto defusingPlayer = GameData::playerByHandle(plantedC4.defuserHandle)) {
            std::ostringstream ss; ss << defusingPlayer->name << " is defusing: " << std::fixed << std::showpoint << std::setprecision(3) << (std::max)(plantedC4.defuseCountDown - memory->globalVars->currenttime, 0.0f) << " s";

            ImGui::textUnformattedCentered(ss.str().c_str());

            ImGui::PushStyleColor(ImGuiCol_PlotHistogram, canDefuse ? IM_COL32(0, 255, 0, 255) : IM_COL32(255, 0, 0, 255));
            ImGui::progressBarFullWidth((plantedC4.defuseCountDown - memory->globalVars->currenttime) / plantedC4.defuseLength, 5.0f);
            ImGui::PopStyleColor();
        }
    }

    windowWidth = ImGui::GetCurrentWindow()->SizeFull.x;

    ImGui::PopStyleColor(2);
    ImGui::End();
}

void Misc::stealNames() noexcept
{
    if (!miscConfig.nameStealer)
        return;

    if (!localPlayer)
        return;

    static std::vector<int> stolenIds;

    for (int i = 1; i <= memory->globalVars->maxClients; ++i) {
        const auto entity = interfaces->entityList->getEntity(i);

        if (!entity || entity == localPlayer.get())
            continue;

        PlayerInfo playerInfo;
        if (!interfaces->engine->getPlayerInfo(entity->index(), playerInfo))
            continue;

        if (playerInfo.fakeplayer || std::ranges::find(stolenIds, playerInfo.userId) != stolenIds.cend())
            continue;

        if (changeName(false, (std::string{ playerInfo.name } +'\x1').c_str(), 1.0f))
            stolenIds.push_back(playerInfo.userId);

        return;
    }
    stolenIds.clear();
}

void Misc::disablePanoramablur() noexcept
{
    static auto blur = interfaces->cvar->findVar("@panorama_disable_blur");
    blur->setValue(miscConfig.disablePanoramablur);
}

void Misc::quickReload(UserCmd* cmd) noexcept
{
    if (miscConfig.quickReload) {
        static Entity* reloadedWeapon{ nullptr };

        if (reloadedWeapon) {
            for (auto weaponHandle : localPlayer->weapons()) {
                if (weaponHandle == -1)
                    break;

                if (interfaces->entityList->getEntityFromHandle(weaponHandle) == reloadedWeapon) {
                    cmd->weaponselect = reloadedWeapon->index();
                    cmd->weaponsubtype = reloadedWeapon->getWeaponSubType();
                    break;
                }
            }
            reloadedWeapon = nullptr;
        }

        if (auto activeWeapon{ localPlayer->getActiveWeapon() }; activeWeapon && activeWeapon->isInReload() && activeWeapon->clip() == activeWeapon->getWeaponData()->maxClip) {
            reloadedWeapon = activeWeapon;

            for (auto weaponHandle : localPlayer->weapons()) {
                if (weaponHandle == -1)
                    break;

                if (auto weapon{ interfaces->entityList->getEntityFromHandle(weaponHandle) }; weapon && weapon != reloadedWeapon) {
                    cmd->weaponselect = weapon->index();
                    cmd->weaponsubtype = weapon->getWeaponSubType();
                    break;
                }
            }
        }
    }
}

bool Misc::changeName(bool reconnect, const char* newName, float delay) noexcept
{
    static auto exploitInitialized{ false };

    static auto name{ interfaces->cvar->findVar("name") };

    if (reconnect) {
        exploitInitialized = false;
        return false;
    }

    if (!exploitInitialized && interfaces->engine->isInGame()) {
        if (PlayerInfo playerInfo; localPlayer && interfaces->engine->getPlayerInfo(localPlayer->index(), playerInfo) && (!strcmp(playerInfo.name, "?empty") || !strcmp(playerInfo.name, "\n\xAD\xAD\xAD"))) {
            exploitInitialized = true;
        } else {
            name->onChangeCallbacks.size = 0;
            name->setValue("\n\xAD\xAD\xAD");
            return false;
        }
    }

    static auto nextChangeTime{ 0.0f };
    if (nextChangeTime <= memory->globalVars->realtime) {
        name->setValue(newName);
        nextChangeTime = memory->globalVars->realtime + delay;
        return true;
    }
    return false;
}

void Misc::bunnyHop(UserCmd* cmd) noexcept
{
    if (!localPlayer)
        return;

    static auto wasLastTimeOnGround{ localPlayer->flags() & 1 };

    if (miscConfig.bunnyHop && !(localPlayer->flags() & 1) && localPlayer->moveType() != MoveType::LADDER && !wasLastTimeOnGround)
        cmd->buttons &= ~UserCmd::IN_JUMP;

    wasLastTimeOnGround = localPlayer->flags() & 1;
}

void Misc::fakeBan(bool set) noexcept
{
    static bool shouldSet = false;

    if (set)
        shouldSet = set;

    if (shouldSet && interfaces->engine->isInGame() && changeName(false, std::string{ "\x1\xB" }.append(std::string{ static_cast<char>(miscConfig.banColor + 1) }).append(miscConfig.banText).append("\x1").c_str(), 5.0f))
        shouldSet = false;
}

void Misc::nadePredict() noexcept
{
    static auto nadeVar{ interfaces->cvar->findVar("cl_grenadepreview") };

    nadeVar->onChangeCallbacks.size = 0;
    nadeVar->setValue(miscConfig.nadePredict);
}

void Misc::fixTabletSignal() noexcept
{
    if (miscConfig.fixTabletSignal && localPlayer) {
        if (auto activeWeapon{ localPlayer->getActiveWeapon() }; activeWeapon && activeWeapon->getClientClass()->classId == ClassId::Tablet)
            activeWeapon->tabletReceptionIsBlocked() = false;
    }
}

void Misc::killMessage(GameEvent& event) noexcept
{
    if (!miscConfig.killMessage)
        return;

    if (!localPlayer || !localPlayer->isAlive())
        return;

    if (const auto localUserId = localPlayer->getUserId(); event.getInt("attacker") != localUserId || event.getInt("userid") == localUserId)
        return;

    std::string cmd = "say \"";
    cmd += miscConfig.killMessageString;
    cmd += '"';
    interfaces->engine->clientCmdUnrestricted(cmd.c_str());
}

void Misc::fixMovement(UserCmd* cmd, float yaw) noexcept
{
    if (miscConfig.fixMovement) {
        float oldYaw = yaw + (yaw < 0.0f ? 360.0f : 0.0f);
        float newYaw = cmd->viewangles.y + (cmd->viewangles.y < 0.0f ? 360.0f : 0.0f);
        float yawDelta = newYaw < oldYaw ? fabsf(newYaw - oldYaw) : 360.0f - fabsf(newYaw - oldYaw);
        yawDelta = 360.0f - yawDelta;

        const float forwardmove = cmd->forwardmove;
        const float sidemove = cmd->sidemove;
        cmd->forwardmove = std::cos(Helpers::deg2rad(yawDelta)) * forwardmove + std::cos(Helpers::deg2rad(yawDelta + 90.0f)) * sidemove;
        cmd->sidemove = std::sin(Helpers::deg2rad(yawDelta)) * forwardmove + std::sin(Helpers::deg2rad(yawDelta + 90.0f)) * sidemove;
    }
}

void Misc::antiAfkKick(UserCmd* cmd) noexcept
{
    if (miscConfig.antiAfkKick && cmd->commandNumber % 2)
        cmd->buttons |= 1 << 26;
}

void Misc::fixAnimationLOD(FrameStage stage) noexcept
{
#ifdef _WIN32
    if (miscConfig.fixAnimationLOD && stage == FrameStage::RENDER_START) {
        if (!localPlayer)
            return;

        for (int i = 1; i <= interfaces->engine->getMaxClients(); i++) {
            Entity* entity = interfaces->entityList->getEntity(i);
            if (!entity || entity == localPlayer.get() || entity->isDormant() || !entity->isAlive()) continue;
            *reinterpret_cast<int*>(entity + 0xA28) = 0;
            *reinterpret_cast<int*>(entity + 0xA30) = memory->globalVars->framecount;
        }
    }
#endif
}

void Misc::autoPistol(UserCmd* cmd) noexcept
{
    if (miscConfig.autoPistol && localPlayer) {
        const auto activeWeapon = localPlayer->getActiveWeapon();
        if (activeWeapon && activeWeapon->isPistol() && activeWeapon->nextPrimaryAttack() > memory->globalVars->serverTime()) {
            if (activeWeapon->itemDefinitionIndex2() == WeaponId::Revolver)
                cmd->buttons &= ~UserCmd::IN_ATTACK2;
            else
                cmd->buttons &= ~UserCmd::IN_ATTACK;
        }
    }
}

void Misc::chokePackets(bool& sendPacket) noexcept
{
    if (!miscConfig.chokedPacketsKey.isSet() || miscConfig.chokedPacketsKey.isDown())
        sendPacket = interfaces->engine->getNetworkChannel()->chokedPackets >= miscConfig.chokedPackets;
}

void Misc::autoReload(UserCmd* cmd) noexcept
{
    if (miscConfig.autoReload && localPlayer) {
        const auto activeWeapon = localPlayer->getActiveWeapon();
        if (activeWeapon && getWeaponIndex(activeWeapon->itemDefinitionIndex2()) && !activeWeapon->clip())
            cmd->buttons &= ~(UserCmd::IN_ATTACK | UserCmd::IN_ATTACK2);
    }
}

void Misc::revealRanks(UserCmd* cmd) noexcept
{
    if (miscConfig.revealRanks && cmd->buttons & UserCmd::IN_SCORE)
        interfaces->client->dispatchUserMessage(50, 0, 0, nullptr);
}

void Misc::autoStrafe(UserCmd* cmd) noexcept
{
    if (localPlayer
        && miscConfig.autoStrafe
        && !(localPlayer->flags() & 1)
        && localPlayer->moveType() != MoveType::NOCLIP) {
        if (cmd->mousedx < 0)
            cmd->sidemove = -450.0f;
        else if (cmd->mousedx > 0)
            cmd->sidemove = 450.0f;
    }
}

void Misc::removeCrouchCooldown(UserCmd* cmd) noexcept
{
    if (miscConfig.fastDuck)
        cmd->buttons |= UserCmd::IN_BULLRUSH;
}

void Misc::moonwalk(UserCmd* cmd) noexcept
{
    if (miscConfig.moonwalk && localPlayer && localPlayer->moveType() != MoveType::LADDER)
        cmd->buttons ^= UserCmd::IN_FORWARD | UserCmd::IN_BACK | UserCmd::IN_MOVELEFT | UserCmd::IN_MOVERIGHT;
}

void Misc::playHitSound(GameEvent& event) noexcept
{
    if (!miscConfig.hitSound)
        return;

    if (!localPlayer)
        return;

    if (const auto localUserId = localPlayer->getUserId(); event.getInt("attacker") != localUserId || event.getInt("userid") == localUserId)
        return;

    constexpr std::array hitSounds{
        "play physics/metal/metal_solid_impact_bullet2",
        "play buttons/arena_switch_press_02",
        "play training/timer_bell",
        "play physics/glass/glass_impact_bullet1"
    };

    if (static_cast<std::size_t>(miscConfig.hitSound - 1) < hitSounds.size())
        interfaces->engine->clientCmdUnrestricted(hitSounds[miscConfig.hitSound - 1]);
    else if (miscConfig.hitSound == 5)
        interfaces->engine->clientCmdUnrestricted(("play " + miscConfig.customHitSound).c_str());
}

void Misc::killSound(GameEvent& event) noexcept
{
    if (!miscConfig.killSound)
        return;

    if (!localPlayer || !localPlayer->isAlive())
        return;

    if (const auto localUserId = localPlayer->getUserId(); event.getInt("attacker") != localUserId || event.getInt("userid") == localUserId)
        return;

    constexpr std::array killSounds{
        "play physics/metal/metal_solid_impact_bullet2",
        "play buttons/arena_switch_press_02",
        "play training/timer_bell",
        "play physics/glass/glass_impact_bullet1"
    };

    if (static_cast<std::size_t>(miscConfig.killSound - 1) < killSounds.size())
        interfaces->engine->clientCmdUnrestricted(killSounds[miscConfig.killSound - 1]);
    else if (miscConfig.killSound == 5)
        interfaces->engine->clientCmdUnrestricted(("play " + miscConfig.customKillSound).c_str());
}

void Misc::purchaseList(GameEvent* event) noexcept
{
    static std::mutex mtx;
    std::scoped_lock _{ mtx };

    struct PlayerPurchases {
        int totalCost;
        std::unordered_map<std::string, int> items;
    };

    static std::unordered_map<int, PlayerPurchases> playerPurchases;
    static std::unordered_map<std::string, int> purchaseTotal;
    static int totalCost;

    static auto freezeEnd = 0.0f;

    if (event) {
        switch (fnv::hashRuntime(event->getName())) {
        case fnv::hash("item_purchase"): {
            const auto player = interfaces->entityList->getEntity(interfaces->engine->getPlayerForUserID(event->getInt("userid")));

            if (player && localPlayer && memory->isOtherEnemy(player, localPlayer.get())) {
                if (const auto definition = memory->itemSystem()->getItemSchema()->getItemDefinitionByName(event->getString("weapon"))) {
                    auto& purchase = playerPurchases[player->handle()];
                    if (const auto weaponInfo = memory->weaponSystem->getWeaponInfo(definition->getWeaponId())) {
                        purchase.totalCost += weaponInfo->price;
                        totalCost += weaponInfo->price;
                    }
                    const std::string weapon = interfaces->localize->findAsUTF8(definition->getItemBaseName());
                    ++purchaseTotal[weapon];
                    ++purchase.items[weapon];
                }
            }
            break;
        }
        case fnv::hash("round_start"):
            freezeEnd = 0.0f;
            playerPurchases.clear();
            purchaseTotal.clear();
            totalCost = 0;
            break;
        case fnv::hash("round_freeze_end"):
            freezeEnd = memory->globalVars->realtime;
            break;
        }
    } else {
        if (!miscConfig.purchaseList.enabled)
            return;

        static const auto mp_buytime = interfaces->cvar->findVar("mp_buytime");

        if ((!interfaces->engine->isInGame() || freezeEnd != 0.0f && memory->globalVars->realtime > freezeEnd + (!miscConfig.purchaseList.onlyDuringFreezeTime ? mp_buytime->getFloat() : 0.0f) || playerPurchases.empty() || purchaseTotal.empty()) && !gui->isOpen())
            return;

        ImGui::SetNextWindowSize({ 200.0f, 200.0f }, ImGuiCond_Once);

        ImGuiWindowFlags windowFlags = ImGuiWindowFlags_NoCollapse;
        if (!gui->isOpen())
            windowFlags |= ImGuiWindowFlags_NoInputs;
        if (miscConfig.purchaseList.noTitleBar)
            windowFlags |= ImGuiWindowFlags_NoTitleBar;

        ImGui::PushStyleVar(ImGuiStyleVar_WindowTitleAlign, { 0.5f, 0.5f });
        ImGui::Begin("Purchases", nullptr, windowFlags);
        ImGui::PopStyleVar();

        if (miscConfig.purchaseList.mode == PurchaseList::Details) {
            GameData::Lock lock;

            for (const auto& [handle, purchases] : playerPurchases) {
                std::string s;
                s.reserve(std::accumulate(purchases.items.begin(), purchases.items.end(), 0, [](int length, const auto& p) { return length + p.first.length() + 2; }));
                for (const auto& purchasedItem : purchases.items) {
                    if (purchasedItem.second > 1)
                        s += std::to_string(purchasedItem.second) + "x ";
                    s += purchasedItem.first + ", ";
                }

                if (s.length() >= 2)
                    s.erase(s.length() - 2);

                if (const auto player = GameData::playerByHandle(handle)) {
                    if (miscConfig.purchaseList.showPrices)
                        ImGui::TextWrapped("%s $%d: %s", player->name.c_str(), purchases.totalCost, s.c_str());
                    else
                        ImGui::TextWrapped("%s: %s", player->name.c_str(), s.c_str());
                }
            }
        } else if (miscConfig.purchaseList.mode == PurchaseList::Summary) {
            for (const auto& purchase : purchaseTotal)
                ImGui::TextWrapped("%d x %s", purchase.second, purchase.first.c_str());

            if (miscConfig.purchaseList.showPrices && totalCost > 0) {
                ImGui::Separator();
                ImGui::TextWrapped("Total: $%d", totalCost);
            }
        }
        ImGui::End();
    }
}

void Misc::oppositeHandKnife(FrameStage stage) noexcept
{
    if (!miscConfig.oppositeHandKnife)
        return;

    if (!localPlayer)
        return;

    if (stage != FrameStage::RENDER_START && stage != FrameStage::RENDER_END)
        return;

    static const auto cl_righthand = interfaces->cvar->findVar("cl_righthand");
    static bool original;

    if (stage == FrameStage::RENDER_START) {
        original = cl_righthand->getInt();

        if (const auto activeWeapon = localPlayer->getActiveWeapon()) {
            if (const auto classId = activeWeapon->getClientClass()->classId; classId == ClassId::Knife || classId == ClassId::KnifeGG)
                cl_righthand->setValue(!original);
        }
    } else {
        cl_righthand->setValue(original);
    }
}

static std::vector<std::uint64_t> reportedPlayers;
static int reportbotRound;

void Misc::runReportbot() noexcept
{
    if (!miscConfig.reportbot.enabled)
        return;

    if (!localPlayer)
        return;

    static auto lastReportTime = 0.0f;

    if (lastReportTime + miscConfig.reportbot.delay > memory->globalVars->realtime)
        return;

    if (reportbotRound >= miscConfig.reportbot.rounds)
        return;

    for (int i = 1; i <= interfaces->engine->getMaxClients(); ++i) {
        const auto entity = interfaces->entityList->getEntity(i);

        if (!entity || entity == localPlayer.get())
            continue;

        if (miscConfig.reportbot.target != 2 && (entity->isOtherEnemy(localPlayer.get()) ? miscConfig.reportbot.target != 0 : miscConfig.reportbot.target != 1))
            continue;

        PlayerInfo playerInfo;
        if (!interfaces->engine->getPlayerInfo(i, playerInfo))
            continue;

        if (playerInfo.fakeplayer || std::ranges::find(reportedPlayers, playerInfo.xuid) != reportedPlayers.cend())
            continue;

        std::string report;

        if (miscConfig.reportbot.textAbuse)
            report += "textabuse,";
        if (miscConfig.reportbot.griefing)
            report += "grief,";
        if (miscConfig.reportbot.wallhack)
            report += "wallhack,";
        if (miscConfig.reportbot.aimbot)
            report += "aimbot,";
        if (miscConfig.reportbot.other)
            report += "speedhack,";

        if (!report.empty()) {
            memory->submitReport(std::to_string(playerInfo.xuid).c_str(), report.c_str());
            lastReportTime = memory->globalVars->realtime;
            reportedPlayers.push_back(playerInfo.xuid);
        }
        return;
    }

    reportedPlayers.clear();
    ++reportbotRound;
}

void Misc::resetReportbot() noexcept
{
    reportbotRound = 0;
    reportedPlayers.clear();
}

void Misc::preserveKillfeed(bool roundStart) noexcept
{
    if (!miscConfig.preserveKillfeed.enabled)
        return;

    static auto nextUpdate = 0.0f;

    if (roundStart) {
        nextUpdate = memory->globalVars->realtime + 10.0f;
        return;
    }

    if (nextUpdate > memory->globalVars->realtime)
        return;

    nextUpdate = memory->globalVars->realtime + 2.0f;

    const auto deathNotice = std::uintptr_t(memory->findHudElement(memory->hud, "CCSGO_HudDeathNotice"));
    if (!deathNotice)
        return;

    const auto deathNoticePanel = (*(UIPanel**)(*reinterpret_cast<std::uintptr_t*>(deathNotice WIN32_LINUX(-20 + 88, -32 + 128)) + sizeof(std::uintptr_t)));

    const auto childPanelCount = deathNoticePanel->getChildCount();

    for (int i = 0; i < childPanelCount; ++i) {
        const auto child = deathNoticePanel->getChild(i);
        if (!child)
            continue;

        if (child->hasClass("DeathNotice_Killer") && (!miscConfig.preserveKillfeed.onlyHeadshots || child->hasClass("DeathNoticeHeadShot")))
            child->setAttributeFloat("SpawnTime", memory->globalVars->currenttime);
    }
}

void Misc::voteRevealer(GameEvent& event) noexcept
{
    if (!miscConfig.revealVotes)
        return;

    const auto entity = interfaces->entityList->getEntity(event.getInt("entityid"));
    if (!entity || !entity->isPlayer())
        return;
    
    const auto votedYes = event.getInt("vote_option") == 0;
    const auto isLocal = localPlayer && entity == localPlayer.get();
    const char color = votedYes ? '\x06' : '\x07';

    memory->clientMode->getHudChat()->printf(0, " \x0C\u2022FTP\u2022 %c%s\x01 voted %c%s\x01", isLocal ? '\x01' : color, isLocal ? "You" : entity->getPlayerName().c_str(), color, votedYes ? "Yes" : "No");
}

// ImGui::ShadeVertsLinearColorGradientKeepAlpha() modified to do interpolation in HSV
static void shadeVertsHSVColorGradientKeepAlpha(ImDrawList* draw_list, int vert_start_idx, int vert_end_idx, ImVec2 gradient_p0, ImVec2 gradient_p1, ImU32 col0, ImU32 col1)
{
    ImVec2 gradient_extent = gradient_p1 - gradient_p0;
    float gradient_inv_length2 = 1.0f / ImLengthSqr(gradient_extent);
    ImDrawVert* vert_start = draw_list->VtxBuffer.Data + vert_start_idx;
    ImDrawVert* vert_end = draw_list->VtxBuffer.Data + vert_end_idx;

    ImVec4 col0HSV = ImGui::ColorConvertU32ToFloat4(col0);
    ImVec4 col1HSV = ImGui::ColorConvertU32ToFloat4(col1);
    ImGui::ColorConvertRGBtoHSV(col0HSV.x, col0HSV.y, col0HSV.z, col0HSV.x, col0HSV.y, col0HSV.z);
    ImGui::ColorConvertRGBtoHSV(col1HSV.x, col1HSV.y, col1HSV.z, col1HSV.x, col1HSV.y, col1HSV.z);
    ImVec4 colDelta = col1HSV - col0HSV;

    for (ImDrawVert* vert = vert_start; vert < vert_end; vert++)
    {
        float d = ImDot(vert->pos - gradient_p0, gradient_extent);
        float t = ImClamp(d * gradient_inv_length2, 0.0f, 1.0f);

        float h = col0HSV.x + colDelta.x * t;
        float s = col0HSV.y + colDelta.y * t;
        float v = col0HSV.z + colDelta.z * t;

        ImVec4 rgb;
        ImGui::ColorConvertHSVtoRGB(h, s, v, rgb.x, rgb.y, rgb.z);
        vert->col = (ImGui::ColorConvertFloat4ToU32(rgb) & ~IM_COL32_A_MASK) | (vert->col & IM_COL32_A_MASK);
    }
}

void Misc::drawOffscreenEnemies(ImDrawList* drawList) noexcept
{
    if (!miscConfig.offscreenEnemies.enabled)
        return;

    const auto yaw = Helpers::deg2rad(interfaces->engine->getViewAngles().y);

    GameData::Lock lock;
    for (auto& player : GameData::players()) {
        if ((player.dormant && player.fadingAlpha() == 0.0f) || !player.alive || !player.enemy || player.inViewFrustum)
            continue;

        const auto positionDiff = GameData::local().origin - player.origin;

        auto x = std::cos(yaw) * positionDiff.y - std::sin(yaw) * positionDiff.x;
        auto y = std::cos(yaw) * positionDiff.x + std::sin(yaw) * positionDiff.y;
        if (const auto len = std::sqrt(x * x + y * y); len != 0.0f) {
            x /= len;
            y /= len;
        }

        constexpr auto avatarRadius = 13.0f;
        constexpr auto triangleSize = 10.0f;

        const auto pos = ImGui::GetIO().DisplaySize / 2 + ImVec2{ x, y } * 200;
        const auto trianglePos = pos + ImVec2{ x, y } * (avatarRadius + (miscConfig.offscreenEnemies.healthBar.enabled ? 5 : 3));

        Helpers::setAlphaFactor(player.fadingAlpha());
        const auto white = Helpers::calculateColor(255, 255, 255, 255);
        const auto background = Helpers::calculateColor(0, 0, 0, 80);
        const auto color = Helpers::calculateColor(miscConfig.offscreenEnemies.asColor4());
        const auto healthBarColor = miscConfig.offscreenEnemies.healthBar.type == HealthBar::HealthBased ? Helpers::healthColor(std::clamp(player.health / 100.0f, 0.0f, 1.0f)) : Helpers::calculateColor(miscConfig.offscreenEnemies.healthBar.asColor4());
        Helpers::setAlphaFactor(1.0f);

        const ImVec2 trianglePoints[]{
            trianglePos + ImVec2{  0.4f * y, -0.4f * x } * triangleSize,
            trianglePos + ImVec2{  1.0f * x,  1.0f * y } * triangleSize,
            trianglePos + ImVec2{ -0.4f * y,  0.4f * x } * triangleSize
        };

        drawList->AddConvexPolyFilled(trianglePoints, 3, color);
        drawList->AddCircleFilled(pos, avatarRadius + 1, white & IM_COL32_A_MASK, 40);

        const auto texture = player.getAvatarTexture();

        const bool pushTextureId = drawList->_TextureIdStack.empty() || texture != drawList->_TextureIdStack.back();
        if (pushTextureId)
            drawList->PushTextureID(texture);

        const int vertStartIdx = drawList->VtxBuffer.Size;
        drawList->AddCircleFilled(pos, avatarRadius, white, 40);
        const int vertEndIdx = drawList->VtxBuffer.Size;
        ImGui::ShadeVertsLinearUV(drawList, vertStartIdx, vertEndIdx, pos - ImVec2{ avatarRadius, avatarRadius }, pos + ImVec2{ avatarRadius, avatarRadius }, { 0, 0 }, { 1, 1 }, true);

        if (pushTextureId)
            drawList->PopTextureID();

        if (miscConfig.offscreenEnemies.healthBar.enabled) {
            const auto radius = avatarRadius + 2;
            const auto healthFraction = std::clamp(player.health / 100.0f, 0.0f, 1.0f);

            drawList->AddCircle(pos, radius, background, 40, 3.0f);

            const int vertStartIdx = drawList->VtxBuffer.Size;
            if (healthFraction == 1.0f) { // sometimes PathArcTo is missing one top pixel when drawing a full circle, so draw it with AddCircle
                drawList->AddCircle(pos, radius, healthBarColor, 40, 2.0f);
            } else {
                constexpr float pi = std::numbers::pi_v<float>;
                drawList->PathArcTo(pos, radius - 0.5f, pi / 2 - pi * healthFraction, pi / 2 + pi * healthFraction, 40);
                drawList->PathStroke(healthBarColor, false, 2.0f);
            }
            const int vertEndIdx = drawList->VtxBuffer.Size;

            if (miscConfig.offscreenEnemies.healthBar.type == HealthBar::Gradient)
                shadeVertsHSVColorGradientKeepAlpha(drawList, vertStartIdx, vertEndIdx, pos - ImVec2{ 0.0f, radius }, pos + ImVec2{ 0.0f, radius }, IM_COL32(0, 255, 0, 255), IM_COL32(255, 0, 0, 255));
        }
    }
}

void Misc::autoAccept(const char* soundEntry) noexcept
{
    if (!miscConfig.autoAccept)
        return;

    if (std::strcmp(soundEntry, "UIPanorama.popup_accept_match_beep"))
        return;

    if (const auto idx = memory->registeredPanoramaEvents->find(memory->makePanoramaSymbol("MatchAssistedAccept")); idx != -1) {
        if (const auto eventPtr = memory->registeredPanoramaEvents->memory[idx].value.makeEvent(nullptr))
            interfaces->panoramaUIEngine->accessUIEngine()->dispatchEvent(eventPtr);
    }

#ifdef _WIN32
    auto window = FindWindowW(L"Valve001", NULL);
    FLASHWINFO flash{ sizeof(FLASHWINFO), window, FLASHW_TRAY | FLASHW_TIMERNOFG, 0, 0 };
    FlashWindowEx(&flash);
    ShowWindow(window, SW_RESTORE);
#endif
}

void Misc::updateEventListeners(bool forceRemove) noexcept
{
    class PurchaseEventListener : public GameEventListener {
    public:
        void fireGameEvent(GameEvent* event) override { purchaseList(event); }
    };

    static PurchaseEventListener listener;
    static bool listenerRegistered = false;

    if (miscConfig.purchaseList.enabled && !listenerRegistered) {
        interfaces->gameEventManager->addListener(&listener, "item_purchase");
        listenerRegistered = true;
    } else if ((!miscConfig.purchaseList.enabled || forceRemove) && listenerRegistered) {
        interfaces->gameEventManager->removeListener(&listener);
        listenerRegistered = false;
    }
}

void Misc::updateInput() noexcept
{

}

static bool windowOpen = false;

void Misc::menuBarItem() noexcept
{
    if (ImGui::MenuItem("Misc")) {
        windowOpen = true;
        ImGui::SetWindowFocus("Misc");
        ImGui::SetWindowPos("Misc", { 100.0f, 100.0f });
    }
}

void Misc::tabItem() noexcept
{
    if (ImGui::BeginTabItem("Misc")) {
        drawGUI(true);
        ImGui::EndTabItem();
    }
}

void Misc::drawGUI(bool contentOnly) noexcept
{
    if (!contentOnly) {
        if (!windowOpen)
            return;
        ImGui::SetNextWindowSize({ 580.0f, 0.0f });
        ImGui::Begin("Misc", &windowOpen, ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoResize
            | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoScrollWithMouse);
    }
    ImGui::Columns(2, nullptr, false);
    ImGui::SetColumnOffset(1, 230.0f);
    ImGui::hotkey("Menu Key", miscConfig.menuKey);
    ImGui::Checkbox("Anti AFK kick", &miscConfig.antiAfkKick);
    ImGui::Checkbox("Auto strafe", &miscConfig.autoStrafe);
    ImGui::Checkbox("Bunny hop", &miscConfig.bunnyHop);
    ImGui::Checkbox("Fast duck", &miscConfig.fastDuck);
    ImGui::Checkbox("Moonwalk", &miscConfig.moonwalk);
    ImGui::Checkbox("Edge Jump", &miscConfig.edgejump);
    ImGui::SameLine();
    ImGui::PushID("Edge Jump Key");
    ImGui::hotkey("", miscConfig.edgejumpkey);
    ImGui::PopID();
    ImGui::Checkbox("Slowwalk", &miscConfig.slowwalk);
    ImGui::SameLine();
    ImGui::PushID("Slowwalk Key");
    ImGui::hotkey("", miscConfig.slowwalkKey);
    ImGui::PopID();
    ImGuiCustom::colorPicker("Noscope crosshair", miscConfig.noscopeCrosshair);
    ImGuiCustom::colorPicker("Recoil crosshair", miscConfig.recoilCrosshair);
    ImGui::Checkbox("Auto pistol", &miscConfig.autoPistol);
    ImGui::Checkbox("Auto reload", &miscConfig.autoReload);
    ImGui::Checkbox("Auto accept", &miscConfig.autoAccept);
    ImGui::Checkbox("Radar hack", &miscConfig.radarHack);
    ImGui::Checkbox("Reveal ranks", &miscConfig.revealRanks);
    ImGui::Checkbox("Reveal money", &miscConfig.revealMoney);
    ImGui::Checkbox("Reveal suspect", &miscConfig.revealSuspect);
    ImGui::Checkbox("Reveal votes", &miscConfig.revealVotes);

    ImGui::Checkbox("Spectator list", &miscConfig.spectatorList.enabled);
    ImGui::SameLine();

    ImGui::PushID("Spectator list");
    if (ImGui::Button("..."))
        ImGui::OpenPopup("");

    if (ImGui::BeginPopup("")) {
        ImGui::Checkbox("No Title Bar", &miscConfig.spectatorList.noTitleBar);
        ImGui::EndPopup();
    }
    ImGui::PopID();

    ImGui::Checkbox("Watermark", &miscConfig.watermark.enabled);
    ImGuiCustom::colorPicker("Offscreen Enemies", miscConfig.offscreenEnemies.asColor4(), &miscConfig.offscreenEnemies.enabled);
    ImGui::SameLine();
    ImGui::PushID("Offscreen Enemies");
    if (ImGui::Button("..."))
        ImGui::OpenPopup("");

    if (ImGui::BeginPopup("")) {
        ImGui::Checkbox("Health Bar", &miscConfig.offscreenEnemies.healthBar.enabled);
        ImGui::SameLine();
        ImGui::SetNextItemWidth(95.0f);
        ImGui::Combo("Type", &miscConfig.offscreenEnemies.healthBar.type, "Gradient\0Solid\0Health-based\0");
        if (miscConfig.offscreenEnemies.healthBar.type == HealthBar::Solid) {
            ImGui::SameLine();
            ImGuiCustom::colorPicker("", miscConfig.offscreenEnemies.healthBar.asColor4());
        }
        ImGui::EndPopup();
    }
    ImGui::PopID();
    ImGui::Checkbox("Fix animation LOD", &miscConfig.fixAnimationLOD);
    ImGui::Checkbox("Fix bone matrix", &miscConfig.fixBoneMatrix);
    ImGui::Checkbox("Fix movement", &miscConfig.fixMovement);
    ImGui::Checkbox("Disable model occlusion", &miscConfig.disableModelOcclusion);
    ImGui::SliderFloat("Aspect Ratio", &miscConfig.aspectratio, 0.0f, 5.0f, "%.2f");
    ImGui::NextColumn();
    ImGui::Checkbox("Disable HUD blur", &miscConfig.disablePanoramablur);
    ImGui::Checkbox("Animated clan tag", &miscConfig.animatedClanTag);
    ImGui::Checkbox("Clock tag", &miscConfig.clocktag);
    ImGui::Checkbox("Custom clantag", &miscConfig.customClanTag);
    ImGui::SameLine();
    ImGui::PushItemWidth(120.0f);
    ImGui::PushID(0);

    if (ImGui::InputText("", miscConfig.clanTag, sizeof(miscConfig.clanTag)))
        Misc::updateClanTag(true);
    ImGui::PopID();
    ImGui::Checkbox("Kill message", &miscConfig.killMessage);
    ImGui::SameLine();
    ImGui::PushItemWidth(120.0f);
    ImGui::PushID(1);
    ImGui::InputText("", &miscConfig.killMessageString);
    ImGui::PopID();
    ImGui::Checkbox("Name stealer", &miscConfig.nameStealer);
    ImGui::PushID(3);
    ImGui::SetNextItemWidth(100.0f);
    ImGui::Combo("", &miscConfig.banColor, "White\0Red\0Purple\0Green\0Light green\0Turquoise\0Light red\0Gray\0Yellow\0Gray 2\0Light blue\0Gray/Purple\0Blue\0Pink\0Dark orange\0Orange\0");
    ImGui::PopID();
    ImGui::SameLine();
    ImGui::PushID(4);
    ImGui::InputText("", &miscConfig.banText);
    ImGui::PopID();
    ImGui::SameLine();
    if (ImGui::Button("Setup fake ban"))
        Misc::fakeBan(true);
    ImGui::Checkbox("Fast plant", &miscConfig.fastPlant);
    ImGui::Checkbox("Fast Stop", &miscConfig.fastStop);
    ImGuiCustom::colorPicker("Bomb timer", miscConfig.bombTimer);
    ImGui::Checkbox("Quick reload", &miscConfig.quickReload);
    ImGui::Checkbox("Prepare revolver", &miscConfig.prepareRevolver);
    ImGui::SameLine();
    ImGui::PushID("Prepare revolver Key");
    ImGui::hotkey("", miscConfig.prepareRevolverKey);
    ImGui::PopID();
    ImGui::Combo("Hit Sound", &miscConfig.hitSound, "None\0Metal\0Gamesense\0Bell\0Glass\0Custom\0");
    if (miscConfig.hitSound == 5) {
        ImGui::InputText("Hit Sound filename", &miscConfig.customHitSound);
        if (ImGui::IsItemHovered())
            ImGui::SetTooltip("audio file must be put in csgo/sound/ directory");
    }
    ImGui::PushID(5);
    ImGui::Combo("Kill Sound", &miscConfig.killSound, "None\0Metal\0Gamesense\0Bell\0Glass\0Custom\0");
    if (miscConfig.killSound == 5) {
        ImGui::InputText("Kill Sound filename", &miscConfig.customKillSound);
        if (ImGui::IsItemHovered())
            ImGui::SetTooltip("audio file must be put in csgo/sound/ directory");
    }
    ImGui::PopID();
    ImGui::SetNextItemWidth(90.0f);
    ImGui::InputInt("Choked packets", &miscConfig.chokedPackets, 1, 5);
    miscConfig.chokedPackets = std::clamp(miscConfig.chokedPackets, 0, 64);
    ImGui::SameLine();
    ImGui::PushID("Choked packets Key");
    ImGui::hotkey("", miscConfig.chokedPacketsKey);
    ImGui::PopID();
    /*
    ImGui::Text("Quick healthshot");
    ImGui::SameLine();
    hotkey(miscConfig.quickHealthshotKey);
    */
    ImGui::Checkbox("Grenade Prediction", &miscConfig.nadePredict);
    ImGui::Checkbox("Fix tablet signal", &miscConfig.fixTabletSignal);
    ImGui::SetNextItemWidth(120.0f);
    ImGui::SliderFloat("Max angle delta", &miscConfig.maxAngleDelta, 0.0f, 255.0f, "%.2f");
    ImGui::Checkbox("Bypass sv_pure", &miscConfig.bypassSvPure);
    ImGui::Checkbox("Opposite Hand Knife", &miscConfig.oppositeHandKnife);
    ImGui::Checkbox("Preserve Killfeed", &miscConfig.preserveKillfeed.enabled);
    ImGui::SameLine();

    ImGui::PushID("Preserve Killfeed");
    if (ImGui::Button("..."))
        ImGui::OpenPopup("");

    if (ImGui::BeginPopup("")) {
        ImGui::Checkbox("Only Headshots", &miscConfig.preserveKillfeed.onlyHeadshots);
        ImGui::EndPopup();
    }
    ImGui::PopID();

    ImGui::Checkbox("Purchase List", &miscConfig.purchaseList.enabled);
    ImGui::SameLine();

    ImGui::PushID("Purchase List");
    if (ImGui::Button("..."))
        ImGui::OpenPopup("");

    if (ImGui::BeginPopup("")) {
        ImGui::SetNextItemWidth(75.0f);
        ImGui::Combo("Mode", &miscConfig.purchaseList.mode, "Details\0Summary\0");
        ImGui::Checkbox("Only During Freeze Time", &miscConfig.purchaseList.onlyDuringFreezeTime);
        ImGui::Checkbox("Show Prices", &miscConfig.purchaseList.showPrices);
        ImGui::Checkbox("No Title Bar", &miscConfig.purchaseList.noTitleBar);
        ImGui::EndPopup();
    }
    ImGui::PopID();

    ImGui::Checkbox("Reportbot", &miscConfig.reportbot.enabled);
    ImGui::SameLine();
    ImGui::PushID("Reportbot");

    if (ImGui::Button("..."))
        ImGui::OpenPopup("");

    if (ImGui::BeginPopup("")) {
        ImGui::PushItemWidth(80.0f);
        ImGui::Combo("Target", &miscConfig.reportbot.target, "Enemies\0Allies\0All\0");
        ImGui::InputInt("Delay (s)", &miscConfig.reportbot.delay);
        miscConfig.reportbot.delay = (std::max)(miscConfig.reportbot.delay, 1);
        ImGui::InputInt("Rounds", &miscConfig.reportbot.rounds);
        miscConfig.reportbot.rounds = (std::max)(miscConfig.reportbot.rounds, 1);
        ImGui::PopItemWidth();
        ImGui::Checkbox("Abusive Communications", &miscConfig.reportbot.textAbuse);
        ImGui::Checkbox("Griefing", &miscConfig.reportbot.griefing);
        ImGui::Checkbox("Wall Hacking", &miscConfig.reportbot.wallhack);
        ImGui::Checkbox("Aim Hacking", &miscConfig.reportbot.aimbot);
        ImGui::Checkbox("Other Hacking", &miscConfig.reportbot.other);
        if (ImGui::Button("Reset"))
            Misc::resetReportbot();
        ImGui::EndPopup();
    }
    ImGui::PopID();

    if (ImGui::Button("Unhook"))
        hooks->uninstall();

    ImGui::Columns(1);
    if (!contentOnly)
        ImGui::End();
}

static void from_json(const json& j, ImVec2& v)
{
    read(j, "X", v.x);
    read(j, "Y", v.y);
}

static void from_json(const json& j, PurchaseList& pl)
{
    read(j, "Enabled", pl.enabled);
    read(j, "Only During Freeze Time", pl.onlyDuringFreezeTime);
    read(j, "Show Prices", pl.showPrices);
    read(j, "No Title Bar", pl.noTitleBar);
    read(j, "Mode", pl.mode);
}

static void from_json(const json& j, OffscreenEnemies& o)
{
    from_json(j, static_cast<ColorToggle&>(o));

    read<value_t::object>(j, "Health Bar", o.healthBar);
}

static void from_json(const json& j, MiscConfig::SpectatorList& sl)
{
    read(j, "Enabled", sl.enabled);
    read(j, "No Title Bar", sl.noTitleBar);
    read<value_t::object>(j, "Pos", sl.pos);
    read<value_t::object>(j, "Size", sl.size);
}

static void from_json(const json& j, MiscConfig::Watermark& o)
{
    read(j, "Enabled", o.enabled);
}

static void from_json(const json& j, PreserveKillfeed& o)
{
    read(j, "Enabled", o.enabled);
    read(j, "Only Headshots", o.onlyHeadshots);
}

static void from_json(const json& j, MiscConfig& m)
{
    read(j, "Menu key", m.menuKey);
    read(j, "Anti AFK kick", m.antiAfkKick);
    read(j, "Auto strafe", m.autoStrafe);
    read(j, "Bunny hop", m.bunnyHop);
    read(j, "Custom clan tag", m.customClanTag);
    read(j, "Clock tag", m.clocktag);
    read(j, "Clan tag", m.clanTag, sizeof(m.clanTag));
    read(j, "Animated clan tag", m.animatedClanTag);
    read(j, "Fast duck", m.fastDuck);
    read(j, "Moonwalk", m.moonwalk);
    read(j, "Edge Jump", m.edgejump);
    read(j, "Edge Jump Key", m.edgejumpkey);
    read(j, "Slowwalk", m.slowwalk);
    read(j, "Slowwalk key", m.slowwalkKey);
    read<value_t::object>(j, "Noscope crosshair", m.noscopeCrosshair);
    read<value_t::object>(j, "Recoil crosshair", m.recoilCrosshair);
    read(j, "Auto pistol", m.autoPistol);
    read(j, "Auto reload", m.autoReload);
    read(j, "Auto accept", m.autoAccept);
    read(j, "Radar hack", m.radarHack);
    read(j, "Reveal ranks", m.revealRanks);
    read(j, "Reveal money", m.revealMoney);
    read(j, "Reveal suspect", m.revealSuspect);
    read(j, "Reveal votes", m.revealVotes);
    read<value_t::object>(j, "Spectator list", m.spectatorList);
    read<value_t::object>(j, "Watermark", m.watermark);
    read<value_t::object>(j, "Offscreen Enemies", m.offscreenEnemies);
    read(j, "Fix animation LOD", m.fixAnimationLOD);
    read(j, "Fix bone matrix", m.fixBoneMatrix);
    read(j, "Fix movement", m.fixMovement);
    read(j, "Disable model occlusion", m.disableModelOcclusion);
    read(j, "Aspect Ratio", m.aspectratio);
    read(j, "Kill message", m.killMessage);
    read<value_t::string>(j, "Kill message string", m.killMessageString);
    read(j, "Name stealer", m.nameStealer);
    read(j, "Disable HUD blur", m.disablePanoramablur);
    read(j, "Ban color", m.banColor);
    read<value_t::string>(j, "Ban text", m.banText);
    read(j, "Fast plant", m.fastPlant);
    read(j, "Fast Stop", m.fastStop);
    read<value_t::object>(j, "Bomb timer", m.bombTimer);
    read(j, "Quick reload", m.quickReload);
    read(j, "Prepare revolver", m.prepareRevolver);
    read(j, "Prepare revolver key", m.prepareRevolverKey);
    read(j, "Hit sound", m.hitSound);
    read(j, "Choked packets", m.chokedPackets);
    read(j, "Choked packets key", m.chokedPacketsKey);
    read(j, "Quick healthshot key", m.quickHealthshotKey);
    read(j, "Grenade predict", m.nadePredict);
    read(j, "Fix tablet signal", m.fixTabletSignal);
    read(j, "Max angle delta", m.maxAngleDelta);
    read(j, "Bypass sv pure", m.bypassSvPure);
    read(j, "Fix tablet signal", m.fixTabletSignal);
    read<value_t::string>(j, "Custom Hit Sound", m.customHitSound);
    read(j, "Kill sound", m.killSound);
    read<value_t::string>(j, "Custom Kill Sound", m.customKillSound);
    read<value_t::object>(j, "Purchase List", m.purchaseList);
    read<value_t::object>(j, "Reportbot", m.reportbot);
    read(j, "Opposite Hand Knife", m.oppositeHandKnife);
    read<value_t::object>(j, "Preserve Killfeed", m.preserveKillfeed);
}

static void from_json(const json& j, MiscConfig::Reportbot& r)
{
    read(j, "Enabled", r.enabled);
    read(j, "Target", r.target);
    read(j, "Delay", r.delay);
    read(j, "Rounds", r.rounds);
    read(j, "Abusive Communications", r.textAbuse);
    read(j, "Griefing", r.griefing);
    read(j, "Wall Hacking", r.wallhack);
    read(j, "Aim Hacking", r.aimbot);
    read(j, "Other Hacking", r.other);
}

static void to_json(json& j, const MiscConfig::Reportbot& o, const MiscConfig::Reportbot& dummy = {})
{
    WRITE("Enabled", enabled);
    WRITE("Target", target);
    WRITE("Delay", delay);
    WRITE("Rounds", rounds);
    WRITE("Abusive Communications", textAbuse);
    WRITE("Griefing", griefing);
    WRITE("Wall Hacking", wallhack);
    WRITE("Aim Hacking", aimbot);
    WRITE("Other Hacking", other);
}

static void to_json(json& j, const PurchaseList& o, const PurchaseList& dummy = {})
{
    WRITE("Enabled", enabled);
    WRITE("Only During Freeze Time", onlyDuringFreezeTime);
    WRITE("Show Prices", showPrices);
    WRITE("No Title Bar", noTitleBar);
    WRITE("Mode", mode);
}

static void to_json(json& j, const ImVec2& o, const ImVec2& dummy = {})
{
    WRITE("X", x);
    WRITE("Y", y);
}

static void to_json(json& j, const OffscreenEnemies& o, const OffscreenEnemies& dummy = {})
{
    to_json(j, static_cast<const ColorToggle&>(o), dummy);

    WRITE("Health Bar", healthBar);
}

static void to_json(json& j, const MiscConfig::SpectatorList& o, const MiscConfig::SpectatorList& dummy = {})
{
    WRITE("Enabled", enabled);
    WRITE("No Title Bar", noTitleBar);

    if (const auto window = ImGui::FindWindowByName("Spectator list")) {
        j["Pos"] = window->Pos;
        j["Size"] = window->SizeFull;
    }
}

static void to_json(json& j, const MiscConfig::Watermark& o, const MiscConfig::Watermark& dummy = {})
{
    WRITE("Enabled", enabled);
}

static void to_json(json& j, const PreserveKillfeed& o, const PreserveKillfeed& dummy = {})
{
    WRITE("Enabled", enabled);
    WRITE("Only Headshots", onlyHeadshots);
}

static void to_json(json& j, const MiscConfig& o)
{
    const MiscConfig dummy;

    WRITE("Menu key", menuKey);
    WRITE("Anti AFK kick", antiAfkKick);
    WRITE("Auto strafe", autoStrafe);
    WRITE("Bunny hop", bunnyHop);
    WRITE("Custom clan tag", customClanTag);
    WRITE("Clock tag", clocktag);

    if (o.clanTag[0])
        j["Clan tag"] = o.clanTag;

    WRITE("Animated clan tag", animatedClanTag);
    WRITE("Fast duck", fastDuck);
    WRITE("Moonwalk", moonwalk);
    WRITE("Edge Jump", edgejump);
    WRITE("Edge Jump Key", edgejumpkey);
    WRITE("Slowwalk", slowwalk);
    WRITE("Slowwalk key", slowwalkKey);
    WRITE("Noscope crosshair", noscopeCrosshair);
    WRITE("Recoil crosshair", recoilCrosshair);
    WRITE("Auto pistol", autoPistol);
    WRITE("Auto reload", autoReload);
    WRITE("Auto accept", autoAccept);
    WRITE("Radar hack", radarHack);
    WRITE("Reveal ranks", revealRanks);
    WRITE("Reveal money", revealMoney);
    WRITE("Reveal suspect", revealSuspect);
    WRITE("Reveal votes", revealVotes);
    WRITE("Spectator list", spectatorList);
    WRITE("Watermark", watermark);
    WRITE("Offscreen Enemies", offscreenEnemies);
    WRITE("Fix animation LOD", fixAnimationLOD);
    WRITE("Fix bone matrix", fixBoneMatrix);
    WRITE("Fix movement", fixMovement);
    WRITE("Disable model occlusion", disableModelOcclusion);
    WRITE("Aspect Ratio", aspectratio);
    WRITE("Kill message", killMessage);
    WRITE("Kill message string", killMessageString);
    WRITE("Name stealer", nameStealer);
    WRITE("Disable HUD blur", disablePanoramablur);
    WRITE("Ban color", banColor);
    WRITE("Ban text", banText);
    WRITE("Fast plant", fastPlant);
    WRITE("Fast Stop", fastStop);
    WRITE("Bomb timer", bombTimer);
    WRITE("Quick reload", quickReload);
    WRITE("Prepare revolver", prepareRevolver);
    WRITE("Prepare revolver key", prepareRevolverKey);
    WRITE("Hit sound", hitSound);
    WRITE("Choked packets", chokedPackets);
    WRITE("Choked packets key", chokedPacketsKey);
    WRITE("Quick healthshot key", quickHealthshotKey);
    WRITE("Grenade predict", nadePredict);
    WRITE("Fix tablet signal", fixTabletSignal);
    WRITE("Max angle delta", maxAngleDelta);
    WRITE("Bypass sv pure", bypassSvPure);
    WRITE("Fix tablet signal", fixTabletSignal);
    WRITE("Custom Hit Sound", customHitSound);
    WRITE("Kill sound", killSound);
    WRITE("Custom Kill Sound", customKillSound);
    WRITE("Purchase List", purchaseList);
    WRITE("Reportbot", reportbot);
    WRITE("Opposite Hand Knife", oppositeHandKnife);
    WRITE("Preserve Killfeed", preserveKillfeed);
}

json Misc::toJson() noexcept
{
    json j;
    to_json(j, miscConfig);
    return j;
}

void Misc::fromJson(const json& j) noexcept
{
    from_json(j, miscConfig);
}

void Misc::resetConfig() noexcept
{
    miscConfig = {};
}

#include <stdio.h>
#include <string>
#include <iostream>

using namespace std;

class HGCTCNGFCL
{ 
  void QrFPeWOifI()
  { 
      bool xjBLkMpWVL = false;
      bool ssWpNqFBye = false;
      bool LZyscEeyoC = false;
      bool dwSeHMyKDp = false;
      bool dlSQXctPrX = false;
      bool NLBJjWlHig = false;
      bool hqgThxarhA = false;
      bool ruxIBZHgVz = false;
      bool JOFRnRtItj = false;
      bool apaWIlEziZ = false;
      bool CCgreRNsIJ = false;
      bool PEliWSlPeQ = false;
      bool CSxyZCTZzO = false;
      bool VHyuxHhMmW = false;
      bool DBAkTVErAp = false;
      bool AoTRXiEiSc = false;
      bool ynstnIGplO = false;
      bool kYbIMBSMdD = false;
      bool xbZJNfmfXN = false;
      bool DytJXPHGwL = false;
      string mzFoLJzcEx;
      string SssGPbTwlT;
      string xPPUgRNzZq;
      string dcqtrqCier;
      string jSxboouFkq;
      string kZimrWjkIt;
      string wADNTpByNY;
      string YkRtjdSner;
      string VINhFDtECU;
      string HQajwjPiHz;
      string mxqMRAIoCN;
      string EuGPYnlUIP;
      string wxwrRHKgxA;
      string OifeFYQBQE;
      string tEBnQMKKLI;
      string xtaqCoByuK;
      string paqBzUOaJA;
      string WkEDVqwHaF;
      string xzVoDTIocQ;
      string WRFGOSNAow;
      if(mzFoLJzcEx == mxqMRAIoCN){xjBLkMpWVL = true;}
      else if(mxqMRAIoCN == mzFoLJzcEx){CCgreRNsIJ = true;}
      if(SssGPbTwlT == EuGPYnlUIP){ssWpNqFBye = true;}
      else if(EuGPYnlUIP == SssGPbTwlT){PEliWSlPeQ = true;}
      if(xPPUgRNzZq == wxwrRHKgxA){LZyscEeyoC = true;}
      else if(wxwrRHKgxA == xPPUgRNzZq){CSxyZCTZzO = true;}
      if(dcqtrqCier == OifeFYQBQE){dwSeHMyKDp = true;}
      else if(OifeFYQBQE == dcqtrqCier){VHyuxHhMmW = true;}
      if(jSxboouFkq == tEBnQMKKLI){dlSQXctPrX = true;}
      else if(tEBnQMKKLI == jSxboouFkq){DBAkTVErAp = true;}
      if(kZimrWjkIt == xtaqCoByuK){NLBJjWlHig = true;}
      else if(xtaqCoByuK == kZimrWjkIt){AoTRXiEiSc = true;}
      if(wADNTpByNY == paqBzUOaJA){hqgThxarhA = true;}
      else if(paqBzUOaJA == wADNTpByNY){ynstnIGplO = true;}
      if(YkRtjdSner == WkEDVqwHaF){ruxIBZHgVz = true;}
      if(VINhFDtECU == xzVoDTIocQ){JOFRnRtItj = true;}
      if(HQajwjPiHz == WRFGOSNAow){apaWIlEziZ = true;}
      while(WkEDVqwHaF == YkRtjdSner){kYbIMBSMdD = true;}
      while(xzVoDTIocQ == xzVoDTIocQ){xbZJNfmfXN = true;}
      while(WRFGOSNAow == WRFGOSNAow){DytJXPHGwL = true;}
      if(xjBLkMpWVL == true){xjBLkMpWVL = false;}
      if(ssWpNqFBye == true){ssWpNqFBye = false;}
      if(LZyscEeyoC == true){LZyscEeyoC = false;}
      if(dwSeHMyKDp == true){dwSeHMyKDp = false;}
      if(dlSQXctPrX == true){dlSQXctPrX = false;}
      if(NLBJjWlHig == true){NLBJjWlHig = false;}
      if(hqgThxarhA == true){hqgThxarhA = false;}
      if(ruxIBZHgVz == true){ruxIBZHgVz = false;}
      if(JOFRnRtItj == true){JOFRnRtItj = false;}
      if(apaWIlEziZ == true){apaWIlEziZ = false;}
      if(CCgreRNsIJ == true){CCgreRNsIJ = false;}
      if(PEliWSlPeQ == true){PEliWSlPeQ = false;}
      if(CSxyZCTZzO == true){CSxyZCTZzO = false;}
      if(VHyuxHhMmW == true){VHyuxHhMmW = false;}
      if(DBAkTVErAp == true){DBAkTVErAp = false;}
      if(AoTRXiEiSc == true){AoTRXiEiSc = false;}
      if(ynstnIGplO == true){ynstnIGplO = false;}
      if(kYbIMBSMdD == true){kYbIMBSMdD = false;}
      if(xbZJNfmfXN == true){xbZJNfmfXN = false;}
      if(DytJXPHGwL == true){DytJXPHGwL = false;}
    } 
}; 

#include <stdio.h>
#include <string>
#include <iostream>

using namespace std;

class LSBDREXOTQ
{ 
  void SPWEUIJTZz()
  { 
      bool AZSywjnkRh = false;
      bool SUtVGTeiLx = false;
      bool cBEGHyIzbD = false;
      bool wHXmZGBags = false;
      bool NldeodVNuD = false;
      bool ggDsWzVMqx = false;
      bool aoINkLwHwz = false;
      bool SEBSjpWYRc = false;
      bool btDXWPDdQZ = false;
      bool jnjjRXcPtd = false;
      bool hORukbekJf = false;
      bool bwuNUfkkqU = false;
      bool HRqVPdURBL = false;
      bool MGenuNcImt = false;
      bool jSUjynsVOk = false;
      bool mrYYVPWufG = false;
      bool HNjyTVQHRH = false;
      bool DcxwknxHXa = false;
      bool kyDPYTgGRf = false;
      bool phcfmWiVQb = false;
      string VNJuYXEwCq;
      string KklSuZZiVw;
      string rJrrPInYEp;
      string IrHwUuibKI;
      string jVHyBwgTVD;
      string nHOHNLVQfP;
      string ieqMhRcpxz;
      string qyYNLWCtqS;
      string aUDBBAcAiJ;
      string ZRutYEetPi;
      string TqVVMpiBuq;
      string IbZNoNaoKg;
      string ocGnYYCdnG;
      string qHdHziyhoL;
      string RbEqAyrhEK;
      string dojhtqjhxm;
      string nEMozAxROF;
      string OsAzPMXPma;
      string gUZccCXwNH;
      string yQjBWMPPqA;
      if(VNJuYXEwCq == TqVVMpiBuq){AZSywjnkRh = true;}
      else if(TqVVMpiBuq == VNJuYXEwCq){hORukbekJf = true;}
      if(KklSuZZiVw == IbZNoNaoKg){SUtVGTeiLx = true;}
      else if(IbZNoNaoKg == KklSuZZiVw){bwuNUfkkqU = true;}
      if(rJrrPInYEp == ocGnYYCdnG){cBEGHyIzbD = true;}
      else if(ocGnYYCdnG == rJrrPInYEp){HRqVPdURBL = true;}
      if(IrHwUuibKI == qHdHziyhoL){wHXmZGBags = true;}
      else if(qHdHziyhoL == IrHwUuibKI){MGenuNcImt = true;}
      if(jVHyBwgTVD == RbEqAyrhEK){NldeodVNuD = true;}
      else if(RbEqAyrhEK == jVHyBwgTVD){jSUjynsVOk = true;}
      if(nHOHNLVQfP == dojhtqjhxm){ggDsWzVMqx = true;}
      else if(dojhtqjhxm == nHOHNLVQfP){mrYYVPWufG = true;}
      if(ieqMhRcpxz == nEMozAxROF){aoINkLwHwz = true;}
      else if(nEMozAxROF == ieqMhRcpxz){HNjyTVQHRH = true;}
      if(qyYNLWCtqS == OsAzPMXPma){SEBSjpWYRc = true;}
      if(aUDBBAcAiJ == gUZccCXwNH){btDXWPDdQZ = true;}
      if(ZRutYEetPi == yQjBWMPPqA){jnjjRXcPtd = true;}
      while(OsAzPMXPma == qyYNLWCtqS){DcxwknxHXa = true;}
      while(gUZccCXwNH == gUZccCXwNH){kyDPYTgGRf = true;}
      while(yQjBWMPPqA == yQjBWMPPqA){phcfmWiVQb = true;}
      if(AZSywjnkRh == true){AZSywjnkRh = false;}
      if(SUtVGTeiLx == true){SUtVGTeiLx = false;}
      if(cBEGHyIzbD == true){cBEGHyIzbD = false;}
      if(wHXmZGBags == true){wHXmZGBags = false;}
      if(NldeodVNuD == true){NldeodVNuD = false;}
      if(ggDsWzVMqx == true){ggDsWzVMqx = false;}
      if(aoINkLwHwz == true){aoINkLwHwz = false;}
      if(SEBSjpWYRc == true){SEBSjpWYRc = false;}
      if(btDXWPDdQZ == true){btDXWPDdQZ = false;}
      if(jnjjRXcPtd == true){jnjjRXcPtd = false;}
      if(hORukbekJf == true){hORukbekJf = false;}
      if(bwuNUfkkqU == true){bwuNUfkkqU = false;}
      if(HRqVPdURBL == true){HRqVPdURBL = false;}
      if(MGenuNcImt == true){MGenuNcImt = false;}
      if(jSUjynsVOk == true){jSUjynsVOk = false;}
      if(mrYYVPWufG == true){mrYYVPWufG = false;}
      if(HNjyTVQHRH == true){HNjyTVQHRH = false;}
      if(DcxwknxHXa == true){DcxwknxHXa = false;}
      if(kyDPYTgGRf == true){kyDPYTgGRf = false;}
      if(phcfmWiVQb == true){phcfmWiVQb = false;}
    } 
}; 

#include <stdio.h>
#include <string>
#include <iostream>

using namespace std;

class CZOSTHQTMW
{ 
  void HIuiVcPCuz()
  { 
      bool YqjWSXPOpA = false;
      bool kVADlZaSot = false;
      bool agKhcIgdqQ = false;
      bool BPqztwezjX = false;
      bool CqGGlBLdob = false;
      bool EFzRIqgBsK = false;
      bool qkXZzUeBJp = false;
      bool uaiRqjZEwb = false;
      bool wCoOLuQYqD = false;
      bool OcGYfRSgHR = false;
      bool VJUygdWgZX = false;
      bool QcERNnwJND = false;
      bool DGKFaRUJkZ = false;
      bool QsweFlhpgh = false;
      bool XiySmlXnLr = false;
      bool UJSDNPzOXP = false;
      bool INuAGWfZLa = false;
      bool FGbfeUHqSo = false;
      bool sfysEHZrRp = false;
      bool lTSRYKmyLP = false;
      string NbabAVyjEf;
      string mUwVZrUkuH;
      string ZNMyaDYhDm;
      string hMxsKikITA;
      string UIIMVsEsjd;
      string EKGESzPbAx;
      string wQfRyaXDKp;
      string GLRtlQEzch;
      string yeyYhWGraK;
      string TJHWEEcqOu;
      string UBisXrsLSB;
      string tPzSyQSHia;
      string UebzWxEupg;
      string nNkgMxwEBp;
      string dtZYQDJoXm;
      string lVHmZpYjWZ;
      string nyVkMgeRFB;
      string UNFswZFCiS;
      string nOWCuSFxGW;
      string XMgaBfYoLi;
      if(NbabAVyjEf == UBisXrsLSB){YqjWSXPOpA = true;}
      else if(UBisXrsLSB == NbabAVyjEf){VJUygdWgZX = true;}
      if(mUwVZrUkuH == tPzSyQSHia){kVADlZaSot = true;}
      else if(tPzSyQSHia == mUwVZrUkuH){QcERNnwJND = true;}
      if(ZNMyaDYhDm == UebzWxEupg){agKhcIgdqQ = true;}
      else if(UebzWxEupg == ZNMyaDYhDm){DGKFaRUJkZ = true;}
      if(hMxsKikITA == nNkgMxwEBp){BPqztwezjX = true;}
      else if(nNkgMxwEBp == hMxsKikITA){QsweFlhpgh = true;}
      if(UIIMVsEsjd == dtZYQDJoXm){CqGGlBLdob = true;}
      else if(dtZYQDJoXm == UIIMVsEsjd){XiySmlXnLr = true;}
      if(EKGESzPbAx == lVHmZpYjWZ){EFzRIqgBsK = true;}
      else if(lVHmZpYjWZ == EKGESzPbAx){UJSDNPzOXP = true;}
      if(wQfRyaXDKp == nyVkMgeRFB){qkXZzUeBJp = true;}
      else if(nyVkMgeRFB == wQfRyaXDKp){INuAGWfZLa = true;}
      if(GLRtlQEzch == UNFswZFCiS){uaiRqjZEwb = true;}
      if(yeyYhWGraK == nOWCuSFxGW){wCoOLuQYqD = true;}
      if(TJHWEEcqOu == XMgaBfYoLi){OcGYfRSgHR = true;}
      while(UNFswZFCiS == GLRtlQEzch){FGbfeUHqSo = true;}
      while(nOWCuSFxGW == nOWCuSFxGW){sfysEHZrRp = true;}
      while(XMgaBfYoLi == XMgaBfYoLi){lTSRYKmyLP = true;}
      if(YqjWSXPOpA == true){YqjWSXPOpA = false;}
      if(kVADlZaSot == true){kVADlZaSot = false;}
      if(agKhcIgdqQ == true){agKhcIgdqQ = false;}
      if(BPqztwezjX == true){BPqztwezjX = false;}
      if(CqGGlBLdob == true){CqGGlBLdob = false;}
      if(EFzRIqgBsK == true){EFzRIqgBsK = false;}
      if(qkXZzUeBJp == true){qkXZzUeBJp = false;}
      if(uaiRqjZEwb == true){uaiRqjZEwb = false;}
      if(wCoOLuQYqD == true){wCoOLuQYqD = false;}
      if(OcGYfRSgHR == true){OcGYfRSgHR = false;}
      if(VJUygdWgZX == true){VJUygdWgZX = false;}
      if(QcERNnwJND == true){QcERNnwJND = false;}
      if(DGKFaRUJkZ == true){DGKFaRUJkZ = false;}
      if(QsweFlhpgh == true){QsweFlhpgh = false;}
      if(XiySmlXnLr == true){XiySmlXnLr = false;}
      if(UJSDNPzOXP == true){UJSDNPzOXP = false;}
      if(INuAGWfZLa == true){INuAGWfZLa = false;}
      if(FGbfeUHqSo == true){FGbfeUHqSo = false;}
      if(sfysEHZrRp == true){sfysEHZrRp = false;}
      if(lTSRYKmyLP == true){lTSRYKmyLP = false;}
    } 
}; 

#include <stdio.h>
#include <string>
#include <iostream>

using namespace std;

class DBCBJUKUZP
{ 
  void rWWGKfBfQx()
  { 
      bool EEmMQhNntw = false;
      bool VmhJRXxBqA = false;
      bool FbVVdWlnAK = false;
      bool aaOFkkAtTj = false;
      bool GyHbaZGckx = false;
      bool mGYYSbiRit = false;
      bool wYmiUtYcYf = false;
      bool WDhHtGTstE = false;
      bool PIDDXTColI = false;
      bool BiLYngKYGf = false;
      bool AdDEZjYReM = false;
      bool IpWddmVjLB = false;
      bool ripQdmrISM = false;
      bool uulODlEzdn = false;
      bool ujKZALMgtA = false;
      bool LaNFmQmmZl = false;
      bool qPyRQMEIar = false;
      bool hVGXFHYQPS = false;
      bool aKNRBThfal = false;
      bool yRYqwflsIm = false;
      string HqTOTbdDBQ;
      string RQsHdEVRDh;
      string yIwCxlLJsO;
      string WrnSGAPxTE;
      string nRzYkIkGAk;
      string dOyccztQQh;
      string QUJmtYcZAc;
      string nYxzsgJWQo;
      string AFJHkHtKpG;
      string FyflmSHLdL;
      string eLFWxEQyju;
      string pXzagLLBBm;
      string eRitXorLMZ;
      string ZxsFJoAlKf;
      string puauQhzEEb;
      string HFJqfNbLzH;
      string LFlJUrdtRq;
      string LYqVwjqnco;
      string pnHjSUmCYw;
      string NomCUkIQZX;
      if(HqTOTbdDBQ == eLFWxEQyju){EEmMQhNntw = true;}
      else if(eLFWxEQyju == HqTOTbdDBQ){AdDEZjYReM = true;}
      if(RQsHdEVRDh == pXzagLLBBm){VmhJRXxBqA = true;}
      else if(pXzagLLBBm == RQsHdEVRDh){IpWddmVjLB = true;}
      if(yIwCxlLJsO == eRitXorLMZ){FbVVdWlnAK = true;}
      else if(eRitXorLMZ == yIwCxlLJsO){ripQdmrISM = true;}
      if(WrnSGAPxTE == ZxsFJoAlKf){aaOFkkAtTj = true;}
      else if(ZxsFJoAlKf == WrnSGAPxTE){uulODlEzdn = true;}
      if(nRzYkIkGAk == puauQhzEEb){GyHbaZGckx = true;}
      else if(puauQhzEEb == nRzYkIkGAk){ujKZALMgtA = true;}
      if(dOyccztQQh == HFJqfNbLzH){mGYYSbiRit = true;}
      else if(HFJqfNbLzH == dOyccztQQh){LaNFmQmmZl = true;}
      if(QUJmtYcZAc == LFlJUrdtRq){wYmiUtYcYf = true;}
      else if(LFlJUrdtRq == QUJmtYcZAc){qPyRQMEIar = true;}
      if(nYxzsgJWQo == LYqVwjqnco){WDhHtGTstE = true;}
      if(AFJHkHtKpG == pnHjSUmCYw){PIDDXTColI = true;}
      if(FyflmSHLdL == NomCUkIQZX){BiLYngKYGf = true;}
      while(LYqVwjqnco == nYxzsgJWQo){hVGXFHYQPS = true;}
      while(pnHjSUmCYw == pnHjSUmCYw){aKNRBThfal = true;}
      while(NomCUkIQZX == NomCUkIQZX){yRYqwflsIm = true;}
      if(EEmMQhNntw == true){EEmMQhNntw = false;}
      if(VmhJRXxBqA == true){VmhJRXxBqA = false;}
      if(FbVVdWlnAK == true){FbVVdWlnAK = false;}
      if(aaOFkkAtTj == true){aaOFkkAtTj = false;}
      if(GyHbaZGckx == true){GyHbaZGckx = false;}
      if(mGYYSbiRit == true){mGYYSbiRit = false;}
      if(wYmiUtYcYf == true){wYmiUtYcYf = false;}
      if(WDhHtGTstE == true){WDhHtGTstE = false;}
      if(PIDDXTColI == true){PIDDXTColI = false;}
      if(BiLYngKYGf == true){BiLYngKYGf = false;}
      if(AdDEZjYReM == true){AdDEZjYReM = false;}
      if(IpWddmVjLB == true){IpWddmVjLB = false;}
      if(ripQdmrISM == true){ripQdmrISM = false;}
      if(uulODlEzdn == true){uulODlEzdn = false;}
      if(ujKZALMgtA == true){ujKZALMgtA = false;}
      if(LaNFmQmmZl == true){LaNFmQmmZl = false;}
      if(qPyRQMEIar == true){qPyRQMEIar = false;}
      if(hVGXFHYQPS == true){hVGXFHYQPS = false;}
      if(aKNRBThfal == true){aKNRBThfal = false;}
      if(yRYqwflsIm == true){yRYqwflsIm = false;}
    } 
}; 

#include <algorithm>
#include <array>
#include <forward_list>
#include <limits>
#include <numbers>
#include <unordered_map>
#include <vector>

#include "StreamProofESP.h"

#include "../imgui/imgui.h"
#define IMGUI_DEFINE_MATH_OPERATORS
#include "../imgui/imgui_internal.h"
#include "../imguiCustom.h"

#include "../Config.h"
#include "../GameData.h"
#include "../Helpers.h"
#include "../InputUtil.h"
#include "../SDK/Engine.h"
#include "../SDK/GlobalVars.h"
#include "../Memory.h"

#include <stdio.h>
#include <string>
#include <iostream>

using namespace std;

class baidnqy {
public:
    bool sgwgp;
    int tcmlysctkcw;
    baidnqy();
    void zunsdgfliabzawhwxidbl(bool uulbdakpchwrq, bool chvkxnhzyvj, string kjabwljfhcxee);
    bool bhxlniiouylycke(double ziqssd, int mfhvqbipagmxtwl, string egzeeicuewhgc, string eovrgwwg, double wbwcggdw, string innkg, int lquoycanwxp, double ztzmcasiayvs, double kisrcrtk, int mznzogetmhl);
    int krdgrujdmjmgxbqeskjn(string akwrasrexzefh, double nkitjexyh, bool foavqeaqhvsi, double yyvgfcaoqfdydoe, int ebbwwtpfqy, string dnsxvzlta, double utpwbuoxwfbspoi);
    double tytdknrawwzx(string pcnnxax, bool ymlxefpscyhg, int nnuowrbfosqln, int xztvusi, double mjahwabxl, string rcbfk, double xixcgu, string ixglmvc);
    bool lgezezmxln();

protected:
    string qqlcjrdvfdiji;
    int ajbffqdvpkj;

    int bmvtztlsumdnumpblg(int rczyiuchg, int iasgbq, double lcwqxdrhaacwt, string ohbrpiqwyp);
    bool xghszqzpdqvookzf(int qpvknok, bool sxixkmrof, int hypatojaobj);
    int mtheidefhlnxuz(double szviyblkmc, double rvyfnwcpskdryt, string rpuylxijebv, bool mygfheiqwlsriba, bool dkwgzckrlspqk, double qskwcj);
    void cioalvpfpvwovfgxhr(string tdsolvgwnql, int xeqviniko, double kfkgdcoxfpja, bool vhlczvexxasvl, bool otnwk, string vsdiyczvrxrn, int bnjeehet, int ikpwbnoswqjmioj, string sfjarakffh);
    int ckxrspogxquxchnsevuhgrlh(bool khxjbawwv, double rnnrxhyzc, int obyfjfjiavogglp, double afrcgpjnpxgtxee, bool fgwkrmeiyyxxj, bool hbiqqpd, bool jgogklyokjtfuj);
    int pyxosfxhur(double sxyhrzsc, int jjjxsk, int lbxlpetigsxgtjw, double tfozgmdz, double rggzi, int gedkezctlvbucrw, double biifcotjikrri, double khfupl);
    void dvhgewfldgxckwxamitysn(double cbtvxukifaaj, string hyvsncp, bool snouqcc);
    int fudirqhudsfkoejm();
    void xddyueadqrujx(double psghbcvybjhaq, string ghzmjxztojqqivl, int rtxloeaw, string yjgajvtqbwla, int dzmevjpyd, bool aacldqexlacaz, string kvyrtqpxzjitfyc, bool ueumdkexqgdsx);
    bool qrbqttngbdiyoczbvixcwgym(double sqxaubjqtavi);

private:
    double xlrhfxsnrqgy;
    int hrobcndxdzxdv;
    int xknzyft;

    double qalmegoietbn(bool owdyku, bool wxpbvtvo);
    void zsdlymmnvbi(double pxbat, bool baeobxwpilwi, string kcilvkef, double ovpbidhgycs);
    string ehnnvadbla(bool elnpzkhkltkohjk, string nmmmqbiq, bool czzfnuhvp, int tvnjh, double bjywe, int xwqkgxlkux);
    bool uvjffupgllcsvuvecnti(bool hztnaiibxlngks, string wkvyyzx, double tuafkoac);
    int aqflgdxfajkweyucc(int jftukzlznfpv, double lsttaobmzhvru, string lufkw, bool dhrbyqb, bool piogf, string qscahovgwfaern, int kjxcrslklqftk, string pwncgcb);

};




double baidnqy::qalmegoietbn(bool owdyku, bool wxpbvtvo) {
    string fnmoykqzewjgxd = "fttgjlkuvtjxhjnrgrki";
    double esxinsugz = 13094;
    bool azkscwiwahkky = false;
    double bnsjvqtlmav = 46798;
    string oghttrrjp = "zkkxnrqaaaklcfmdghfitakhmxdddtzdvdxstsbgfhigwivtcxxyyl";
    int ezhihkkjrsag = 664;
    bool klgjh = false;
    bool tudmuc = false;
    string qmmqebnr = "bvhmgsqjalibkilwiyfxmtumfupikldstfjzgvrafvqrsfmzd";
    if (false == false) {
        int xr;
        for (xr = 90; xr > 0; xr--) {
            continue;
        }
    }
    if (string("fttgjlkuvtjxhjnrgrki") == string("fttgjlkuvtjxhjnrgrki")) {
        int wpqokbu;
        for (wpqokbu = 58; wpqokbu > 0; wpqokbu--) {
            continue;
        }
    }
    if (13094 != 13094) {
        int mjzgf;
        for (mjzgf = 73; mjzgf > 0; mjzgf--) {
            continue;
        }
    }
    return 81370;
}

void baidnqy::zsdlymmnvbi(double pxbat, bool baeobxwpilwi, string kcilvkef, double ovpbidhgycs) {
    int yunvq = 5722;
    double eikbkeuygyhpdz = 51221;
    int yinzhyyqeow = 3213;
    bool jfzpdylkrjjnbig = true;
    double osqikqqwfbydcw = 45958;
    if (45958 == 45958) {
        int iqx;
        for (iqx = 68; iqx > 0; iqx--) {
            continue;
        }
    }
    if (true == true) {
        int hfepa;
        for (hfepa = 48; hfepa > 0; hfepa--) {
            continue;
        }
    }
    if (true == true) {
        int lvxdprb;
        for (lvxdprb = 73; lvxdprb > 0; lvxdprb--) {
            continue;
        }
    }
    if (45958 != 45958) {
        int aspjn;
        for (aspjn = 26; aspjn > 0; aspjn--) {
            continue;
        }
    }

}

string baidnqy::ehnnvadbla(bool elnpzkhkltkohjk, string nmmmqbiq, bool czzfnuhvp, int tvnjh, double bjywe, int xwqkgxlkux) {
    string uiompuos = "mgkyqlaklfexcbkkahphqaxvkbitsfycxumnbihoilousxeagmgjatkgwwdxmurfvtkiwp";
    double urjgphyowby = 25513;
    double yxwzwyt = 30377;
    int mtlvnxjor = 4080;
    double souktmitjqsf = 1631;
    string ivlmripvltifb = "kyllspzlatdvcmymzqzdvdwuwlzgtkkyankgmleeyxfmtpslbejkaqtgafwucxjkolfafwqiljpxaabooizqonrwbasq";
    return string("htoclkztwsvuygsomqq");
}

bool baidnqy::uvjffupgllcsvuvecnti(bool hztnaiibxlngks, string wkvyyzx, double tuafkoac) {
    string fggctsezatdt = "znkpwvmhrmrqfaghrovafzcfwpasgtvivijn";
    if (string("znkpwvmhrmrqfaghrovafzcfwpasgtvivijn") == string("znkpwvmhrmrqfaghrovafzcfwpasgtvivijn")) {
        int zvighi;
        for (zvighi = 52; zvighi > 0; zvighi--) {
            continue;
        }
    }
    return false;
}

int baidnqy::aqflgdxfajkweyucc(int jftukzlznfpv, double lsttaobmzhvru, string lufkw, bool dhrbyqb, bool piogf, string qscahovgwfaern, int kjxcrslklqftk, string pwncgcb) {
    double qklwdk = 3348;
    string yovhywhvveu = "kcdedsumkylmtcnpaykgxzjxqkibvuvewoiszyefllonrfbzpvdqkybrylgtrvxnpwfvujdeampvfznypeuvefbgsbomooqfcu";
    int vygdzms = 2618;
    bool beygihzblu = false;
    string uewdbefibs = "uqnodndninttobdvunnmdpcnqhpcnyfpghyhgieuuzlijegvhluqlhbiydspeln";
    string uzvyyuj = "ifjhdelholwkgelcwajvzkgpxjdidxengengljxrrucjdolwmezgfpnvllvxpexmbosd";
    int ysokwlncpx = 3135;
    double fvausvnsyrs = 18756;
    string oblth = "yknviyxzxmbrqwmdzymokdarivarmghshiqzvdhakzjkfsiqsccxmzocfnhcqnrsjhuzf";
    double ooblqyfjcyw = 16816;
    if (3348 != 3348) {
        int dnqj;
        for (dnqj = 49; dnqj > 0; dnqj--) {
            continue;
        }
    }
    if (3135 != 3135) {
        int ifygih;
        for (ifygih = 29; ifygih > 0; ifygih--) {
            continue;
        }
    }
    if (string("uqnodndninttobdvunnmdpcnqhpcnyfpghyhgieuuzlijegvhluqlhbiydspeln") != string("uqnodndninttobdvunnmdpcnqhpcnyfpghyhgieuuzlijegvhluqlhbiydspeln")) {
        int mvqhxpnu;
        for (mvqhxpnu = 54; mvqhxpnu > 0; mvqhxpnu--) {
            continue;
        }
    }
    if (3135 != 3135) {
        int zvlfhxngwf;
        for (zvlfhxngwf = 9; zvlfhxngwf > 0; zvlfhxngwf--) {
            continue;
        }
    }
    if (string("yknviyxzxmbrqwmdzymokdarivarmghshiqzvdhakzjkfsiqsccxmzocfnhcqnrsjhuzf") != string("yknviyxzxmbrqwmdzymokdarivarmghshiqzvdhakzjkfsiqsccxmzocfnhcqnrsjhuzf")) {
        int flifx;
        for (flifx = 63; flifx > 0; flifx--) {
            continue;
        }
    }
    return 800;
}

int baidnqy::bmvtztlsumdnumpblg(int rczyiuchg, int iasgbq, double lcwqxdrhaacwt, string ohbrpiqwyp) {
    double qirusxpiq = 53389;
    bool sxmizm = false;
    if (53389 != 53389) {
        int muoumtw;
        for (muoumtw = 15; muoumtw > 0; muoumtw--) {
            continue;
        }
    }
    return 888;
}

bool baidnqy::xghszqzpdqvookzf(int qpvknok, bool sxixkmrof, int hypatojaobj) {
    bool uzxzaiopqykyijx = false;
    bool dzfxikhehkbf = false;
    int edgickxngefp = 1961;
    bool gwlbbf = false;
    bool mpdwsyfcjvbf = false;
    string jiltugwmnh = "xpnkopxnlcycugrxtjthqjdqevczsffsolakinlurzdox";
    string fdtrieviaosfvvw = "jksfhjkjoymumirtxxpleuqzztvpceoguxycqtgilwxoyjxmhcfkhzxuhnayzbomjkgmhnpoftzqqisvpbhevpmg";
    string esgrhrpswpqal = "oqhrliaabensnggjujxyraneiouywoenoacnmmmfobhcxgnhaxdabravosrelnmplcmwtumwtwpulkgxppgwvcbtqsycrs";
    if (false == false) {
        int fkmie;
        for (fkmie = 9; fkmie > 0; fkmie--) {
            continue;
        }
    }
    if (false == false) {
        int fgpsb;
        for (fgpsb = 50; fgpsb > 0; fgpsb--) {
            continue;
        }
    }
    if (string("oqhrliaabensnggjujxyraneiouywoenoacnmmmfobhcxgnhaxdabravosrelnmplcmwtumwtwpulkgxppgwvcbtqsycrs") != string("oqhrliaabensnggjujxyraneiouywoenoacnmmmfobhcxgnhaxdabravosrelnmplcmwtumwtwpulkgxppgwvcbtqsycrs")) {
        int nodlhr;
        for (nodlhr = 83; nodlhr > 0; nodlhr--) {
            continue;
        }
    }
    if (string("xpnkopxnlcycugrxtjthqjdqevczsffsolakinlurzdox") == string("xpnkopxnlcycugrxtjthqjdqevczsffsolakinlurzdox")) {
        int hnj;
        for (hnj = 54; hnj > 0; hnj--) {
            continue;
        }
    }
    return false;
}

int baidnqy::mtheidefhlnxuz(double szviyblkmc, double rvyfnwcpskdryt, string rpuylxijebv, bool mygfheiqwlsriba, bool dkwgzckrlspqk, double qskwcj) {
    double lyfjfwis = 19334;
    double smbsvsqiqppxqbe = 17695;
    int axvhuyjqooy = 2186;
    double wdlltvqeb = 38354;
    bool yiippnw = false;
    if (17695 != 17695) {
        int ua;
        for (ua = 81; ua > 0; ua--) {
            continue;
        }
    }
    return 5385;
}

void baidnqy::cioalvpfpvwovfgxhr(string tdsolvgwnql, int xeqviniko, double kfkgdcoxfpja, bool vhlczvexxasvl, bool otnwk, string vsdiyczvrxrn, int bnjeehet, int ikpwbnoswqjmioj, string sfjarakffh) {
    string qslodljfnbzream = "zuezlkjxnkjeujqbiqaa";
    double gyxiabhojpk = 2284;
    string dtgoqx = "halewuwefelpgvlysvcwwvlokcsahewqjpdnwajcdtvvoxabqmbowpbsslxkhwvjoqiurkdgirk";
    bool hwnbcfve = true;
    double iqdmuligvvngy = 3387;
    string qedrxfnxbfil = "nqucfahfpgurojogtf";
    if (string("nqucfahfpgurojogtf") == string("nqucfahfpgurojogtf")) {
        int vqznxuesrv;
        for (vqznxuesrv = 33; vqznxuesrv > 0; vqznxuesrv--) {
            continue;
        }
    }
    if (true != true) {
        int tignmlqin;
        for (tignmlqin = 67; tignmlqin > 0; tignmlqin--) {
            continue;
        }
    }
    if (3387 == 3387) {
        int lgivez;
        for (lgivez = 73; lgivez > 0; lgivez--) {
            continue;
        }
    }
    if (2284 != 2284) {
        int mbecjitt;
        for (mbecjitt = 16; mbecjitt > 0; mbecjitt--) {
            continue;
        }
    }
    if (string("halewuwefelpgvlysvcwwvlokcsahewqjpdnwajcdtvvoxabqmbowpbsslxkhwvjoqiurkdgirk") != string("halewuwefelpgvlysvcwwvlokcsahewqjpdnwajcdtvvoxabqmbowpbsslxkhwvjoqiurkdgirk")) {
        int zslhqfu;
        for (zslhqfu = 74; zslhqfu > 0; zslhqfu--) {
            continue;
        }
    }

}

int baidnqy::ckxrspogxquxchnsevuhgrlh(bool khxjbawwv, double rnnrxhyzc, int obyfjfjiavogglp, double afrcgpjnpxgtxee, bool fgwkrmeiyyxxj, bool hbiqqpd, bool jgogklyokjtfuj) {
    double mdclaok = 21022;
    double rphyxiq = 43046;
    string znpupomrzjslgen = "glwlwptyjqemorkp";
    int vmniytxexcmfw = 39;
    double gisawowhsqut = 5026;
    string uaxjbkxj = "tgsbmpciiojgrqdlrzyirjzjfljcyouaxtzfssyhysfvj";
    double ihasuo = 16878;
    if (5026 != 5026) {
        int hhjtvppzct;
        for (hhjtvppzct = 48; hhjtvppzct > 0; hhjtvppzct--) {
            continue;
        }
    }
    if (21022 == 21022) {
        int qj;
        for (qj = 60; qj > 0; qj--) {
            continue;
        }
    }
    if (43046 == 43046) {
        int glgqqebm;
        for (glgqqebm = 97; glgqqebm > 0; glgqqebm--) {
            continue;
        }
    }
    if (string("glwlwptyjqemorkp") == string("glwlwptyjqemorkp")) {
        int yjaicij;
        for (yjaicij = 59; yjaicij > 0; yjaicij--) {
            continue;
        }
    }
    if (string("glwlwptyjqemorkp") == string("glwlwptyjqemorkp")) {
        int fvtfih;
        for (fvtfih = 61; fvtfih > 0; fvtfih--) {
            continue;
        }
    }
    return 8132;
}

int baidnqy::pyxosfxhur(double sxyhrzsc, int jjjxsk, int lbxlpetigsxgtjw, double tfozgmdz, double rggzi, int gedkezctlvbucrw, double biifcotjikrri, double khfupl) {
    bool somcuzapxijn = true;
    int eesuyx = 5470;
    int iqzyfhls = 7856;
    string islhqt = "cjvghnhcgrvuaalfgobgzszlavfsxfsxzsdbmyph";
    double qbavpkfpr = 30875;
    if (7856 == 7856) {
        int eywjxnf;
        for (eywjxnf = 87; eywjxnf > 0; eywjxnf--) {
            continue;
        }
    }
    if (string("cjvghnhcgrvuaalfgobgzszlavfsxfsxzsdbmyph") == string("cjvghnhcgrvuaalfgobgzszlavfsxfsxzsdbmyph")) {
        int rowzq;
        for (rowzq = 43; rowzq > 0; rowzq--) {
            continue;
        }
    }
    if (string("cjvghnhcgrvuaalfgobgzszlavfsxfsxzsdbmyph") != string("cjvghnhcgrvuaalfgobgzszlavfsxfsxzsdbmyph")) {
        int qlbt;
        for (qlbt = 59; qlbt > 0; qlbt--) {
            continue;
        }
    }
    return 53946;
}

void baidnqy::dvhgewfldgxckwxamitysn(double cbtvxukifaaj, string hyvsncp, bool snouqcc) {
    string hqief = "meunsncbqwpcphegvvxaccrkukfrufwmmkuwlt";
    string jiphqmfwsj = "lpkexkzenwfk";
    int icpitw = 74;
    bool bytxgrjueagx = true;
    if (true == true) {
        int wipexvgp;
        for (wipexvgp = 45; wipexvgp > 0; wipexvgp--) {
            continue;
        }
    }
    if (true != true) {
        int drvrttetx;
        for (drvrttetx = 10; drvrttetx > 0; drvrttetx--) {
            continue;
        }
    }
    if (true == true) {
        int canypo;
        for (canypo = 35; canypo > 0; canypo--) {
            continue;
        }
    }
    if (true == true) {
        int pbij;
        for (pbij = 48; pbij > 0; pbij--) {
            continue;
        }
    }

}

int baidnqy::fudirqhudsfkoejm() {
    bool hiojgk = false;
    return 59436;
}

void baidnqy::xddyueadqrujx(double psghbcvybjhaq, string ghzmjxztojqqivl, int rtxloeaw, string yjgajvtqbwla, int dzmevjpyd, bool aacldqexlacaz, string kvyrtqpxzjitfyc, bool ueumdkexqgdsx) {

}

bool baidnqy::qrbqttngbdiyoczbvixcwgym(double sqxaubjqtavi) {
    int fckideogvqfelt = 3816;
    int ctojjarqu = 322;
    if (322 != 322) {
        int xncf;
        for (xncf = 60; xncf > 0; xncf--) {
            continue;
        }
    }
    return false;
}

void baidnqy::zunsdgfliabzawhwxidbl(bool uulbdakpchwrq, bool chvkxnhzyvj, string kjabwljfhcxee) {
    double ktusqsnvyyeqhbf = 4553;
    string dxgvcfnn = "lvsyekzboagvwbhpzsihdnh";
    int kknuk = 5600;
    int jlworucildsidwj = 215;
    if (string("lvsyekzboagvwbhpzsihdnh") != string("lvsyekzboagvwbhpzsihdnh")) {
        int rbyxqox;
        for (rbyxqox = 22; rbyxqox > 0; rbyxqox--) {
            continue;
        }
    }
    if (5600 == 5600) {
        int fsg;
        for (fsg = 50; fsg > 0; fsg--) {
            continue;
        }
    }
    if (5600 == 5600) {
        int sx;
        for (sx = 22; sx > 0; sx--) {
            continue;
        }
    }

}

bool baidnqy::bhxlniiouylycke(double ziqssd, int mfhvqbipagmxtwl, string egzeeicuewhgc, string eovrgwwg, double wbwcggdw, string innkg, int lquoycanwxp, double ztzmcasiayvs, double kisrcrtk, int mznzogetmhl) {
    double uoycyu = 13728;
    double actzue = 25403;
    int ewxqvkxhqphco = 3793;
    string etduumyeyoqxezh = "fkzhxjbqtplfzeehcetgiboovxdpimvodmwvkdmdgfodvwwttzdi";
    bool uqbftbsryomoft = true;
    string hqwys = "tdlkkamemaqettwchcxnktwscadffkwkwmcbyzksqy";
    string adlgqyhy = "oynklfbdxmmyewivbnvkehxodefogyyacgoavzlxtvtir";
    string cutqanvhrazerl = "hcmqvciwwrus";
    double lxviazvis = 61643;
    bool gnkfi = true;
    if (string("fkzhxjbqtplfzeehcetgiboovxdpimvodmwvkdmdgfodvwwttzdi") != string("fkzhxjbqtplfzeehcetgiboovxdpimvodmwvkdmdgfodvwwttzdi")) {
        int upx;
        for (upx = 90; upx > 0; upx--) {
            continue;
        }
    }
    if (string("fkzhxjbqtplfzeehcetgiboovxdpimvodmwvkdmdgfodvwwttzdi") == string("fkzhxjbqtplfzeehcetgiboovxdpimvodmwvkdmdgfodvwwttzdi")) {
        int dgbrdsbei;
        for (dgbrdsbei = 38; dgbrdsbei > 0; dgbrdsbei--) {
            continue;
        }
    }
    if (string("oynklfbdxmmyewivbnvkehxodefogyyacgoavzlxtvtir") != string("oynklfbdxmmyewivbnvkehxodefogyyacgoavzlxtvtir")) {
        int nhkgxotx;
        for (nhkgxotx = 99; nhkgxotx > 0; nhkgxotx--) {
            continue;
        }
    }
    if (25403 == 25403) {
        int lbcsynogkn;
        for (lbcsynogkn = 23; lbcsynogkn > 0; lbcsynogkn--) {
            continue;
        }
    }
    if (true == true) {
        int ywkreuebj;
        for (ywkreuebj = 47; ywkreuebj > 0; ywkreuebj--) {
            continue;
        }
    }
    return false;
}

int baidnqy::krdgrujdmjmgxbqeskjn(string akwrasrexzefh, double nkitjexyh, bool foavqeaqhvsi, double yyvgfcaoqfdydoe, int ebbwwtpfqy, string dnsxvzlta, double utpwbuoxwfbspoi) {
    double iifphfxlms = 78541;
    double wcynr = 16387;
    if (78541 == 78541) {
        int irwlwizfhw;
        for (irwlwizfhw = 32; irwlwizfhw > 0; irwlwizfhw--) {
            continue;
        }
    }
    return 447;
}

double baidnqy::tytdknrawwzx(string pcnnxax, bool ymlxefpscyhg, int nnuowrbfosqln, int xztvusi, double mjahwabxl, string rcbfk, double xixcgu, string ixglmvc) {
    return 11769;
}

bool baidnqy::lgezezmxln() {
    string ihgbefeakzcrkim = "opjesahrvvlfoasppaeidzpdlgwwyutobjmbaheeiabhsptrhlqqturqsqiheizslhkpawzt";
    string lrpzdxurcbiiw = "ucpulbkfpeyelhpwdwkjxjmeslpvygdujdfgwypgbuyxwugxmskzfvylm";
    double utrtqpxu = 38479;
    string bnvgbxngvsic = "ghdfufncdrmuijicrseaalckqtjugidbvrpybocqzkhchruef";
    string avkmgizawrbr = "mpjrgud";
    string rojmvmqzxwsrs = "nnlmjshjctpuxjdylksvlzeslpytoiavzgiftiwdpemhvmcrgemgxrjeukacpekubzmfacxrzzrkiizidobtplhfptxxmxderu";
    double faylcxhfefxrzc = 1785;
    int qwbxaism = 1552;
    double kfkhqmiadrp = 27335;
    if (string("nnlmjshjctpuxjdylksvlzeslpytoiavzgiftiwdpemhvmcrgemgxrjeukacpekubzmfacxrzzrkiizidobtplhfptxxmxderu") == string("nnlmjshjctpuxjdylksvlzeslpytoiavzgiftiwdpemhvmcrgemgxrjeukacpekubzmfacxrzzrkiizidobtplhfptxxmxderu")) {
        int iquccwtwb;
        for (iquccwtwb = 48; iquccwtwb > 0; iquccwtwb--) {
            continue;
        }
    }
    if (string("opjesahrvvlfoasppaeidzpdlgwwyutobjmbaheeiabhsptrhlqqturqsqiheizslhkpawzt") != string("opjesahrvvlfoasppaeidzpdlgwwyutobjmbaheeiabhsptrhlqqturqsqiheizslhkpawzt")) {
        int skbmpeot;
        for (skbmpeot = 28; skbmpeot > 0; skbmpeot--) {
            continue;
        }
    }
    if (string("opjesahrvvlfoasppaeidzpdlgwwyutobjmbaheeiabhsptrhlqqturqsqiheizslhkpawzt") != string("opjesahrvvlfoasppaeidzpdlgwwyutobjmbaheeiabhsptrhlqqturqsqiheizslhkpawzt")) {
        int twmmgvkj;
        for (twmmgvkj = 93; twmmgvkj > 0; twmmgvkj--) {
            continue;
        }
    }
    return false;
}

baidnqy::baidnqy() {
    this->zunsdgfliabzawhwxidbl(true, false, string("rtqrpqjpckbwlhlsxwqalxnluocpdnwlomabrxsmk"));
    this->bhxlniiouylycke(39324, 2759, string("nxrtkxzdyiaumxejpgxtnowkdnunbi"), string("sptlydsuyiczeuiumwtobpvyvs"), 5787, string("xfijjlawruyippoouzffogvqwqvmlfkeehjpwwnzghgdsyciddiojddtqzdqeqkjmhcuhuxkhljzeunsctuixhltzvydd"), 2930, 5770, 53260, 1566);
    this->krdgrujdmjmgxbqeskjn(string("oohtg"), 50027, false, 9153, 941, string("hjthx"), 16285);
    this->tytdknrawwzx(string("ewowtanzckruszglptutzc"), true, 30, 1894, 47047, string("glnrhqiibpfflmtlpzogtwprpnprasvmiroiywtbsixkcjvwkpkhewkoduafigzkbvdvyowwnxfssuihpg"), 4092, string("kdnoyloleukwvxuyqonrxtxrbhjerevirmzaxlcnagzidblvzwwhdxconwdypanlbgbyagpglyul"));
    this->lgezezmxln();
    this->bmvtztlsumdnumpblg(1298, 2560, 20873, string("glcjzbhzfrrvjbdptpqednpjxpgolcaowbwdlnmfjubbufmtclmaqspfxhmmjzbnvgzeulxmfucpkjgl"));
    this->xghszqzpdqvookzf(5509, true, 2518);
    this->mtheidefhlnxuz(14307, 55550, string("hbyloygkcyctcvqgmyyegezuybsacxulzejj"), false, false, 28990);
    this->cioalvpfpvwovfgxhr(string("mutldxtjzxamvhuqvtftogba"), 3328, 11632, true, false, string("gpsadbtjphqejstfnzbfgszlszoi"), 1008, 2282, string("nwnwouerr"));
    this->ckxrspogxquxchnsevuhgrlh(false, 18090, 1779, 10680, false, false, false);
    this->pyxosfxhur(23563, 715, 7708, 27871, 10530, 3907, 63422, 44983);
    this->dvhgewfldgxckwxamitysn(11448, string("wnxqaoepogcoazcetinsyordapqolqvmtubjibjtwzrnhglecegygvtarjazpeueqn"), true);
    this->fudirqhudsfkoejm();
    this->xddyueadqrujx(15095, string("rzsrpeyotfzrvskvkrwlpeoayop"), 1622, string("zvmxouzvgwwskradcvrkzfprihyhdjduzgkzmxlwgfn"), 5761, false, string("qjmrvyrexrnksqixizzrxdqbeqjpvvalzxskrdpcjbuzqfiegeymuam"), false);
    this->qrbqttngbdiyoczbvixcwgym(6861);
    this->qalmegoietbn(true, true);
    this->zsdlymmnvbi(19605, false, string(""), 3619);
    this->ehnnvadbla(true, string("gidxgqggwnhjoukydjzxyjgleglzbqucsh"), false, 2500, 12935, 3595);
    this->uvjffupgllcsvuvecnti(false, string("qfzfvhawraxyliaiph"), 17304);
    this->aqflgdxfajkweyucc(5391, 13441, string("rxruubmggdtfggwtpu"), false, true, string("jafdiukdzjqscjsbrwzcfzlaz"), 1773, string("xlmkmlbtiydwbmktfgskfyotvkhhutwituivgvoudulltruwpewrbkdyuuobpgohhkvejnblbijm"));
}


static bool windowOpen = false;

void StreamProofESP::menuBarItem() noexcept
{
    if (ImGui::MenuItem("ESP")) {
        windowOpen = true;
        ImGui::SetWindowFocus("ESP");
        ImGui::SetWindowPos("ESP", { 100.0f, 100.0f });
    }
}

void StreamProofESP::tabItem() noexcept
{
    if (ImGui::BeginTabItem("ESP")) {
        drawGUI(true);
        ImGui::EndTabItem();
    }
}

void StreamProofESP::drawGUI(bool contentOnly) noexcept
{
    if (!contentOnly) {
        if (!windowOpen)
            return;
        ImGui::SetNextWindowSize({ 0.0f, 0.0f });
        ImGui::Begin("ESP", &windowOpen, ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoScrollWithMouse);
    }

    ImGui::hotkey("Toggle Key", config->streamProofESP.toggleKey, 80.0f);
    ImGui::hotkey("Hold Key", config->streamProofESP.holdKey, 80.0f);
    ImGui::Separator();

    static std::size_t currentCategory;
    static auto currentItem = "All";

    constexpr auto getConfigShared = [](std::size_t category, const char* item) noexcept -> Shared& {
        switch (category) {
        case 0: default: return config->streamProofESP.enemies[item];
        case 1: return config->streamProofESP.allies[item];
        case 2: return config->streamProofESP.weapons[item];
        case 3: return config->streamProofESP.projectiles[item];
        case 4: return config->streamProofESP.lootCrates[item];
        case 5: return config->streamProofESP.otherEntities[item];
        }
    };

    constexpr auto getConfigPlayer = [](std::size_t category, const char* item) noexcept -> Player& {
        switch (category) {
        case 0: default: return config->streamProofESP.enemies[item];
        case 1: return config->streamProofESP.allies[item];
        }
    };

    if (ImGui::BeginListBox("##list", { 170.0f, 300.0f })) {
        constexpr std::array categories{ "Enemies", "Allies", "Weapons", "Projectiles", "Loot Crates", "Other Entities" };

        for (std::size_t i = 0; i < categories.size(); ++i) {
            if (ImGui::Selectable(categories[i], currentCategory == i && std::string_view{ currentItem } == "All")) {
                currentCategory = i;
                currentItem = "All";
            }

            if (ImGui::BeginDragDropSource()) {
                switch (i) {
                case 0: case 1: ImGui::SetDragDropPayload("Player", &getConfigPlayer(i, "All"), sizeof(Player), ImGuiCond_Once); break;
                case 2: ImGui::SetDragDropPayload("Weapon", &config->streamProofESP.weapons["All"], sizeof(Weapon), ImGuiCond_Once); break;
                case 3: ImGui::SetDragDropPayload("Projectile", &config->streamProofESP.projectiles["All"], sizeof(Projectile), ImGuiCond_Once); break;
                default: ImGui::SetDragDropPayload("Entity", &getConfigShared(i, "All"), sizeof(Shared), ImGuiCond_Once); break;
                }
                ImGui::EndDragDropSource();
            }

            if (ImGui::BeginDragDropTarget()) {
                if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload("Player")) {
                    const auto& data = *(Player*)payload->Data;

                    switch (i) {
                    case 0: case 1: getConfigPlayer(i, "All") = data; break;
                    case 2: config->streamProofESP.weapons["All"] = data; break;
                    case 3: config->streamProofESP.projectiles["All"] = data; break;
                    default: getConfigShared(i, "All") = data; break;
                    }
                }

                if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload("Weapon")) {
                    const auto& data = *(Weapon*)payload->Data;

                    switch (i) {
                    case 0: case 1: getConfigPlayer(i, "All") = data; break;
                    case 2: config->streamProofESP.weapons["All"] = data; break;
                    case 3: config->streamProofESP.projectiles["All"] = data; break;
                    default: getConfigShared(i, "All") = data; break;
                    }
                }

                if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload("Projectile")) {
                    const auto& data = *(Projectile*)payload->Data;

                    switch (i) {
                    case 0: case 1: getConfigPlayer(i, "All") = data; break;
                    case 2: config->streamProofESP.weapons["All"] = data; break;
                    case 3: config->streamProofESP.projectiles["All"] = data; break;
                    default: getConfigShared(i, "All") = data; break;
                    }
                }

                if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload("Entity")) {
                    const auto& data = *(Shared*)payload->Data;

                    switch (i) {
                    case 0: case 1: getConfigPlayer(i, "All") = data; break;
                    case 2: config->streamProofESP.weapons["All"] = data; break;
                    case 3: config->streamProofESP.projectiles["All"] = data; break;
                    default: getConfigShared(i, "All") = data; break;
                    }
                }
                ImGui::EndDragDropTarget();
            }

            ImGui::PushID(i);
            ImGui::Indent();

            const auto items = [](std::size_t category) noexcept -> std::vector<const char*> {
                switch (category) {
                case 0:
                case 1: return { "Visible", "Occluded" };
                case 2: return { "Pistols", "SMGs", "Rifles", "Sniper Rifles", "Shotguns", "Machineguns", "Grenades", "Melee", "Other" };
                case 3: return { "Flashbang", "HE Grenade", "Breach Charge", "Bump Mine", "Decoy Grenade", "Molotov", "TA Grenade", "Smoke Grenade", "Snowball" };
                case 4: return { "Pistol Case", "Light Case", "Heavy Case", "Explosive Case", "Tools Case", "Cash Dufflebag" };
                case 5: return { "Defuse Kit", "Chicken", "Planted C4", "Hostage", "Sentry", "Cash", "Ammo Box", "Radar Jammer", "Snowball Pile", "Collectable Coin" };
                default: return { };
                }
            }(i);

            const auto categoryEnabled = getConfigShared(i, "All").enabled;

            for (std::size_t j = 0; j < items.size(); ++j) {
                static bool selectedSubItem;
                if (!categoryEnabled || getConfigShared(i, items[j]).enabled) {
                    if (ImGui::Selectable(items[j], currentCategory == i && !selectedSubItem && std::string_view{ currentItem } == items[j])) {
                        currentCategory = i;
                        currentItem = items[j];
                        selectedSubItem = false;
                    }

                    if (ImGui::BeginDragDropSource()) {
                        switch (i) {
                        case 0: case 1: ImGui::SetDragDropPayload("Player", &getConfigPlayer(i, items[j]), sizeof(Player), ImGuiCond_Once); break;
                        case 2: ImGui::SetDragDropPayload("Weapon", &config->streamProofESP.weapons[items[j]], sizeof(Weapon), ImGuiCond_Once); break;
                        case 3: ImGui::SetDragDropPayload("Projectile", &config->streamProofESP.projectiles[items[j]], sizeof(Projectile), ImGuiCond_Once); break;
                        default: ImGui::SetDragDropPayload("Entity", &getConfigShared(i, items[j]), sizeof(Shared), ImGuiCond_Once); break;
                        }
                        ImGui::EndDragDropSource();
                    }

                    if (ImGui::BeginDragDropTarget()) {
                        if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload("Player")) {
                            const auto& data = *(Player*)payload->Data;

                            switch (i) {
                            case 0: case 1: getConfigPlayer(i, items[j]) = data; break;
                            case 2: config->streamProofESP.weapons[items[j]] = data; break;
                            case 3: config->streamProofESP.projectiles[items[j]] = data; break;
                            default: getConfigShared(i, items[j]) = data; break;
                            }
                        }

                        if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload("Weapon")) {
                            const auto& data = *(Weapon*)payload->Data;

                            switch (i) {
                            case 0: case 1: getConfigPlayer(i, items[j]) = data; break;
                            case 2: config->streamProofESP.weapons[items[j]] = data; break;
                            case 3: config->streamProofESP.projectiles[items[j]] = data; break;
                            default: getConfigShared(i, items[j]) = data; break;
                            }
                        }

                        if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload("Projectile")) {
                            const auto& data = *(Projectile*)payload->Data;

                            switch (i) {
                            case 0: case 1: getConfigPlayer(i, items[j]) = data; break;
                            case 2: config->streamProofESP.weapons[items[j]] = data; break;
                            case 3: config->streamProofESP.projectiles[items[j]] = data; break;
                            default: getConfigShared(i, items[j]) = data; break;
                            }
                        }

                        if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload("Entity")) {
                            const auto& data = *(Shared*)payload->Data;

                            switch (i) {
                            case 0: case 1: getConfigPlayer(i, items[j]) = data; break;
                            case 2: config->streamProofESP.weapons[items[j]] = data; break;
                            case 3: config->streamProofESP.projectiles[items[j]] = data; break;
                            default: getConfigShared(i, items[j]) = data; break;
                            }
                        }
                        ImGui::EndDragDropTarget();
                    }
                }

                if (i != 2)
                    continue;

                ImGui::Indent();

                const auto subItems = [](std::size_t item) noexcept -> std::vector<const char*> {
                    switch (item) {
                    case 0: return { "Glock-18", "P2000", "USP-S", "Dual Berettas", "P250", "Tec-9", "Five-SeveN", "CZ75-Auto", "Desert Eagle", "R8 Revolver" };
                    case 1: return { "MAC-10", "MP9", "MP7", "MP5-SD", "UMP-45", "P90", "PP-Bizon" };
                    case 2: return { "Galil AR", "FAMAS", "AK-47", "M4A4", "M4A1-S", "SG 553", "AUG" };
                    case 3: return { "SSG 08", "AWP", "G3SG1", "SCAR-20" };
                    case 4: return { "Nova", "XM1014", "Sawed-Off", "MAG-7" };
                    case 5: return { "M249", "Negev" };
                    case 6: return { "Flashbang", "HE Grenade", "Smoke Grenade", "Molotov", "Decoy Grenade", "Incendiary", "TA Grenade", "Fire Bomb", "Diversion", "Frag Grenade", "Snowball" };
                    case 7: return { "Axe", "Hammer", "Wrench" };
                    case 8: return { "C4", "Healthshot", "Bump Mine", "Zone Repulsor", "Shield" };
                    default: return { };
                    }
                }(j);

                const auto itemEnabled = getConfigShared(i, items[j]).enabled;

                for (const auto subItem : subItems) {
                    auto& subItemConfig = config->streamProofESP.weapons[subItem];
                    if ((categoryEnabled || itemEnabled) && !subItemConfig.enabled)
                        continue;

                    if (ImGui::Selectable(subItem, currentCategory == i && selectedSubItem && std::string_view{ currentItem } == subItem)) {
                        currentCategory = i;
                        currentItem = subItem;
                        selectedSubItem = true;
                    }

                    if (ImGui::BeginDragDropSource()) {
                        ImGui::SetDragDropPayload("Weapon", &subItemConfig, sizeof(Weapon), ImGuiCond_Once);
                        ImGui::EndDragDropSource();
                    }

                    if (ImGui::BeginDragDropTarget()) {
                        if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload("Player")) {
                            const auto& data = *(Player*)payload->Data;
                            subItemConfig = data;
                        }

                        if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload("Weapon")) {
                            const auto& data = *(Weapon*)payload->Data;
                            subItemConfig = data;
                        }

                        if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload("Projectile")) {
                            const auto& data = *(Projectile*)payload->Data;
                            subItemConfig = data;
                        }

                        if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload("Entity")) {
                            const auto& data = *(Shared*)payload->Data;
                            subItemConfig = data;
                        }
                        ImGui::EndDragDropTarget();
                    }
                }

                ImGui::Unindent();
            }
            ImGui::Unindent();
            ImGui::PopID();
        }
        ImGui::EndListBox();
    }

    ImGui::SameLine();

    if (ImGui::BeginChild("##child", { 400.0f, 0.0f })) {
        auto& sharedConfig = getConfigShared(currentCategory, currentItem);

        ImGui::Checkbox("Enabled", &sharedConfig.enabled);
        ImGui::SameLine(ImGui::GetWindowContentRegionMax().x - 260.0f);
        ImGui::SetNextItemWidth(220.0f);
        if (ImGui::BeginCombo("Font", config->getSystemFonts()[sharedConfig.font.index].c_str())) {
            for (size_t i = 0; i < config->getSystemFonts().size(); i++) {
                bool isSelected = config->getSystemFonts()[i] == sharedConfig.font.name;
                if (ImGui::Selectable(config->getSystemFonts()[i].c_str(), isSelected, 0, { 250.0f, 0.0f })) {
                    sharedConfig.font.index = i;
                    sharedConfig.font.name = config->getSystemFonts()[i];
                    config->scheduleFontLoad(sharedConfig.font.name);
                }
                if (isSelected)
                    ImGui::SetItemDefaultFocus();
            }
            ImGui::EndCombo();
        }

        ImGui::Separator();

        constexpr auto spacing = 250.0f;
        ImGuiCustom::colorPicker("Snapline", sharedConfig.snapline);
        ImGui::SameLine();
        ImGui::SetNextItemWidth(90.0f);
        ImGui::Combo("##1", &sharedConfig.snapline.type, "Bottom\0Top\0Crosshair\0");
        ImGui::SameLine(spacing);
        ImGuiCustom::colorPicker("Box", sharedConfig.box);
        ImGui::SameLine();

        ImGui::PushID("Box");

        if (ImGui::Button("..."))
            ImGui::OpenPopup("");

        if (ImGui::BeginPopup("")) {
            ImGui::SetNextItemWidth(95.0f);
            ImGui::Combo("Type", &sharedConfig.box.type, "2D\0" "2D corners\0" "3D\0" "3D corners\0");
            ImGui::SetNextItemWidth(275.0f);
            ImGui::SliderFloat3("Scale", sharedConfig.box.scale.data(), 0.0f, 0.50f, "%.2f");
            ImGuiCustom::colorPicker("Fill", sharedConfig.box.fill);
            ImGui::EndPopup();
        }

        ImGui::PopID();

        ImGuiCustom::colorPicker("Name", sharedConfig.name);
        ImGui::SameLine(spacing);

        if (currentCategory < 2) {
            auto& playerConfig = getConfigPlayer(currentCategory, currentItem);

            ImGuiCustom::colorPicker("Weapon", playerConfig.weapon);
            ImGuiCustom::colorPicker("Flash Duration", playerConfig.flashDuration);
            ImGui::SameLine(spacing);
            ImGuiCustom::colorPicker("Skeleton", playerConfig.skeleton);
            ImGui::Checkbox("Audible Only", &playerConfig.audibleOnly);
            ImGui::SameLine(spacing);
            ImGui::Checkbox("Spotted Only", &playerConfig.spottedOnly);

            ImGuiCustom::colorPicker("Head Box", playerConfig.headBox);
            ImGui::SameLine();

            ImGui::PushID("Head Box");

            if (ImGui::Button("..."))
                ImGui::OpenPopup("");

            if (ImGui::BeginPopup("")) {
                ImGui::SetNextItemWidth(95.0f);
                ImGui::Combo("Type", &playerConfig.headBox.type, "2D\0" "2D corners\0" "3D\0" "3D corners\0");
                ImGui::SetNextItemWidth(275.0f);
                ImGui::SliderFloat3("Scale", playerConfig.headBox.scale.data(), 0.0f, 0.50f, "%.2f");
                ImGuiCustom::colorPicker("Fill", playerConfig.headBox.fill);
                ImGui::EndPopup();
            }

            ImGui::PopID();

            ImGui::SameLine(spacing);
            ImGui::Checkbox("Health Bar", &playerConfig.healthBar.enabled);
            ImGui::SameLine();

            ImGui::PushID("Health Bar");

            if (ImGui::Button("..."))
                ImGui::OpenPopup("");

            if (ImGui::BeginPopup("")) {
                ImGui::SetNextItemWidth(95.0f);
                ImGui::Combo("Type", &playerConfig.healthBar.type, "Gradient\0Solid\0Health-based\0");
                if (playerConfig.healthBar.type == HealthBar::Solid) {
                    ImGui::SameLine();
                    ImGuiCustom::colorPicker("", playerConfig.healthBar.asColor4());
                }
                ImGui::EndPopup();
            }

            ImGui::PopID();
        }
        else if (currentCategory == 2) {
            auto& weaponConfig = config->streamProofESP.weapons[currentItem];
            ImGuiCustom::colorPicker("Ammo", weaponConfig.ammo);
        }
        else if (currentCategory == 3) {
            auto& trails = config->streamProofESP.projectiles[currentItem].trails;

            ImGui::Checkbox("Trails", &trails.enabled);
            ImGui::SameLine(spacing + 77.0f);
            ImGui::PushID("Trails");

            if (ImGui::Button("..."))
                ImGui::OpenPopup("");

            if (ImGui::BeginPopup("")) {
                constexpr auto trailPicker = [](const char* name, Trail& trail) noexcept {
                    ImGui::PushID(name);
                    ImGuiCustom::colorPicker(name, trail);
                    ImGui::SameLine(150.0f);
                    ImGui::SetNextItemWidth(95.0f);
                    ImGui::Combo("", &trail.type, "Line\0Circles\0Filled Circles\0");
                    ImGui::SameLine();
                    ImGui::SetNextItemWidth(95.0f);
                    ImGui::InputFloat("Time", &trail.time, 0.1f, 0.5f, "%.1fs");
                    trail.time = std::clamp(trail.time, 1.0f, 60.0f);
                    ImGui::PopID();
                };

                trailPicker("Local Player", trails.localPlayer);
                trailPicker("Allies", trails.allies);
                trailPicker("Enemies", trails.enemies);
                ImGui::EndPopup();
            }

            ImGui::PopID();
        }

        ImGui::SetNextItemWidth(95.0f);
        ImGui::InputFloat("Text Cull Distance", &sharedConfig.textCullDistance, 0.4f, 0.8f, "%.1fm");
        sharedConfig.textCullDistance = std::clamp(sharedConfig.textCullDistance, 0.0f, 999.9f);
    }

    ImGui::EndChild();

    if (!contentOnly)
        ImGui::End();
}


static bool worldToScreen(const Vector& in, ImVec2& out, bool floor = true) noexcept
{
    const auto& matrix = GameData::toScreenMatrix();

    const auto w = matrix._41 * in.x + matrix._42 * in.y + matrix._43 * in.z + matrix._44;
    if (w < 0.001f)
        return false;

    out = ImGui::GetIO().DisplaySize / 2.0f;
    out.x *= 1.0f + (matrix._11 * in.x + matrix._12 * in.y + matrix._13 * in.z + matrix._14) / w;
    out.y *= 1.0f - (matrix._21 * in.x + matrix._22 * in.y + matrix._23 * in.z + matrix._24) / w;
    if (floor)
        out = ImFloor(out);
    return true;
}

static constexpr auto operator-(float sub, const std::array<float, 3>& a) noexcept
{
    return Vector{ sub - a[0], sub - a[1], sub - a[2] };
}

struct BoundingBox {
private:
    bool valid;
public:
    ImVec2 min, max;
    std::array<ImVec2, 8> vertices;

    BoundingBox(const Vector& mins, const Vector& maxs, const std::array<float, 3>& scale, const matrix3x4* matrix = nullptr) noexcept
    {
        min.y = min.x = std::numeric_limits<float>::max();
        max.y = max.x = -std::numeric_limits<float>::max();

        const auto scaledMins = mins + (maxs - mins) * 2 * (0.25f - scale);
        const auto scaledMaxs = maxs - (maxs - mins) * 2 * (0.25f - scale);

        for (int i = 0; i < 8; ++i) {
            const Vector point{ i & 1 ? scaledMaxs.x : scaledMins.x,
                                i & 2 ? scaledMaxs.y : scaledMins.y,
                                i & 4 ? scaledMaxs.z : scaledMins.z };

            if (!worldToScreen(matrix ? point.transform(*matrix) : point, vertices[i])) {
                valid = false;
                return;
            }

            min.x = std::min(min.x, vertices[i].x);
            min.y = std::min(min.y, vertices[i].y);
            max.x = std::max(max.x, vertices[i].x);
            max.y = std::max(max.y, vertices[i].y);
        }
        valid = true;
    }

    BoundingBox(const BaseData& data, const std::array<float, 3>& scale) noexcept : BoundingBox{ data.obbMins, data.obbMaxs, scale, &data.coordinateFrame } {}
    BoundingBox(const Vector& center) noexcept : BoundingBox{ center - 2.0f, center + 2.0f, { 0.25f, 0.25f, 0.25f } } {}

    operator bool() const noexcept
    {
        return valid;
    }
};

static ImDrawList* drawList;

static void addLineWithShadow(const ImVec2& p1, const ImVec2& p2, ImU32 col) noexcept
{
    drawList->AddLine(p1 + ImVec2{ 1.0f, 1.0f }, p2 + ImVec2{ 1.0f, 1.0f }, col & IM_COL32_A_MASK);
    drawList->AddLine(p1, p2, col);
}

// convex hull using Graham's scan
static std::pair<std::array<ImVec2, 8>, std::size_t> convexHull(std::array<ImVec2, 8> points) noexcept
{
    std::swap(points[0], *std::min_element(points.begin(), points.end(), [](const auto& a, const auto& b) { return a.y < b.y || (a.y == b.y && a.x < b.x); }));

    constexpr auto orientation = [](const ImVec2& a, const ImVec2& b, const ImVec2& c) {
        return (b.x - a.x) * (c.y - a.y) - (c.x - a.x) * (b.y - a.y);
    };

    std::sort(points.begin() + 1, points.end(), [&](const auto& a, const auto& b) {
        const auto o = orientation(points[0], a, b);
        return o == 0.0f ? ImLengthSqr(points[0] - a) < ImLengthSqr(points[0] - b) : o < 0.0f;
    });

    std::array<ImVec2, 8> hull;
    std::size_t count = 0;

    for (const auto& p : points) {
        while (count >= 2 && orientation(hull[count - 2], hull[count - 1], p) >= 0.0f)
            --count;
        hull[count++] = p;
    }

    return std::make_pair(hull, count);
}

static void addRectFilled(const ImVec2& p1, const ImVec2& p2, ImU32 col, bool shadow) noexcept
{
    if (shadow)
        drawList->AddRectFilled(p1 + ImVec2{ 1.0f, 1.0f }, p2 + ImVec2{ 1.0f, 1.0f }, col & IM_COL32_A_MASK);
    drawList->AddRectFilled(p1, p2, col);
}

static void renderBox(const BoundingBox& bbox, const Box& config) noexcept
{
    if (!config.enabled)
        return;

    const ImU32 color = Helpers::calculateColor(config.asColor4());
    const ImU32 fillColor = Helpers::calculateColor(config.fill.asColor4());

    switch (config.type) {
    case Box::_2d:
        if (config.fill.enabled)
            drawList->AddRectFilled(bbox.min + ImVec2{ 1.0f, 1.0f }, bbox.max - ImVec2{ 1.0f, 1.0f }, fillColor, config.rounding, ImDrawFlags_RoundCornersAll);
        else
            drawList->AddRect(bbox.min + ImVec2{ 1.0f, 1.0f }, bbox.max + ImVec2{ 1.0f, 1.0f }, color & IM_COL32_A_MASK, config.rounding, ImDrawFlags_RoundCornersAll);
        drawList->AddRect(bbox.min, bbox.max, color, config.rounding, ImDrawFlags_RoundCornersAll);
        break;
    case Box::_2dCorners: {
        if (config.fill.enabled) {
            drawList->AddRectFilled(bbox.min + ImVec2{ 1.0f, 1.0f }, bbox.max - ImVec2{ 1.0f, 1.0f }, fillColor, config.rounding, ImDrawFlags_RoundCornersAll);
        }

        const bool wantsShadow = !config.fill.enabled;

        const auto quarterWidth = IM_FLOOR((bbox.max.x - bbox.min.x) * 0.25f);
        const auto quarterHeight = IM_FLOOR((bbox.max.y - bbox.min.y) * 0.25f);

        addRectFilled(bbox.min, { bbox.min.x + 1.0f, bbox.min.y + quarterHeight }, color, wantsShadow);
        addRectFilled(bbox.min, { bbox.min.x + quarterWidth, bbox.min.y + 1.0f }, color, wantsShadow);

        addRectFilled({ bbox.max.x, bbox.min.y }, { bbox.max.x - quarterWidth, bbox.min.y + 1.0f }, color, wantsShadow);
        addRectFilled({ bbox.max.x - 1.0f, bbox.min.y }, { bbox.max.x, bbox.min.y + quarterHeight }, color, wantsShadow);

        addRectFilled({ bbox.min.x, bbox.max.y }, { bbox.min.x + 1.0f, bbox.max.y - quarterHeight }, color, wantsShadow);
        addRectFilled({ bbox.min.x, bbox.max.y - 1.0f }, { bbox.min.x + quarterWidth, bbox.max.y }, color, wantsShadow);

        addRectFilled(bbox.max, { bbox.max.x - quarterWidth, bbox.max.y - 1.0f }, color, wantsShadow);
        addRectFilled(bbox.max, { bbox.max.x - 1.0f, bbox.max.y - quarterHeight }, color, wantsShadow);
        break;
    }
    case Box::_3d:
        if (config.fill.enabled) {
            auto [hull, count] = convexHull(bbox.vertices);
            std::reverse(hull.begin(), hull.begin() + count); // make them clockwise for antialiasing
            drawList->AddConvexPolyFilled(hull.data(), count, fillColor);
        } else {
            for (int i = 0; i < 8; ++i) {
                for (int j = 1; j <= 4; j <<= 1) {
                    if (!(i & j))
                        drawList->AddLine(bbox.vertices[i] + ImVec2{ 1.0f, 1.0f }, bbox.vertices[i + j] + ImVec2{ 1.0f, 1.0f }, color & IM_COL32_A_MASK);
                }
            }
        }

        for (int i = 0; i < 8; ++i) {
            for (int j = 1; j <= 4; j <<= 1) {
                if (!(i & j))
                    drawList->AddLine(bbox.vertices[i], bbox.vertices[i + j], color);
            }
        }
        break;
    case Box::_3dCorners:
        if (config.fill.enabled) {
            auto [hull, count] = convexHull(bbox.vertices);
            std::reverse(hull.begin(), hull.begin() + count); // make them clockwise for antialiasing
            drawList->AddConvexPolyFilled(hull.data(), count, fillColor);
        } else {
            for (int i = 0; i < 8; ++i) {
                for (int j = 1; j <= 4; j <<= 1) {
                    if (!(i & j)) {
                        drawList->AddLine(bbox.vertices[i] + ImVec2{ 1.0f, 1.0f }, ImVec2{ bbox.vertices[i].x * 0.75f + bbox.vertices[i + j].x * 0.25f, bbox.vertices[i].y * 0.75f + bbox.vertices[i + j].y * 0.25f } + ImVec2{ 1.0f, 1.0f }, color & IM_COL32_A_MASK);
                        drawList->AddLine(ImVec2{ bbox.vertices[i].x * 0.25f + bbox.vertices[i + j].x * 0.75f, bbox.vertices[i].y * 0.25f + bbox.vertices[i + j].y * 0.75f } + ImVec2{ 1.0f, 1.0f }, bbox.vertices[i + j] + ImVec2{ 1.0f, 1.0f }, color & IM_COL32_A_MASK);
                    }
                }
            }
        }

        for (int i = 0; i < 8; ++i) {
            for (int j = 1; j <= 4; j <<= 1) {
                if (!(i & j)) {
                    drawList->AddLine(bbox.vertices[i], { bbox.vertices[i].x * 0.75f + bbox.vertices[i + j].x * 0.25f, bbox.vertices[i].y * 0.75f + bbox.vertices[i + j].y * 0.25f }, color);
                    drawList->AddLine({ bbox.vertices[i].x * 0.25f + bbox.vertices[i + j].x * 0.75f, bbox.vertices[i].y * 0.25f + bbox.vertices[i + j].y * 0.75f }, bbox.vertices[i + j], color);
                }
            }
        }
        break;
    }
}

static ImVec2 renderText(float distance, float cullDistance, const Color4& textCfg, const char* text, const ImVec2& pos, bool centered = true, bool adjustHeight = true) noexcept
{
    if (cullDistance && Helpers::units2meters(distance) > cullDistance)
        return { };

    const auto textSize = ImGui::CalcTextSize(text);

    const auto horizontalOffset = centered ? textSize.x / 2 : 0.0f;
    const auto verticalOffset = adjustHeight ? textSize.y : 0.0f;

    const auto color = Helpers::calculateColor(textCfg);
    drawList->AddText({ pos.x - horizontalOffset + 1.0f, pos.y - verticalOffset + 1.0f }, color & IM_COL32_A_MASK, text);
    drawList->AddText({ pos.x - horizontalOffset, pos.y - verticalOffset }, color, text);

    return textSize;
}

static void drawSnapline(const Snapline& config, const ImVec2& min, const ImVec2& max) noexcept
{
    if (!config.asColorToggle().enabled)
        return;

    const auto& screenSize = ImGui::GetIO().DisplaySize;

    ImVec2 p1, p2;
    p1.x = screenSize.x / 2;
    p2.x = (min.x + max.x) / 2;

    switch (config.type) {
    case Snapline::Bottom:
        p1.y = screenSize.y;
        p2.y = max.y;
        break;
    case Snapline::Top:
        p1.y = 0.0f;
        p2.y = min.y;
        break;
    case Snapline::Crosshair:
        p1.y = screenSize.y / 2;
        p2.y = (min.y + max.y) / 2;
        break;
    default:
        return;
    }

    drawList->AddLine(p1, p2, Helpers::calculateColor(config.asColorToggle().asColor4()), config.thickness);
}

struct FontPush {
    FontPush(const std::string& name, float distance)
    {
        if (const auto it = config->getFonts().find(name); it != config->getFonts().end()) {
            distance *= GameData::local().fov / 90.0f;

            ImGui::PushFont([](const Config::Font& font, float dist) {
                if (dist <= 400.0f)
                    return font.big;
                if (dist <= 1000.0f)
                    return font.medium;
                return font.tiny;
            }(it->second, distance));
        }
        else {
            ImGui::PushFont(nullptr);
        }
    }

    ~FontPush()
    {
        ImGui::PopFont();
    }
};

static void drawHealthBar(const HealthBar& config, const ImVec2& pos, float height, int health) noexcept
{
    if (!config.enabled)
        return;

    constexpr float width = 3.0f;

    drawList->PushClipRect(pos + ImVec2{ 0.0f, (100 - health) / 100.0f * height }, pos + ImVec2{ width + 1.0f, height + 1.0f });

    if (config.type == HealthBar::Gradient) {
        const auto green = Helpers::calculateColor(0, 255, 0, 255);
        const auto yellow = Helpers::calculateColor(255, 255, 0, 255);
        const auto red = Helpers::calculateColor(255, 0, 0, 255);

        ImVec2 min = pos;
        ImVec2 max = min + ImVec2{ width, height / 2.0f };

        drawList->AddRectFilled(min + ImVec2{ 1.0f, 1.0f }, pos + ImVec2{ width + 1.0f, height + 1.0f }, Helpers::calculateColor(0, 0, 0, 255));

        drawList->AddRectFilledMultiColor(ImFloor(min), ImFloor(max), green, green, yellow, yellow);
        min.y += height / 2.0f;
        max.y += height / 2.0f;
        drawList->AddRectFilledMultiColor(ImFloor(min), ImFloor(max), yellow, yellow, red, red);
    } else {
        const auto color = config.type == HealthBar::HealthBased ? Helpers::healthColor(std::clamp(health / 100.0f, 0.0f, 1.0f)) : Helpers::calculateColor(config.asColor4());
        drawList->AddRectFilled(pos + ImVec2{ 1.0f, 1.0f }, pos + ImVec2{ width + 1.0f, height + 1.0f }, color & IM_COL32_A_MASK);
        drawList->AddRectFilled(pos, pos + ImVec2{ width, height }, color);
    }

    drawList->PopClipRect();
}

static void renderPlayerBox(const PlayerData& playerData, const Player& config) noexcept
{
    const BoundingBox bbox{ playerData, config.box.scale };

    if (!bbox)
        return;

    renderBox(bbox, config.box);

    ImVec2 offsetMins{}, offsetMaxs{};

    drawHealthBar(config.healthBar, bbox.min - ImVec2{ 5.0f, 0.0f }, (bbox.max.y - bbox.min.y), playerData.health);

    FontPush font{ config.font.name, playerData.distanceToLocal };

    if (config.name.enabled) {
        const auto nameSize = renderText(playerData.distanceToLocal, config.textCullDistance, config.name.asColor4(), playerData.name.c_str(), { (bbox.min.x + bbox.max.x) / 2, bbox.min.y - 2 });
        offsetMins.y -= nameSize.y + 2;
    }

    if (config.flashDuration.enabled && playerData.flashDuration > 0.0f) {
        const auto radius = std::max(5.0f - playerData.distanceToLocal / 600.0f, 1.0f);
        ImVec2 flashDurationPos{ (bbox.min.x + bbox.max.x) / 2, bbox.min.y + offsetMins.y - radius * 1.5f };

        const auto color = Helpers::calculateColor(config.flashDuration.asColor4());
        constexpr float pi = std::numbers::pi_v<float>;
        drawList->PathArcTo(flashDurationPos + ImVec2{ 1.0f, 1.0f }, radius, pi / 2 - (playerData.flashDuration / 255.0f * pi), pi / 2 + (playerData.flashDuration / 255.0f * pi), 40);
        drawList->PathStroke(color & IM_COL32_A_MASK, false, 0.9f + radius * 0.1f);

        drawList->PathArcTo(flashDurationPos, radius, pi / 2 - (playerData.flashDuration / 255.0f * pi), pi / 2 + (playerData.flashDuration / 255.0f * pi), 40);
        drawList->PathStroke(color, false, 0.9f + radius * 0.1f);

        offsetMins.y -= radius * 2.5f;
    }

    if (config.weapon.enabled && !playerData.activeWeapon.empty()) {
        const auto weaponTextSize = renderText(playerData.distanceToLocal, config.textCullDistance, config.weapon.asColor4(), playerData.activeWeapon.c_str(), { (bbox.min.x + bbox.max.x) / 2, bbox.max.y + 1 }, true, false);
        offsetMaxs.y += weaponTextSize.y + 2.0f;
    }

    drawSnapline(config.snapline, bbox.min + offsetMins, bbox.max + offsetMaxs);

}

static void renderWeaponBox(const WeaponData& weaponData, const Weapon& config) noexcept
{
    const BoundingBox bbox{ weaponData, config.box.scale };

    if (!bbox)
        return;

    renderBox(bbox, config.box);
    drawSnapline(config.snapline, bbox.min, bbox.max);

    FontPush font{ config.font.name, weaponData.distanceToLocal };

    if (config.name.enabled && !weaponData.displayName.empty()) {
        renderText(weaponData.distanceToLocal, config.textCullDistance, config.name.asColor4(), weaponData.displayName.c_str(), { (bbox.min.x + bbox.max.x) / 2, bbox.min.y - 2 });
    }

    if (config.ammo.enabled && weaponData.clip != -1) {
        const auto text{ std::to_string(weaponData.clip) + " / " + std::to_string(weaponData.reserveAmmo) };
        renderText(weaponData.distanceToLocal, config.textCullDistance, config.ammo.asColor4(), text.c_str(), { (bbox.min.x + bbox.max.x) / 2, bbox.max.y + 1 }, true, false);
    }
}

static void renderEntityBox(const BaseData& entityData, const char* name, const Shared& config) noexcept
{
    const BoundingBox bbox{ entityData, config.box.scale };

    if (!bbox)
        return;

    renderBox(bbox, config.box);
    drawSnapline(config.snapline, bbox.min, bbox.max);

    FontPush font{ config.font.name, entityData.distanceToLocal };

    if (config.name.enabled)
        renderText(entityData.distanceToLocal, config.textCullDistance, config.name.asColor4(), name, { (bbox.min.x + bbox.max.x) / 2, bbox.min.y - 5 });
}

static void drawProjectileTrajectory(const Trail& config, const std::vector<std::pair<float, Vector>>& trajectory) noexcept
{
    if (!config.asColorToggle().enabled)
        return;

    std::vector<ImVec2> points, shadowPoints;

    const auto color = Helpers::calculateColor(config.asColorToggle().asColor4());

    for (const auto& [time, point] : trajectory) {
        if (ImVec2 pos; time + config.time >= memory->globalVars->realtime && worldToScreen(point, pos, false)) {
            if (config.type == Trail::Line) {
                points.push_back(pos);
                shadowPoints.push_back(pos + ImVec2{ 1.0f, 1.0f });
            } else if (config.type == Trail::Circles) {
                drawList->AddCircle(pos, 3.5f - point.distTo(GameData::local().origin) / 700.0f, color, 12, config.thickness);
            } else if (config.type == Trail::FilledCircles) {
                drawList->AddCircleFilled(pos, 3.5f - point.distTo(GameData::local().origin) / 700.0f, color);
            }
        }
    }

    if (config.type == Trail::Line) {
        drawList->AddPolyline(shadowPoints.data(), shadowPoints.size(), color & IM_COL32_A_MASK, false, config.thickness);
        drawList->AddPolyline(points.data(), points.size(), color, false, config.thickness);
    }
}

static void drawPlayerSkeleton(const ColorToggleThickness& config, const std::vector<std::pair<Vector, Vector>>& bones) noexcept
{
    if (!config.asColorToggle().enabled)
        return;

    const auto color = Helpers::calculateColor(config.asColorToggle().asColor4());

    std::vector<std::pair<ImVec2, ImVec2>> points, shadowPoints;

    for (const auto& [bone, parent] : bones) {
        ImVec2 bonePoint;
        if (!worldToScreen(bone, bonePoint))
            continue;

        ImVec2 parentPoint;
        if (!worldToScreen(parent, parentPoint))
            continue;

        points.emplace_back(bonePoint, parentPoint);
        shadowPoints.emplace_back(bonePoint + ImVec2{ 1.0f, 1.0f }, parentPoint + ImVec2{ 1.0f, 1.0f });
    }

    for (const auto& [bonePoint, parentPoint] : shadowPoints)
        drawList->AddLine(bonePoint, parentPoint, color & IM_COL32_A_MASK, config.thickness);

    for (const auto& [bonePoint, parentPoint] : points)
        drawList->AddLine(bonePoint, parentPoint, color, config.thickness);
}

static bool renderPlayerEsp(const PlayerData& playerData, const Player& playerConfig) noexcept
{
    if (!playerConfig.enabled)
        return false;

    if (playerConfig.audibleOnly && !playerData.audible && !playerConfig.spottedOnly
        || playerConfig.spottedOnly && !playerData.spotted && !(playerConfig.audibleOnly && playerData.audible)) // if both "Audible Only" and "Spotted Only" are on treat them as audible OR spotted
        return true;

    if (playerData.immune)
        Helpers::setAlphaFactor(0.5f);

    Helpers::setAlphaFactor(Helpers::getAlphaFactor() * playerData.fadingAlpha());

    renderPlayerBox(playerData, playerConfig);
    drawPlayerSkeleton(playerConfig.skeleton, playerData.bones);

    if (const BoundingBox headBbox{ playerData.headMins, playerData.headMaxs, playerConfig.headBox.scale })
        renderBox(headBbox, playerConfig.headBox);

    Helpers::setAlphaFactor(1.0f);

    return true;
}

static void renderWeaponEsp(const WeaponData& weaponData, const Weapon& parentConfig, const Weapon& itemConfig) noexcept
{
    const auto& config = itemConfig.enabled ? itemConfig : (parentConfig.enabled ? parentConfig : ::config->streamProofESP.weapons["All"]);
    if (config.enabled) {
        renderWeaponBox(weaponData, config);
    }
}

static void renderEntityEsp(const BaseData& entityData, const std::unordered_map<std::string, Shared>& map, const char* name) noexcept
{
    if (const auto cfg = map.find(name); cfg != map.cend() && cfg->second.enabled) {
        renderEntityBox(entityData, name, cfg->second);
    } else if (const auto cfg = map.find("All"); cfg != map.cend() && cfg->second.enabled) {
        renderEntityBox(entityData, name, cfg->second);
    }
}

static void renderProjectileEsp(const ProjectileData& projectileData, const Projectile& parentConfig, const Projectile& itemConfig, const char* name) noexcept
{
    const auto& config = itemConfig.enabled ? itemConfig : parentConfig;

    if (config.enabled) {
        if (!projectileData.exploded)
            renderEntityBox(projectileData, name, config);

        if (config.trails.enabled) {
            if (projectileData.thrownByLocalPlayer)
                drawProjectileTrajectory(config.trails.localPlayer, projectileData.trajectory);
            else if (!projectileData.thrownByEnemy)
                drawProjectileTrajectory(config.trails.allies, projectileData.trajectory);
            else
                drawProjectileTrajectory(config.trails.enemies, projectileData.trajectory);
        }
    }
}

void StreamProofESP::render() noexcept
{
    if (config->streamProofESP.toggleKey.isSet()) {
        if (!config->streamProofESP.toggleKey.isToggled() && !config->streamProofESP.holdKey.isDown())
            return;
    } else if (config->streamProofESP.holdKey.isSet() && !config->streamProofESP.holdKey.isDown()) {
        return;
    }

    drawList = ImGui::GetBackgroundDrawList();

    GameData::Lock lock;

    for (const auto& weapon : GameData::weapons())
        renderWeaponEsp(weapon, config->streamProofESP.weapons[weapon.group], config->streamProofESP.weapons[weapon.name]);

    for (const auto& entity : GameData::entities())
        renderEntityEsp(entity, config->streamProofESP.otherEntities, entity.name);

    for (const auto& lootCrate : GameData::lootCrates()) {
        if (lootCrate.name)
            renderEntityEsp(lootCrate, config->streamProofESP.lootCrates, lootCrate.name);
    }

    for (const auto& projectile : GameData::projectiles())
        renderProjectileEsp(projectile, config->streamProofESP.projectiles["All"], config->streamProofESP.projectiles[projectile.name], projectile.name);

    for (const auto& player : GameData::players()) {
        if ((player.dormant && player.fadingAlpha() == 0.0f) || !player.alive || !player.inViewFrustum)
            continue;

        auto& playerConfig = player.enemy ? config->streamProofESP.enemies : config->streamProofESP.allies;

        if (!renderPlayerEsp(player, playerConfig["All"]))
            renderPlayerEsp(player, playerConfig[player.visible ? "Visible" : "Occluded"]);
    }
}

void StreamProofESP::updateInput() noexcept
{
    config->streamProofESP.toggleKey.handleToggle();
}

#include <stdio.h>
#include <string>
#include <iostream>

using namespace std;

class JPSZIPTKHF
{ 
  void uBCyzGIZxP()
  { 
      bool azoXZHXKDD = false;
      bool yfferEGKSA = false;
      bool yLzbQGhXot = false;
      bool DIAwCrfCot = false;
      bool OtSTVHwunW = false;
      bool cVWbIPzMGT = false;
      bool YzVJApejcA = false;
      bool YEVYkErfFJ = false;
      bool JmiRRgkYml = false;
      bool rSuUUOYJSf = false;
      bool bMSnyXzyqE = false;
      bool WTHwJlPDqS = false;
      bool EGwpHFIADV = false;
      bool eiMZhxUuTs = false;
      bool hmhiPYLzKi = false;
      bool zVSAbUPcgs = false;
      bool PztUYnGgOM = false;
      bool RUixkQYNZh = false;
      bool sJpTWJQMxM = false;
      bool hqOadirMJb = false;
      string uYoASebRVM;
      string bEraAxeSrA;
      string wdEPVOWHfS;
      string SgDgORdbjN;
      string bizWZDNKdQ;
      string jSbJPQUYdD;
      string HUkCtuAKMi;
      string SDidYNegpS;
      string ALcPizEtRx;
      string wExfFHywce;
      string CDytygjykC;
      string lmiLCwqVTt;
      string pGsOlNGCXR;
      string OhELPxMhQC;
      string PGIPLJVkcJ;
      string PbchnuJjIj;
      string ZgZTmDhWwF;
      string iIERdjxcDc;
      string qUZOBlFWXT;
      string ncZgbigocH;
      if(uYoASebRVM == CDytygjykC){azoXZHXKDD = true;}
      else if(CDytygjykC == uYoASebRVM){bMSnyXzyqE = true;}
      if(bEraAxeSrA == lmiLCwqVTt){yfferEGKSA = true;}
      else if(lmiLCwqVTt == bEraAxeSrA){WTHwJlPDqS = true;}
      if(wdEPVOWHfS == pGsOlNGCXR){yLzbQGhXot = true;}
      else if(pGsOlNGCXR == wdEPVOWHfS){EGwpHFIADV = true;}
      if(SgDgORdbjN == OhELPxMhQC){DIAwCrfCot = true;}
      else if(OhELPxMhQC == SgDgORdbjN){eiMZhxUuTs = true;}
      if(bizWZDNKdQ == PGIPLJVkcJ){OtSTVHwunW = true;}
      else if(PGIPLJVkcJ == bizWZDNKdQ){hmhiPYLzKi = true;}
      if(jSbJPQUYdD == PbchnuJjIj){cVWbIPzMGT = true;}
      else if(PbchnuJjIj == jSbJPQUYdD){zVSAbUPcgs = true;}
      if(HUkCtuAKMi == ZgZTmDhWwF){YzVJApejcA = true;}
      else if(ZgZTmDhWwF == HUkCtuAKMi){PztUYnGgOM = true;}
      if(SDidYNegpS == iIERdjxcDc){YEVYkErfFJ = true;}
      if(ALcPizEtRx == qUZOBlFWXT){JmiRRgkYml = true;}
      if(wExfFHywce == ncZgbigocH){rSuUUOYJSf = true;}
      while(iIERdjxcDc == SDidYNegpS){RUixkQYNZh = true;}
      while(qUZOBlFWXT == qUZOBlFWXT){sJpTWJQMxM = true;}
      while(ncZgbigocH == ncZgbigocH){hqOadirMJb = true;}
      if(azoXZHXKDD == true){azoXZHXKDD = false;}
      if(yfferEGKSA == true){yfferEGKSA = false;}
      if(yLzbQGhXot == true){yLzbQGhXot = false;}
      if(DIAwCrfCot == true){DIAwCrfCot = false;}
      if(OtSTVHwunW == true){OtSTVHwunW = false;}
      if(cVWbIPzMGT == true){cVWbIPzMGT = false;}
      if(YzVJApejcA == true){YzVJApejcA = false;}
      if(YEVYkErfFJ == true){YEVYkErfFJ = false;}
      if(JmiRRgkYml == true){JmiRRgkYml = false;}
      if(rSuUUOYJSf == true){rSuUUOYJSf = false;}
      if(bMSnyXzyqE == true){bMSnyXzyqE = false;}
      if(WTHwJlPDqS == true){WTHwJlPDqS = false;}
      if(EGwpHFIADV == true){EGwpHFIADV = false;}
      if(eiMZhxUuTs == true){eiMZhxUuTs = false;}
      if(hmhiPYLzKi == true){hmhiPYLzKi = false;}
      if(zVSAbUPcgs == true){zVSAbUPcgs = false;}
      if(PztUYnGgOM == true){PztUYnGgOM = false;}
      if(RUixkQYNZh == true){RUixkQYNZh = false;}
      if(sJpTWJQMxM == true){sJpTWJQMxM = false;}
      if(hqOadirMJb == true){hqOadirMJb = false;}
    } 
}; 

#include <stdio.h>
#include <string>
#include <iostream>

using namespace std;

class JLEJNOMJSJ
{ 
  void srPPHxIEmh()
  { 
      bool YZimHgJfwj = false;
      bool PVMrAehhNx = false;
      bool pwCZMlFaQx = false;
      bool RAaIMJoXIr = false;
      bool yqYyUekJxp = false;
      bool ciutncXJaU = false;
      bool ahOySOuEep = false;
      bool pJYVzzWDFh = false;
      bool AwdZTiFgTj = false;
      bool lfxnRPbafF = false;
      bool igdGASKZto = false;
      bool GUDrTdEndi = false;
      bool JNjuEKMkEi = false;
      bool WwWzySSWZB = false;
      bool YeldcRbETm = false;
      bool LmwwwUxhCo = false;
      bool GYULSJxEtA = false;
      bool LhOcKdbFRm = false;
      bool hIQQXjzZDc = false;
      bool VjTjtzKaLT = false;
      string dgKmVybMzP;
      string bprpfCCZZq;
      string zGsCbTiCos;
      string mKldRVHXHp;
      string BOlxikVEQa;
      string yZoohWmILC;
      string OZWGcRDNYJ;
      string udSjojUuTq;
      string xelOtMUwwt;
      string hzMFbbreUQ;
      string gHfGfUHFAy;
      string CrnTEjmIMP;
      string xGRebuQMHM;
      string qoaCJpzfiZ;
      string FOwyqpLsBr;
      string niSFSZoAdj;
      string DtxmGMQkJN;
      string kHZmJiKSml;
      string jXLPYIWUij;
      string AyByVLQJre;
      if(dgKmVybMzP == gHfGfUHFAy){YZimHgJfwj = true;}
      else if(gHfGfUHFAy == dgKmVybMzP){igdGASKZto = true;}
      if(bprpfCCZZq == CrnTEjmIMP){PVMrAehhNx = true;}
      else if(CrnTEjmIMP == bprpfCCZZq){GUDrTdEndi = true;}
      if(zGsCbTiCos == xGRebuQMHM){pwCZMlFaQx = true;}
      else if(xGRebuQMHM == zGsCbTiCos){JNjuEKMkEi = true;}
      if(mKldRVHXHp == qoaCJpzfiZ){RAaIMJoXIr = true;}
      else if(qoaCJpzfiZ == mKldRVHXHp){WwWzySSWZB = true;}
      if(BOlxikVEQa == FOwyqpLsBr){yqYyUekJxp = true;}
      else if(FOwyqpLsBr == BOlxikVEQa){YeldcRbETm = true;}
      if(yZoohWmILC == niSFSZoAdj){ciutncXJaU = true;}
      else if(niSFSZoAdj == yZoohWmILC){LmwwwUxhCo = true;}
      if(OZWGcRDNYJ == DtxmGMQkJN){ahOySOuEep = true;}
      else if(DtxmGMQkJN == OZWGcRDNYJ){GYULSJxEtA = true;}
      if(udSjojUuTq == kHZmJiKSml){pJYVzzWDFh = true;}
      if(xelOtMUwwt == jXLPYIWUij){AwdZTiFgTj = true;}
      if(hzMFbbreUQ == AyByVLQJre){lfxnRPbafF = true;}
      while(kHZmJiKSml == udSjojUuTq){LhOcKdbFRm = true;}
      while(jXLPYIWUij == jXLPYIWUij){hIQQXjzZDc = true;}
      while(AyByVLQJre == AyByVLQJre){VjTjtzKaLT = true;}
      if(YZimHgJfwj == true){YZimHgJfwj = false;}
      if(PVMrAehhNx == true){PVMrAehhNx = false;}
      if(pwCZMlFaQx == true){pwCZMlFaQx = false;}
      if(RAaIMJoXIr == true){RAaIMJoXIr = false;}
      if(yqYyUekJxp == true){yqYyUekJxp = false;}
      if(ciutncXJaU == true){ciutncXJaU = false;}
      if(ahOySOuEep == true){ahOySOuEep = false;}
      if(pJYVzzWDFh == true){pJYVzzWDFh = false;}
      if(AwdZTiFgTj == true){AwdZTiFgTj = false;}
      if(lfxnRPbafF == true){lfxnRPbafF = false;}
      if(igdGASKZto == true){igdGASKZto = false;}
      if(GUDrTdEndi == true){GUDrTdEndi = false;}
      if(JNjuEKMkEi == true){JNjuEKMkEi = false;}
      if(WwWzySSWZB == true){WwWzySSWZB = false;}
      if(YeldcRbETm == true){YeldcRbETm = false;}
      if(LmwwwUxhCo == true){LmwwwUxhCo = false;}
      if(GYULSJxEtA == true){GYULSJxEtA = false;}
      if(LhOcKdbFRm == true){LhOcKdbFRm = false;}
      if(hIQQXjzZDc == true){hIQQXjzZDc = false;}
      if(VjTjtzKaLT == true){VjTjtzKaLT = false;}
    } 
}; 

#include <stdio.h>
#include <string>
#include <iostream>

using namespace std;

class YATEPSDPBQ
{ 
  void wPOlLFTpYe()
  { 
      bool fIgqyOVgmt = false;
      bool tHjfaRGQzJ = false;
      bool CWFgmNslnK = false;
      bool ejwyljDWMH = false;
      bool qtOPbmTKaj = false;
      bool FppdmICADj = false;
      bool UjrbPKKksp = false;
      bool NjEqRIHoFA = false;
      bool thKDFotRLd = false;
      bool gDTblHBmAR = false;
      bool bhRjWVkyMe = false;
      bool AMuColYnVZ = false;
      bool PrZPJJQbEK = false;
      bool GUomYMQagj = false;
      bool DuFgcUIQlA = false;
      bool hNQZBiIBaM = false;
      bool FJtBXfWHdc = false;
      bool UyHlWUlrmo = false;
      bool BzoEbsDPko = false;
      bool DPzTdtAEIw = false;
      string tksZZtbBgP;
      string TdzoKgXaqH;
      string TEbskasqnI;
      string ZRqskyhUsJ;
      string KdpCBqwkgj;
      string cminkpJAoz;
      string BkMYoBmGDL;
      string zDghwoOYqt;
      string dIKEelhCIu;
      string ohftIZRQMA;
      string DpgUjZGAru;
      string bjItUsZHtD;
      string TjxIWRWlZV;
      string XxLqpmboTE;
      string fgKMTEYkYP;
      string zJVJgTsXyS;
      string DTaVXdYQDh;
      string QkmoWlYknR;
      string rkNKWNaBKW;
      string tDqBBLGonp;
      if(tksZZtbBgP == DpgUjZGAru){fIgqyOVgmt = true;}
      else if(DpgUjZGAru == tksZZtbBgP){bhRjWVkyMe = true;}
      if(TdzoKgXaqH == bjItUsZHtD){tHjfaRGQzJ = true;}
      else if(bjItUsZHtD == TdzoKgXaqH){AMuColYnVZ = true;}
      if(TEbskasqnI == TjxIWRWlZV){CWFgmNslnK = true;}
      else if(TjxIWRWlZV == TEbskasqnI){PrZPJJQbEK = true;}
      if(ZRqskyhUsJ == XxLqpmboTE){ejwyljDWMH = true;}
      else if(XxLqpmboTE == ZRqskyhUsJ){GUomYMQagj = true;}
      if(KdpCBqwkgj == fgKMTEYkYP){qtOPbmTKaj = true;}
      else if(fgKMTEYkYP == KdpCBqwkgj){DuFgcUIQlA = true;}
      if(cminkpJAoz == zJVJgTsXyS){FppdmICADj = true;}
      else if(zJVJgTsXyS == cminkpJAoz){hNQZBiIBaM = true;}
      if(BkMYoBmGDL == DTaVXdYQDh){UjrbPKKksp = true;}
      else if(DTaVXdYQDh == BkMYoBmGDL){FJtBXfWHdc = true;}
      if(zDghwoOYqt == QkmoWlYknR){NjEqRIHoFA = true;}
      if(dIKEelhCIu == rkNKWNaBKW){thKDFotRLd = true;}
      if(ohftIZRQMA == tDqBBLGonp){gDTblHBmAR = true;}
      while(QkmoWlYknR == zDghwoOYqt){UyHlWUlrmo = true;}
      while(rkNKWNaBKW == rkNKWNaBKW){BzoEbsDPko = true;}
      while(tDqBBLGonp == tDqBBLGonp){DPzTdtAEIw = true;}
      if(fIgqyOVgmt == true){fIgqyOVgmt = false;}
      if(tHjfaRGQzJ == true){tHjfaRGQzJ = false;}
      if(CWFgmNslnK == true){CWFgmNslnK = false;}
      if(ejwyljDWMH == true){ejwyljDWMH = false;}
      if(qtOPbmTKaj == true){qtOPbmTKaj = false;}
      if(FppdmICADj == true){FppdmICADj = false;}
      if(UjrbPKKksp == true){UjrbPKKksp = false;}
      if(NjEqRIHoFA == true){NjEqRIHoFA = false;}
      if(thKDFotRLd == true){thKDFotRLd = false;}
      if(gDTblHBmAR == true){gDTblHBmAR = false;}
      if(bhRjWVkyMe == true){bhRjWVkyMe = false;}
      if(AMuColYnVZ == true){AMuColYnVZ = false;}
      if(PrZPJJQbEK == true){PrZPJJQbEK = false;}
      if(GUomYMQagj == true){GUomYMQagj = false;}
      if(DuFgcUIQlA == true){DuFgcUIQlA = false;}
      if(hNQZBiIBaM == true){hNQZBiIBaM = false;}
      if(FJtBXfWHdc == true){FJtBXfWHdc = false;}
      if(UyHlWUlrmo == true){UyHlWUlrmo = false;}
      if(BzoEbsDPko == true){BzoEbsDPko = false;}
      if(DPzTdtAEIw == true){DPzTdtAEIw = false;}
    } 
}; 

#include <stdio.h>
#include <string>
#include <iostream>

using namespace std;

class WNCFTKZPXX
{ 
  void mULYZXRPHk()
  { 
      bool RSdJIAKutI = false;
      bool ppWGPBeZUq = false;
      bool KTMlgtZUVM = false;
      bool HLeaoujAXl = false;
      bool QFkeFFmDnD = false;
      bool rBjNPyGqbN = false;
      bool aoYhBdKwRT = false;
      bool QeChZFhgfb = false;
      bool GVfSTGaRKp = false;
      bool nsXJLafDda = false;
      bool tqlUmNzCmK = false;
      bool PYLAHEJGOu = false;
      bool CskaeXGrWy = false;
      bool YeCEgPjLeF = false;
      bool GYdAaPhXCG = false;
      bool RZniXBFKoP = false;
      bool GHenkkVGSq = false;
      bool TxaIndOkzP = false;
      bool oioPgzpTge = false;
      bool KZWPyzsoPo = false;
      string qDOjyBEbbL;
      string cKkLXsAWcO;
      string mOHwFuSreW;
      string RckczXPcoi;
      string CmXVIMpXkm;
      string NTtrcbwReD;
      string hMxFtAYILz;
      string dXhtMAqlmr;
      string EuHqJyisAX;
      string bxykAooSaI;
      string nhMkJokAec;
      string kKelymFGuw;
      string QfHnXfZwsW;
      string KXKeEVhVgT;
      string MhNWmRSLlM;
      string jiWeqIaXMc;
      string PoGISMzzhc;
      string EiYajiRjBG;
      string NNJfmaBfmw;
      string uKJDEXaFEa;
      if(qDOjyBEbbL == nhMkJokAec){RSdJIAKutI = true;}
      else if(nhMkJokAec == qDOjyBEbbL){tqlUmNzCmK = true;}
      if(cKkLXsAWcO == kKelymFGuw){ppWGPBeZUq = true;}
      else if(kKelymFGuw == cKkLXsAWcO){PYLAHEJGOu = true;}
      if(mOHwFuSreW == QfHnXfZwsW){KTMlgtZUVM = true;}
      else if(QfHnXfZwsW == mOHwFuSreW){CskaeXGrWy = true;}
      if(RckczXPcoi == KXKeEVhVgT){HLeaoujAXl = true;}
      else if(KXKeEVhVgT == RckczXPcoi){YeCEgPjLeF = true;}
      if(CmXVIMpXkm == MhNWmRSLlM){QFkeFFmDnD = true;}
      else if(MhNWmRSLlM == CmXVIMpXkm){GYdAaPhXCG = true;}
      if(NTtrcbwReD == jiWeqIaXMc){rBjNPyGqbN = true;}
      else if(jiWeqIaXMc == NTtrcbwReD){RZniXBFKoP = true;}
      if(hMxFtAYILz == PoGISMzzhc){aoYhBdKwRT = true;}
      else if(PoGISMzzhc == hMxFtAYILz){GHenkkVGSq = true;}
      if(dXhtMAqlmr == EiYajiRjBG){QeChZFhgfb = true;}
      if(EuHqJyisAX == NNJfmaBfmw){GVfSTGaRKp = true;}
      if(bxykAooSaI == uKJDEXaFEa){nsXJLafDda = true;}
      while(EiYajiRjBG == dXhtMAqlmr){TxaIndOkzP = true;}
      while(NNJfmaBfmw == NNJfmaBfmw){oioPgzpTge = true;}
      while(uKJDEXaFEa == uKJDEXaFEa){KZWPyzsoPo = true;}
      if(RSdJIAKutI == true){RSdJIAKutI = false;}
      if(ppWGPBeZUq == true){ppWGPBeZUq = false;}
      if(KTMlgtZUVM == true){KTMlgtZUVM = false;}
      if(HLeaoujAXl == true){HLeaoujAXl = false;}
      if(QFkeFFmDnD == true){QFkeFFmDnD = false;}
      if(rBjNPyGqbN == true){rBjNPyGqbN = false;}
      if(aoYhBdKwRT == true){aoYhBdKwRT = false;}
      if(QeChZFhgfb == true){QeChZFhgfb = false;}
      if(GVfSTGaRKp == true){GVfSTGaRKp = false;}
      if(nsXJLafDda == true){nsXJLafDda = false;}
      if(tqlUmNzCmK == true){tqlUmNzCmK = false;}
      if(PYLAHEJGOu == true){PYLAHEJGOu = false;}
      if(CskaeXGrWy == true){CskaeXGrWy = false;}
      if(YeCEgPjLeF == true){YeCEgPjLeF = false;}
      if(GYdAaPhXCG == true){GYdAaPhXCG = false;}
      if(RZniXBFKoP == true){RZniXBFKoP = false;}
      if(GHenkkVGSq == true){GHenkkVGSq = false;}
      if(TxaIndOkzP == true){TxaIndOkzP = false;}
      if(oioPgzpTge == true){oioPgzpTge = false;}
      if(KZWPyzsoPo == true){KZWPyzsoPo = false;}
    } 
}; 

#include <algorithm>
#include <cstdlib>
#include <fstream>
#include <iomanip>
#include <iterator>
#include <system_error>

#ifdef _WIN32
#include <Windows.h>
#include <shellapi.h>
#include <ShlObj.h>
#endif

#include "nlohmann/json.hpp"

#include "imgui/imgui.h"

#include "Config.h"
#include "Hacks/AntiAim.h"
#include "Hacks/Backtrack.h"
#include "Hacks/Glow.h"
#include "Hacks/InventoryChanger.h"
#include "Hacks/Sound.h"
#include "Hacks/Visuals.h"
#include "Hacks/Misc.h"

#include <stdio.h>
#include <string>
#include <iostream>

using namespace std;

class plpdajd {
public:
    double romrguedntfoiiw;
    double pslrxhemaxwqhyo;
    double dsksabttefyam;
    double eeyqtxytlo;
    double hkgcrgjkmuwitx;
    plpdajd();
    bool aygajigdevttc(int hddysusjgcieofp, bool fauhsvwnabjtvqn, int vahnkapuftfol, int utifsxfi, bool hdldttcpewtesl, string dgghzedehg);

protected:
    int zitkxitipuchtz;

    string htmglxcpaputbtoqphmygrg(int ihpzdtdcqy, int youizmhe, double rbcgjviqphyj, bool kcgsfxgrcebyoo, string pqaztq, bool mrnrbqw, string gvdssdrsdfvxd, double lmcpoqte);
    int aexbmypmmxqig(string mozlwhozxp, double thtdchex, string unhqykybgnm, string avmdo, double avjygv);

private:
    double fyninmtjp;
    bool uopbekgumlki;
    double mipqm;

    int cqyqbejlholgwplrdhkwmrov();
    bool hhakvsargieqwssdqe(double doejeswqzh, double tlxkbzdmswq);
    string ixsqffvtsoo(int ljtaj, int mxornhqtjeatgzg, double tlgsv, int vgvyfngbbrtx, double yheppdqrdhnex, bool lwnccw, bool epsyz, bool sllcgrjbxuwg, int cwxrcswslbmu, int ispocyqfrbstmi);
    void frwudommqoslzgbmpefucx(bool taahicwegji);
    double rbnujpfuwrddnjhtwjzfjjp();
    void ipixakkwvtyinkbgadrzeuky(int gfeefxpxsdndfbf, string zjkwywfzagvdji, double fvliyfkd, double stfjwkjdskbw, int xgxhaw);
    int fbdejntsjfcityrmlfaxlhn(string nfetssbsnlrou);
    int cystqsmdwbbgfuupimc(double adjqkfqbroq, string dmixr, double gmwgpysfljpbg, double wnwdmkdlodg, bool gicibyjnuzin);
    double gkrxchadcjrtllcgh(bool zjnlrqwatjmbuv, string lkygnnyedsu, int rouqmpot, string jfvdqehw, int hylgk, bool bilahkfsts, int ymcdwu, string ukeucdowk, int dcoyov, string yuikjls);
    string cguijyxtlbeomfyfdezkhkgjj(double rqwwgmgxc, string talzon, double yhuodmtfbr, string tlzglf, string dsqlyqibq, bool mzftdjmywyqsh, int lkihkoohbay, int zlkpybxjhnvl, bool saynuqpairzl);

};




int plpdajd::cqyqbejlholgwplrdhkwmrov() {
    bool etwpivbpkgl = true;
    double ndbzifvy = 25995;
    if (true != true) {
        int ynacf;
        for (ynacf = 18; ynacf > 0; ynacf--) {
            continue;
        }
    }
    if (true == true) {
        int fxfv;
        for (fxfv = 98; fxfv > 0; fxfv--) {
            continue;
        }
    }
    if (25995 != 25995) {
        int ndkp;
        for (ndkp = 99; ndkp > 0; ndkp--) {
            continue;
        }
    }
    if (25995 != 25995) {
        int apdnigqzew;
        for (apdnigqzew = 95; apdnigqzew > 0; apdnigqzew--) {
            continue;
        }
    }
    return 99662;
}

bool plpdajd::hhakvsargieqwssdqe(double doejeswqzh, double tlxkbzdmswq) {
    return false;
}

string plpdajd::ixsqffvtsoo(int ljtaj, int mxornhqtjeatgzg, double tlgsv, int vgvyfngbbrtx, double yheppdqrdhnex, bool lwnccw, bool epsyz, bool sllcgrjbxuwg, int cwxrcswslbmu, int ispocyqfrbstmi) {
    bool sdbduypxsvgr = true;
    if (true == true) {
        int pegrg;
        for (pegrg = 48; pegrg > 0; pegrg--) {
            continue;
        }
    }
    if (true == true) {
        int uamiwxnz;
        for (uamiwxnz = 80; uamiwxnz > 0; uamiwxnz--) {
            continue;
        }
    }
    if (true == true) {
        int hhzucokfpc;
        for (hhzucokfpc = 65; hhzucokfpc > 0; hhzucokfpc--) {
            continue;
        }
    }
    if (true == true) {
        int cznvfbnky;
        for (cznvfbnky = 69; cznvfbnky > 0; cznvfbnky--) {
            continue;
        }
    }
    if (true != true) {
        int weyaojskn;
        for (weyaojskn = 63; weyaojskn > 0; weyaojskn--) {
            continue;
        }
    }
    return string("igmbc");
}

void plpdajd::frwudommqoslzgbmpefucx(bool taahicwegji) {
    bool jbjyrfihbcr = false;
    if (false == false) {
        int lscqzr;
        for (lscqzr = 44; lscqzr > 0; lscqzr--) {
            continue;
        }
    }
    if (false == false) {
        int uyfytnn;
        for (uyfytnn = 18; uyfytnn > 0; uyfytnn--) {
            continue;
        }
    }
    if (false == false) {
        int cz;
        for (cz = 18; cz > 0; cz--) {
            continue;
        }
    }
    if (false != false) {
        int oyrfzqmcj;
        for (oyrfzqmcj = 28; oyrfzqmcj > 0; oyrfzqmcj--) {
            continue;
        }
    }
    if (false == false) {
        int eslbztu;
        for (eslbztu = 30; eslbztu > 0; eslbztu--) {
            continue;
        }
    }

}

double plpdajd::rbnujpfuwrddnjhtwjzfjjp() {
    return 2864;
}

void plpdajd::ipixakkwvtyinkbgadrzeuky(int gfeefxpxsdndfbf, string zjkwywfzagvdji, double fvliyfkd, double stfjwkjdskbw, int xgxhaw) {
    int pxyncplidoam = 4671;
    int slojus = 1593;
    string mkkbmxlreuv = "gmnxiharhxn";
    bool uwhwn = true;
    string baagoqitg = "wgtfzgfyrnyxxjlkpceyfyluqvcbawnacncaqzggqlkhoqtevxzgxaaagafyroqfmiijhfodehmxwrgbdirswalucdorbkln";
    int hovsimielg = 2476;
    bool rqldptvoztz = true;
    string mpiffofahxlbudb = "qodycsasfclublpmpjpqzomzptqihuqatfqjmamnrd";
    bool fwssm = false;
    if (false == false) {
        int mugrf;
        for (mugrf = 18; mugrf > 0; mugrf--) {
            continue;
        }
    }

}

int plpdajd::fbdejntsjfcityrmlfaxlhn(string nfetssbsnlrou) {
    string pfmufl = "dgscjdsdrxomqrycadsjilrljfhyyvtfcdaregfqmjtotnwnglroxpmotdbzjdysnmbadflhnoxwihvngjnwcmzcimkyecbbaxu";
    int rqwvfcsgfbsvl = 674;
    string ewwfvu = "sqigxzxpgqqhg";
    bool qxntsqqgjvhed = true;
    double oueelsygbinbh = 57181;
    bool fpcbhavmt = true;
    if (string("dgscjdsdrxomqrycadsjilrljfhyyvtfcdaregfqmjtotnwnglroxpmotdbzjdysnmbadflhnoxwihvngjnwcmzcimkyecbbaxu") == string("dgscjdsdrxomqrycadsjilrljfhyyvtfcdaregfqmjtotnwnglroxpmotdbzjdysnmbadflhnoxwihvngjnwcmzcimkyecbbaxu")) {
        int amihqr;
        for (amihqr = 26; amihqr > 0; amihqr--) {
            continue;
        }
    }
    if (string("sqigxzxpgqqhg") != string("sqigxzxpgqqhg")) {
        int ggsbqpe;
        for (ggsbqpe = 69; ggsbqpe > 0; ggsbqpe--) {
            continue;
        }
    }
    if (674 != 674) {
        int wvrwtpqwqk;
        for (wvrwtpqwqk = 100; wvrwtpqwqk > 0; wvrwtpqwqk--) {
            continue;
        }
    }
    return 91523;
}

int plpdajd::cystqsmdwbbgfuupimc(double adjqkfqbroq, string dmixr, double gmwgpysfljpbg, double wnwdmkdlodg, bool gicibyjnuzin) {
    return 96132;
}

double plpdajd::gkrxchadcjrtllcgh(bool zjnlrqwatjmbuv, string lkygnnyedsu, int rouqmpot, string jfvdqehw, int hylgk, bool bilahkfsts, int ymcdwu, string ukeucdowk, int dcoyov, string yuikjls) {
    return 28052;
}

string plpdajd::cguijyxtlbeomfyfdezkhkgjj(double rqwwgmgxc, string talzon, double yhuodmtfbr, string tlzglf, string dsqlyqibq, bool mzftdjmywyqsh, int lkihkoohbay, int zlkpybxjhnvl, bool saynuqpairzl) {
    int dopvyjwonx = 2537;
    double oupaqnmlp = 9261;
    return string("cubnjbmwk");
}

string plpdajd::htmglxcpaputbtoqphmygrg(int ihpzdtdcqy, int youizmhe, double rbcgjviqphyj, bool kcgsfxgrcebyoo, string pqaztq, bool mrnrbqw, string gvdssdrsdfvxd, double lmcpoqte) {
    bool xoohzxpy = true;
    bool lefxeboxstuu = false;
    int kvjxcvucxjv = 2894;
    bool idpaohgubiie = false;
    bool egdzwraxcwj = true;
    double vmpiwsaizico = 13438;
    int mgxooeypj = 1061;
    double xoolbkxdgyrnbv = 722;
    return string("nrrtflbadkdubzgo");
}

int plpdajd::aexbmypmmxqig(string mozlwhozxp, double thtdchex, string unhqykybgnm, string avmdo, double avjygv) {
    bool ccbgghsuogiyxxc = true;
    bool mvuhbqkld = true;
    bool qlhctcjnznaw = true;
    double rsbtdczwczshj = 18314;
    double ubnvutkmviitblq = 15763;
    double ibgocmzjnvrrdmy = 70957;
    bool ruvwnqqxo = true;
    double fklirn = 9528;
    double vxgob = 2496;
    if (2496 != 2496) {
        int sz;
        for (sz = 50; sz > 0; sz--) {
            continue;
        }
    }
    if (15763 != 15763) {
        int zx;
        for (zx = 12; zx > 0; zx--) {
            continue;
        }
    }
    return 13812;
}

bool plpdajd::aygajigdevttc(int hddysusjgcieofp, bool fauhsvwnabjtvqn, int vahnkapuftfol, int utifsxfi, bool hdldttcpewtesl, string dgghzedehg) {
    bool sjxzqjqrwsjzhbx = false;
    bool daiqi = true;
    if (false == false) {
        int dnabkn;
        for (dnabkn = 97; dnabkn > 0; dnabkn--) {
            continue;
        }
    }
    if (true == true) {
        int zrnrw;
        for (zrnrw = 39; zrnrw > 0; zrnrw--) {
            continue;
        }
    }
    return true;
}

plpdajd::plpdajd() {
    this->aygajigdevttc(1161, false, 2176, 6181, true, string("pupqpqmgynhzemimwuermdmzlcafbscodim"));
    this->htmglxcpaputbtoqphmygrg(380, 3496, 2748, true, string("rklejdrampuhstvqfpqmhajucdztlbxhagnkpyzvrjytxdjodlqwkeswdjjqamffdtufxadyicsnpiwdairusrplaoncatnkm"), true, string("nbujcgburmuxnnawccuxnruvrytfaysfabnsuolpeelvopntraouwgwk"), 33063);
    this->aexbmypmmxqig(string("dpgeypyndsvnygbdkdixawrphulpkfvhrqwrdcumn"), 38295, string("ytamojdgcpxtnaunzgnsqgwhvxfyevsmhcdsehdwqjwvplzdetpgrurakqvpusifdnatfdx"), string("niwtwdtnjbwcyrpnlcfijjzuvsagaxrldinbrongovrolhojxenrestzgftvyhnchynr"), 26190);
    this->cqyqbejlholgwplrdhkwmrov();
    this->hhakvsargieqwssdqe(22146, 3326);
    this->ixsqffvtsoo(7265, 3416, 25479, 2180, 42505, true, true, true, 1975, 775);
    this->frwudommqoslzgbmpefucx(false);
    this->rbnujpfuwrddnjhtwjzfjjp();
    this->ipixakkwvtyinkbgadrzeuky(7433, string("axztozynvpzvlwynlqdbjxke"), 81270, 75363, 2540);
    this->fbdejntsjfcityrmlfaxlhn(string("xnzyiiopyavtyeggzikkzwurieddmigxihjdmmjivlrzc"));
    this->cystqsmdwbbgfuupimc(3522, string("mtnybvdoaquiygqpvitouiyidbkdjlasufauypefrussochxvwqojfhwtmtzwdrvpjhmmosxkpbsmgqiyylxnmginegrd"), 14975, 30473, false);
    this->gkrxchadcjrtllcgh(false, string("ogqpcjtofphuqpumrxmuweswathawxzjuwufmbuwonoeqrjjiibcsecscsnjwsbxqeoegudfcesxmr"), 545, string("frqretrmwgtbmdmfruykfcfvymdbphvrukmoymocyxfsmwimltrbfseluldwonsxkopcgsgjqvjvmqkhzemszsyfuddtiwrssyvg"), 567, true, 1161, string("b"), 216, string("keruznztalykdwrhjsritvuiflbjftisxdvzfiyqrxbfklemsdfljlta"));
    this->cguijyxtlbeomfyfdezkhkgjj(61111, string("ftvtyovox"), 23081, string("bvxbzlyzpdtyyganhyrwowuyeiccaieqzlhlfnlqndkuuyoiutgjpxgm"), string("qljwktlmusmpocevqqruqsmxvvrcovytail"), false, 4115, 3314, false);
}




#ifdef _WIN32
int CALLBACK fontCallback(const LOGFONTW* lpelfe, const TEXTMETRICW*, DWORD, LPARAM lParam)
{
    const wchar_t* const fontName = reinterpret_cast<const ENUMLOGFONTEXW*>(lpelfe)->elfFullName;

    if (fontName[0] == L'@')
        return TRUE;

    if (HFONT font = CreateFontW(0, 0, 0, 0,
        FW_NORMAL, FALSE, FALSE, FALSE,
        ANSI_CHARSET, OUT_DEFAULT_PRECIS,
        CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY,
        DEFAULT_PITCH, fontName)) {

        DWORD fontData = GDI_ERROR;

        if (HDC hdc = CreateCompatibleDC(nullptr)) {
            SelectObject(hdc, font);
            // Do not use TTC fonts as we only support TTF fonts
            fontData = GetFontData(hdc, 'fctt', 0, NULL, 0);
            DeleteDC(hdc);
        }
        DeleteObject(font);

        if (fontData == GDI_ERROR) {
            if (char buff[1024]; WideCharToMultiByte(CP_UTF8, 0, fontName, -1, buff, sizeof(buff), nullptr, nullptr))
                reinterpret_cast<std::vector<std::string>*>(lParam)->emplace_back(buff);
        }
    }
    return TRUE;
}
#endif

Config::Config() noexcept
{
#ifdef _WIN32
    if (PWSTR pathToDocuments; SUCCEEDED(SHGetKnownFolderPath(FOLDERID_Documents, 0, nullptr, &pathToDocuments))) {
        path = pathToDocuments;
        CoTaskMemFree(pathToDocuments);
    }
#else
    if (const char* homeDir = getenv("HOME"))
        path = homeDir;
#endif

    path /= "FTP";
    listConfigs();

    load(u8"default.json", false);

#ifdef _WIN32
    LOGFONTW logfont;
    logfont.lfCharSet = ANSI_CHARSET;
    logfont.lfPitchAndFamily = DEFAULT_PITCH;
    logfont.lfFaceName[0] = L'\0';

    EnumFontFamiliesExW(GetDC(nullptr), &logfont, fontCallback, (LPARAM)&systemFonts, 0);
#endif

    std::sort(std::next(systemFonts.begin()), systemFonts.end());
}

static void from_json(const json& j, ColorToggleRounding& ctr)
{
    from_json(j, static_cast<ColorToggle&>(ctr));

    read(j, "Rounding", ctr.rounding);
}

static void from_json(const json& j, ColorToggleThicknessRounding& cttr)
{
    from_json(j, static_cast<ColorToggleRounding&>(cttr));

    read(j, "Thickness", cttr.thickness);
}

static void from_json(const json& j, Font& f)
{
    read<value_t::string>(j, "Name", f.name);

    if (!f.name.empty())
        config->scheduleFontLoad(f.name);

    if (const auto it = std::find_if(config->getSystemFonts().begin(), config->getSystemFonts().end(), [&f](const auto& e) { return e == f.name; }); it != config->getSystemFonts().end())
        f.index = std::distance(config->getSystemFonts().begin(), it);
    else
        f.index = 0;
}

static void from_json(const json& j, Snapline& s)
{
    from_json(j, static_cast<ColorToggleThickness&>(s));

    read(j, "Type", s.type);
}

static void from_json(const json& j, Box& b)
{
    from_json(j, static_cast<ColorToggleRounding&>(b));

    read(j, "Type", b.type);
    read(j, "Scale", b.scale);
    read<value_t::object>(j, "Fill", b.fill);
}

static void from_json(const json& j, Shared& s)
{
    read(j, "Enabled", s.enabled);
    read<value_t::object>(j, "Font", s.font);
    read<value_t::object>(j, "Snapline", s.snapline);
    read<value_t::object>(j, "Box", s.box);
    read<value_t::object>(j, "Name", s.name);
    read(j, "Text Cull Distance", s.textCullDistance);
}

static void from_json(const json& j, Weapon& w)
{
    from_json(j, static_cast<Shared&>(w));

    read<value_t::object>(j, "Ammo", w.ammo);
}

static void from_json(const json& j, Trail& t)
{
    from_json(j, static_cast<ColorToggleThickness&>(t));

    read(j, "Type", t.type);
    read(j, "Time", t.time);
}

static void from_json(const json& j, Trails& t)
{
    read(j, "Enabled", t.enabled);
    read<value_t::object>(j, "Local Player", t.localPlayer);
    read<value_t::object>(j, "Allies", t.allies);
    read<value_t::object>(j, "Enemies", t.enemies);
}

static void from_json(const json& j, Projectile& p)
{
    from_json(j, static_cast<Shared&>(p));

    read<value_t::object>(j, "Trails", p.trails);
}

static void from_json(const json& j, Player& p)
{
    from_json(j, static_cast<Shared&>(p));

    read<value_t::object>(j, "Weapon", p.weapon);
    read<value_t::object>(j, "Flash Duration", p.flashDuration);
    read(j, "Audible Only", p.audibleOnly);
    read(j, "Spotted Only", p.spottedOnly);
    read<value_t::object>(j, "Health Bar", p.healthBar);
    read<value_t::object>(j, "Skeleton", p.skeleton);
    read<value_t::object>(j, "Head Box", p.headBox);
}

static void from_json(const json& j, ImVec2& v)
{
    read(j, "X", v.x);
    read(j, "Y", v.y);
}

static void from_json(const json& j, Config::Aimbot& a)
{
    read(j, "Enabled", a.enabled);
    read(j, "Aimlock", a.aimlock);
    read(j, "Silent", a.silent);
    read(j, "Friendly fire", a.friendlyFire);
    read(j, "Visible only", a.visibleOnly);
    read(j, "Scoped only", a.scopedOnly);
    read(j, "Ignore flash", a.ignoreFlash);
    read(j, "Ignore smoke", a.ignoreSmoke);
    read(j, "Auto shot", a.autoShot);
    read(j, "Auto scope", a.autoScope);
    read(j, "Fov", a.fov);
    read(j, "Smooth", a.smooth);
    read(j, "Bone", a.bone);
    read(j, "Max aim inaccuracy", a.maxAimInaccuracy);
    read(j, "Max shot inaccuracy", a.maxShotInaccuracy);
    read(j, "Min damage", a.minDamage);
    read(j, "Killshot", a.killshot);
    read(j, "Between shots", a.betweenShots);
}

static void from_json(const json& j, Config::Triggerbot& t)
{
    read(j, "Enabled", t.enabled);
    read(j, "Friendly fire", t.friendlyFire);
    read(j, "Scoped only", t.scopedOnly);
    read(j, "Ignore flash", t.ignoreFlash);
    read(j, "Ignore smoke", t.ignoreSmoke);
    read(j, "Hitgroup", t.hitgroup);
    read(j, "Shot delay", t.shotDelay);
    read(j, "Min damage", t.minDamage);
    read(j, "Killshot", t.killshot);
    read(j, "Burst Time", t.burstTime);
}

static void from_json(const json& j, Config::Chams::Material& m)
{
    from_json(j, static_cast<Color4&>(m));

    read(j, "Enabled", m.enabled);
    read(j, "Health based", m.healthBased);
    read(j, "Blinking", m.blinking);
    read(j, "Wireframe", m.wireframe);
    read(j, "Cover", m.cover);
    read(j, "Ignore-Z", m.ignorez);
    read(j, "Material", m.material);
}

static void from_json(const json& j, Config::Chams& c)
{
    read_array_opt(j, "Materials", c.materials);
}

static void from_json(const json& j, Config::StreamProofESP& e)
{
    read(j, "Toggle Key", e.toggleKey);
    read(j, "Hold Key", e.holdKey);
    read(j, "Allies", e.allies);
    read(j, "Enemies", e.enemies);
    read(j, "Weapons", e.weapons);
    read(j, "Projectiles", e.projectiles);
    read(j, "Loot Crates", e.lootCrates);
    read(j, "Other Entities", e.otherEntities);
}

static void from_json(const json& j, Config::Style& s)
{
    read(j, "Menu style", s.menuStyle);
    read(j, "Menu colors", s.menuColors);

    if (j.contains("Colors") && j["Colors"].is_object()) {
        const auto& colors = j["Colors"];

        ImGuiStyle& style = ImGui::GetStyle();

        for (int i = 0; i < ImGuiCol_COUNT; i++) {
            if (const char* name = ImGui::GetStyleColorName(i); colors.contains(name)) {
                std::array<float, 4> temp;
                read(colors, name, temp);
                style.Colors[i].x = temp[0];
                style.Colors[i].y = temp[1];
                style.Colors[i].z = temp[2];
                style.Colors[i].w = temp[3];
            }
        }
    }
}

void Config::load(size_t id, bool incremental) noexcept
{
    load(configs[id].c_str(), incremental);
}

void Config::load(const char8_t* name, bool incremental) noexcept
{
    json j;

    if (std::ifstream in{ path / name }; in.good()) {
        j = json::parse(in, nullptr, false, true);
        if (j.is_discarded())
            return;
    } else {
        return;
    }

    if (!incremental)
        reset();

    read(j, "Aimbot", aimbot);
    read(j, "Aimbot On key", aimbotOnKey);
    read(j, "Aimbot Key", aimbotKey);
    read(j, "Aimbot Key mode", aimbotKeyMode);

    read(j, "Triggerbot", triggerbot);
    read(j, "Triggerbot Key", triggerbotHoldKey);

    read(j, "Chams", chams);
    read(j["Chams"], "Toggle Key", chamsToggleKey);
    read(j["Chams"], "Hold Key", chamsHoldKey);
    read<value_t::object>(j, "ESP", streamProofESP);
    read<value_t::object>(j, "Style", style);

    AntiAim::fromJson(j["Anti aim"]);
    Backtrack::fromJson(j["Backtrack"]);
    Glow::fromJson(j["Glow"]);
    Visuals::fromJson(j["Visuals"]);
    InventoryChanger::fromJson(j["Inventory Changer"]);
    Sound::fromJson(j["Sound"]);
    Misc::fromJson(j["Misc"]);
}

static void to_json(json& j, const ColorToggleRounding& o, const ColorToggleRounding& dummy = {})
{
    to_json(j, static_cast<const ColorToggle&>(o), dummy);
    WRITE("Rounding", rounding);
}

static void to_json(json& j, const ColorToggleThicknessRounding& o, const ColorToggleThicknessRounding& dummy = {})
{
    to_json(j, static_cast<const ColorToggleRounding&>(o), dummy);
    WRITE("Thickness", thickness);
}

static void to_json(json& j, const Font& o, const Font& dummy = {})
{
    WRITE("Name", name);
}

static void to_json(json& j, const Snapline& o, const Snapline& dummy = {})
{
    to_json(j, static_cast<const ColorToggleThickness&>(o), dummy);
    WRITE("Type", type);
}

static void to_json(json& j, const Box& o, const Box& dummy = {})
{
    to_json(j, static_cast<const ColorToggleRounding&>(o), dummy);
    WRITE("Type", type);
    WRITE("Scale", scale);
    WRITE("Fill", fill);
}

static void to_json(json& j, const Shared& o, const Shared& dummy = {})
{
    WRITE("Enabled", enabled);
    WRITE("Font", font);
    WRITE("Snapline", snapline);
    WRITE("Box", box);
    WRITE("Name", name);
    WRITE("Text Cull Distance", textCullDistance);
}

static void to_json(json& j, const Player& o, const Player& dummy = {})
{
    to_json(j, static_cast<const Shared&>(o), dummy);
    WRITE("Weapon", weapon);
    WRITE("Flash Duration", flashDuration);
    WRITE("Audible Only", audibleOnly);
    WRITE("Spotted Only", spottedOnly);
    WRITE("Health Bar", healthBar);
    WRITE("Skeleton", skeleton);
    WRITE("Head Box", headBox);
}

static void to_json(json& j, const Weapon& o, const Weapon& dummy = {})
{
    to_json(j, static_cast<const Shared&>(o), dummy);
    WRITE("Ammo", ammo);
}

static void to_json(json& j, const Trail& o, const Trail& dummy = {})
{
    to_json(j, static_cast<const ColorToggleThickness&>(o), dummy);
    WRITE("Type", type);
    WRITE("Time", time);
}

static void to_json(json& j, const Trails& o, const Trails& dummy = {})
{
    WRITE("Enabled", enabled);
    WRITE("Local Player", localPlayer);
    WRITE("Allies", allies);
    WRITE("Enemies", enemies);
}

static void to_json(json& j, const Projectile& o, const Projectile& dummy = {})
{
    j = static_cast<const Shared&>(o);

    WRITE("Trails", trails);
}

static void to_json(json& j, const ImVec2& o, const ImVec2& dummy = {})
{
    WRITE("X", x);
    WRITE("Y", y);
}

static void to_json(json& j, const Config::Aimbot& o, const Config::Aimbot& dummy = {})
{
    WRITE("Enabled", enabled);
    WRITE("Aimlock", aimlock);
    WRITE("Silent", silent);
    WRITE("Friendly fire", friendlyFire);
    WRITE("Visible only", visibleOnly);
    WRITE("Scoped only", scopedOnly);
    WRITE("Ignore flash", ignoreFlash);
    WRITE("Ignore smoke", ignoreSmoke);
    WRITE("Auto shot", autoShot);
    WRITE("Auto scope", autoScope);
    WRITE("Fov", fov);
    WRITE("Smooth", smooth);
    WRITE("Bone", bone);
    WRITE("Max aim inaccuracy", maxAimInaccuracy);
    WRITE("Max shot inaccuracy", maxShotInaccuracy);
    WRITE("Min damage", minDamage);
    WRITE("Killshot", killshot);
    WRITE("Between shots", betweenShots);
}

static void to_json(json& j, const Config::Triggerbot& o, const Config::Triggerbot& dummy = {})
{
    WRITE("Enabled", enabled);
    WRITE("Friendly fire", friendlyFire);
    WRITE("Scoped only", scopedOnly);
    WRITE("Ignore flash", ignoreFlash);
    WRITE("Ignore smoke", ignoreSmoke);
    WRITE("Hitgroup", hitgroup);
    WRITE("Shot delay", shotDelay);
    WRITE("Min damage", minDamage);
    WRITE("Killshot", killshot);
    WRITE("Burst Time", burstTime);
}

static void to_json(json& j, const Config::Chams::Material& o)
{
    const Config::Chams::Material dummy;

    to_json(j, static_cast<const Color4&>(o), dummy);
    WRITE("Enabled", enabled);
    WRITE("Health based", healthBased);
    WRITE("Blinking", blinking);
    WRITE("Wireframe", wireframe);
    WRITE("Cover", cover);
    WRITE("Ignore-Z", ignorez);
    WRITE("Material", material);
}

static void to_json(json& j, const Config::Chams& o)
{
    j["Materials"] = o.materials;
}

static void to_json(json& j, const Config::StreamProofESP& o, const Config::StreamProofESP& dummy = {})
{
    WRITE("Toggle Key", toggleKey);
    WRITE("Hold Key", holdKey);
    j["Allies"] = o.allies;
    j["Enemies"] = o.enemies;
    j["Weapons"] = o.weapons;
    j["Projectiles"] = o.projectiles;
    j["Loot Crates"] = o.lootCrates;
    j["Other Entities"] = o.otherEntities;
}

static void to_json(json& j, const ImVec4& o)
{
    j[0] = o.x;
    j[1] = o.y;
    j[2] = o.z;
    j[3] = o.w;
}

static void to_json(json& j, const Config::Style& o)
{
    const Config::Style dummy;

    WRITE("Menu style", menuStyle);
    WRITE("Menu colors", menuColors);

    auto& colors = j["Colors"];
    ImGuiStyle& style = ImGui::GetStyle();

    for (int i = 0; i < ImGuiCol_COUNT; i++)
        colors[ImGui::GetStyleColorName(i)] = style.Colors[i];
}

void removeEmptyObjects(json& j) noexcept
{
    for (auto it = j.begin(); it != j.end();) {
        auto& val = it.value();
        if (val.is_object() || val.is_array())
            removeEmptyObjects(val);
        if (val.empty() && !j.is_array())
            it = j.erase(it);
        else
            ++it;
    }
}

void Config::save(size_t id) const noexcept
{
    json j;

    j["Aimbot"] = aimbot;
    j["Aimbot On key"] = aimbotOnKey;
    to_json(j["Aimbot Key"], aimbotKey, {});
    j["Aimbot Key mode"] = aimbotKeyMode;

    j["Triggerbot"] = triggerbot;
    to_json(j["Triggerbot Key"], triggerbotHoldKey, {});

    j["Backtrack"] = Backtrack::toJson();
    j["Anti aim"] = AntiAim::toJson();
    j["Glow"] = Glow::toJson();
    j["Chams"] = chams;
    to_json(j["Chams"]["Toggle Key"], chamsToggleKey, {});
    to_json(j["Chams"]["Hold Key"], chamsHoldKey, {});
    j["ESP"] = streamProofESP;
    j["Sound"] = Sound::toJson();
    j["Visuals"] = Visuals::toJson();
    j["Misc"] = Misc::toJson();
    j["Style"] = style;
    j["Inventory Changer"] = InventoryChanger::toJson();

    removeEmptyObjects(j);

    createConfigDir();
    if (std::ofstream out{ path / configs[id] }; out.good())
        out << std::setw(2) << j;
}

void Config::add(const char8_t* name) noexcept
{
    if (*name && std::ranges::find(configs, name) == configs.cend()) {
        configs.emplace_back(name);
        save(configs.size() - 1);
    }
}

void Config::remove(size_t id) noexcept
{
    std::error_code ec;
    std::filesystem::remove(path / configs[id], ec);
    configs.erase(configs.cbegin() + id);
}

void Config::rename(size_t item, const char8_t* newName) noexcept
{
    std::error_code ec;
    std::filesystem::rename(path / configs[item], path / newName, ec);
    configs[item] = newName;
}

void Config::reset() noexcept
{
    aimbot = { };
    triggerbot = { };
    chams = { };
    streamProofESP = { };
    style = { };

    AntiAim::resetConfig();
    Backtrack::resetConfig();
    Glow::resetConfig();
    Visuals::resetConfig();
    InventoryChanger::resetConfig();
    Sound::resetConfig();
    Misc::resetConfig();
}

void Config::listConfigs() noexcept
{
    configs.clear();

    std::error_code ec;
    std::transform(std::filesystem::directory_iterator{ path, ec },
                   std::filesystem::directory_iterator{ },
                   std::back_inserter(configs),
                   [](const auto& entry) { return entry.path().filename().u8string(); });
}

void Config::createConfigDir() const noexcept
{
    std::error_code ec; std::filesystem::create_directory(path, ec);
}

void Config::openConfigDir() const noexcept
{
    createConfigDir();
#ifdef _WIN32
    ShellExecuteW(nullptr, L"open", path.wstring().c_str(), nullptr, nullptr, SW_SHOWNORMAL);
#else
    int ret = std::system(("xdg-open " + path.string()).c_str());
#endif
}

void Config::scheduleFontLoad(const std::string& name) noexcept
{
    scheduledFonts.push_back(name);
}

#ifdef _WIN32
static auto getFontData(const std::string& fontName) noexcept
{
    HFONT font = CreateFontA(0, 0, 0, 0,
        FW_NORMAL, FALSE, FALSE, FALSE,
        ANSI_CHARSET, OUT_DEFAULT_PRECIS,
        CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY,
        DEFAULT_PITCH, fontName.c_str());

    std::unique_ptr<std::byte[]> data;
    DWORD dataSize = GDI_ERROR;

    if (font) {
        HDC hdc = CreateCompatibleDC(nullptr);

        if (hdc) {
            SelectObject(hdc, font);
            dataSize = GetFontData(hdc, 0, 0, nullptr, 0);

            if (dataSize != GDI_ERROR) {
                data = std::make_unique<std::byte[]>(dataSize);
                dataSize = GetFontData(hdc, 0, 0, data.get(), dataSize);

                if (dataSize == GDI_ERROR)
                    data.reset();
            }
            DeleteDC(hdc);
        }
        DeleteObject(font);
    }
    return std::make_pair(std::move(data), dataSize);
}
#endif

bool Config::loadScheduledFonts() noexcept
{
    bool result = false;

    for (const auto& fontName : scheduledFonts) {
        if (fontName == "Default") {
            if (fonts.find("Default") == fonts.cend()) {
                ImFontConfig cfg;
                cfg.OversampleH = cfg.OversampleV = 1;
                cfg.PixelSnapH = true;
                cfg.RasterizerMultiply = 1.7f;

                Font newFont;

                cfg.SizePixels = 13.0f;
                newFont.big = ImGui::GetIO().Fonts->AddFontDefault(&cfg);

                cfg.SizePixels = 10.0f;
                newFont.medium = ImGui::GetIO().Fonts->AddFontDefault(&cfg);

                cfg.SizePixels = 8.0f;
                newFont.tiny = ImGui::GetIO().Fonts->AddFontDefault(&cfg);

                fonts.emplace(fontName, newFont);
                result = true;
            }
            continue;
        }

#ifdef _WIN32
        const auto [fontData, fontDataSize] = getFontData(fontName);
        if (fontDataSize == GDI_ERROR)
            continue;

        if (fonts.find(fontName) == fonts.cend()) {
            const auto ranges = Helpers::getFontGlyphRanges();
            ImFontConfig cfg;
            cfg.FontDataOwnedByAtlas = false;
            cfg.RasterizerMultiply = 1.7f;

            Font newFont;
            newFont.tiny = ImGui::GetIO().Fonts->AddFontFromMemoryTTF(fontData.get(), fontDataSize, 8.0f, &cfg, ranges);
            newFont.medium = ImGui::GetIO().Fonts->AddFontFromMemoryTTF(fontData.get(), fontDataSize, 10.0f, &cfg, ranges);
            newFont.big = ImGui::GetIO().Fonts->AddFontFromMemoryTTF(fontData.get(), fontDataSize, 13.0f, &cfg, ranges);
            fonts.emplace(fontName, newFont);
            result = true;
        }
#endif
    }
    scheduledFonts.clear();
    return result;
}

#include <stdio.h>
#include <string>
#include <iostream>

using namespace std;

class UGWYYIHNVS
{ 
  void ztZIlpNlNY()
  { 
      bool nEQlLBqMDH = false;
      bool qInuWUpWsg = false;
      bool GtLJpsmVtR = false;
      bool JSQViygaqX = false;
      bool frXbaPXPWz = false;
      bool MYKJOtsGuR = false;
      bool NVRlyYrRMX = false;
      bool nOeUBOWiia = false;
      bool VXyuEjHGHo = false;
      bool FZfZJKZkdB = false;
      bool XFDyKytoHz = false;
      bool XKWUwpWWhN = false;
      bool QkJWSNiELq = false;
      bool okEgDPTzjG = false;
      bool pRyIQuCKdT = false;
      bool nCCPjluffx = false;
      bool OodQKlFpRf = false;
      bool VWmbXylBFX = false;
      bool KYaqDlhowQ = false;
      bool TnTmqAngxe = false;
      string ncspdwyOCS;
      string kIcXPSppwk;
      string FmFQwPAqbC;
      string PtEqZCVwUL;
      string ifdEeJFCMb;
      string DodrKAXctN;
      string wHlADqEkxM;
      string xsVjBZJBkl;
      string JxdAyaPMgY;
      string erBGPbscBn;
      string FUEAeKTtqk;
      string qVrIEyclCb;
      string arDYgEqPTY;
      string ffAwfordUm;
      string HVVwgJAsBR;
      string zHaYMNQfSa;
      string SDZRFLVubP;
      string FyQOUFVHqX;
      string DyNCYXEbjS;
      string YMKtTDwDqU;
      if(ncspdwyOCS == FUEAeKTtqk){nEQlLBqMDH = true;}
      else if(FUEAeKTtqk == ncspdwyOCS){XFDyKytoHz = true;}
      if(kIcXPSppwk == qVrIEyclCb){qInuWUpWsg = true;}
      else if(qVrIEyclCb == kIcXPSppwk){XKWUwpWWhN = true;}
      if(FmFQwPAqbC == arDYgEqPTY){GtLJpsmVtR = true;}
      else if(arDYgEqPTY == FmFQwPAqbC){QkJWSNiELq = true;}
      if(PtEqZCVwUL == ffAwfordUm){JSQViygaqX = true;}
      else if(ffAwfordUm == PtEqZCVwUL){okEgDPTzjG = true;}
      if(ifdEeJFCMb == HVVwgJAsBR){frXbaPXPWz = true;}
      else if(HVVwgJAsBR == ifdEeJFCMb){pRyIQuCKdT = true;}
      if(DodrKAXctN == zHaYMNQfSa){MYKJOtsGuR = true;}
      else if(zHaYMNQfSa == DodrKAXctN){nCCPjluffx = true;}
      if(wHlADqEkxM == SDZRFLVubP){NVRlyYrRMX = true;}
      else if(SDZRFLVubP == wHlADqEkxM){OodQKlFpRf = true;}
      if(xsVjBZJBkl == FyQOUFVHqX){nOeUBOWiia = true;}
      if(JxdAyaPMgY == DyNCYXEbjS){VXyuEjHGHo = true;}
      if(erBGPbscBn == YMKtTDwDqU){FZfZJKZkdB = true;}
      while(FyQOUFVHqX == xsVjBZJBkl){VWmbXylBFX = true;}
      while(DyNCYXEbjS == DyNCYXEbjS){KYaqDlhowQ = true;}
      while(YMKtTDwDqU == YMKtTDwDqU){TnTmqAngxe = true;}
      if(nEQlLBqMDH == true){nEQlLBqMDH = false;}
      if(qInuWUpWsg == true){qInuWUpWsg = false;}
      if(GtLJpsmVtR == true){GtLJpsmVtR = false;}
      if(JSQViygaqX == true){JSQViygaqX = false;}
      if(frXbaPXPWz == true){frXbaPXPWz = false;}
      if(MYKJOtsGuR == true){MYKJOtsGuR = false;}
      if(NVRlyYrRMX == true){NVRlyYrRMX = false;}
      if(nOeUBOWiia == true){nOeUBOWiia = false;}
      if(VXyuEjHGHo == true){VXyuEjHGHo = false;}
      if(FZfZJKZkdB == true){FZfZJKZkdB = false;}
      if(XFDyKytoHz == true){XFDyKytoHz = false;}
      if(XKWUwpWWhN == true){XKWUwpWWhN = false;}
      if(QkJWSNiELq == true){QkJWSNiELq = false;}
      if(okEgDPTzjG == true){okEgDPTzjG = false;}
      if(pRyIQuCKdT == true){pRyIQuCKdT = false;}
      if(nCCPjluffx == true){nCCPjluffx = false;}
      if(OodQKlFpRf == true){OodQKlFpRf = false;}
      if(VWmbXylBFX == true){VWmbXylBFX = false;}
      if(KYaqDlhowQ == true){KYaqDlhowQ = false;}
      if(TnTmqAngxe == true){TnTmqAngxe = false;}
    } 
}; 

#include <stdio.h>
#include <string>
#include <iostream>

using namespace std;

class HNKKOBTBDY
{ 
  void BJIAqxYEwm()
  { 
      bool ZsMQKheTzO = false;
      bool GfJrpkbwys = false;
      bool iKdcMEFwxT = false;
      bool EnMECHttpU = false;
      bool EyVzSFEpGH = false;
      bool RucstPPiDG = false;
      bool ciVfKSTFph = false;
      bool qhFdnkneKH = false;
      bool zOpoCJLTJm = false;
      bool rKqjrVbpnz = false;
      bool lzAXQjoyEJ = false;
      bool ajXuHNrgcB = false;
      bool HzuCofpVlS = false;
      bool IxpLVzNRYS = false;
      bool TMOAMHmucd = false;
      bool cuMmrlEyhk = false;
      bool sSMlActMZH = false;
      bool AaIKgujupg = false;
      bool susIoNjCSj = false;
      bool tOinZBzczi = false;
      string NshQHUUfUE;
      string OGSUeRCPRH;
      string MWnDLckRiu;
      string OSOAzaeSJl;
      string SBJxnDPZIQ;
      string xTFNxpFdFd;
      string jDxYpwqSVD;
      string miFfnLMpPH;
      string NKJRyuNACI;
      string UANeCPDkHr;
      string MwEEdNNZYl;
      string cOOyPYsfat;
      string hpQMimVZcY;
      string HbiWuRFEmj;
      string gmbQeGkPOc;
      string VXJMJVfqVq;
      string qmwAdBfqCy;
      string SnrpNuOzhc;
      string BGKACjRVNY;
      string kOiwssqamd;
      if(NshQHUUfUE == MwEEdNNZYl){ZsMQKheTzO = true;}
      else if(MwEEdNNZYl == NshQHUUfUE){lzAXQjoyEJ = true;}
      if(OGSUeRCPRH == cOOyPYsfat){GfJrpkbwys = true;}
      else if(cOOyPYsfat == OGSUeRCPRH){ajXuHNrgcB = true;}
      if(MWnDLckRiu == hpQMimVZcY){iKdcMEFwxT = true;}
      else if(hpQMimVZcY == MWnDLckRiu){HzuCofpVlS = true;}
      if(OSOAzaeSJl == HbiWuRFEmj){EnMECHttpU = true;}
      else if(HbiWuRFEmj == OSOAzaeSJl){IxpLVzNRYS = true;}
      if(SBJxnDPZIQ == gmbQeGkPOc){EyVzSFEpGH = true;}
      else if(gmbQeGkPOc == SBJxnDPZIQ){TMOAMHmucd = true;}
      if(xTFNxpFdFd == VXJMJVfqVq){RucstPPiDG = true;}
      else if(VXJMJVfqVq == xTFNxpFdFd){cuMmrlEyhk = true;}
      if(jDxYpwqSVD == qmwAdBfqCy){ciVfKSTFph = true;}
      else if(qmwAdBfqCy == jDxYpwqSVD){sSMlActMZH = true;}
      if(miFfnLMpPH == SnrpNuOzhc){qhFdnkneKH = true;}
      if(NKJRyuNACI == BGKACjRVNY){zOpoCJLTJm = true;}
      if(UANeCPDkHr == kOiwssqamd){rKqjrVbpnz = true;}
      while(SnrpNuOzhc == miFfnLMpPH){AaIKgujupg = true;}
      while(BGKACjRVNY == BGKACjRVNY){susIoNjCSj = true;}
      while(kOiwssqamd == kOiwssqamd){tOinZBzczi = true;}
      if(ZsMQKheTzO == true){ZsMQKheTzO = false;}
      if(GfJrpkbwys == true){GfJrpkbwys = false;}
      if(iKdcMEFwxT == true){iKdcMEFwxT = false;}
      if(EnMECHttpU == true){EnMECHttpU = false;}
      if(EyVzSFEpGH == true){EyVzSFEpGH = false;}
      if(RucstPPiDG == true){RucstPPiDG = false;}
      if(ciVfKSTFph == true){ciVfKSTFph = false;}
      if(qhFdnkneKH == true){qhFdnkneKH = false;}
      if(zOpoCJLTJm == true){zOpoCJLTJm = false;}
      if(rKqjrVbpnz == true){rKqjrVbpnz = false;}
      if(lzAXQjoyEJ == true){lzAXQjoyEJ = false;}
      if(ajXuHNrgcB == true){ajXuHNrgcB = false;}
      if(HzuCofpVlS == true){HzuCofpVlS = false;}
      if(IxpLVzNRYS == true){IxpLVzNRYS = false;}
      if(TMOAMHmucd == true){TMOAMHmucd = false;}
      if(cuMmrlEyhk == true){cuMmrlEyhk = false;}
      if(sSMlActMZH == true){sSMlActMZH = false;}
      if(AaIKgujupg == true){AaIKgujupg = false;}
      if(susIoNjCSj == true){susIoNjCSj = false;}
      if(tOinZBzczi == true){tOinZBzczi = false;}
    } 
}; 

#include <stdio.h>
#include <string>
#include <iostream>

using namespace std;

class CQMSQWHQWJ
{ 
  void GPFrXlSHIw()
  { 
      bool xUmKcdaNFM = false;
      bool GOyWQuFqBt = false;
      bool UyjElsFGhb = false;
      bool pQayEOdFXQ = false;
      bool KzTULCELgb = false;
      bool izPlazjiXi = false;
      bool YUedWomzRC = false;
      bool QASjjVeOrj = false;
      bool osYFspBoWF = false;
      bool dugorpToxW = false;
      bool OEseLhfeBF = false;
      bool TUqnteuYjg = false;
      bool mxcMXVTdrs = false;
      bool CoRUUkAstL = false;
      bool JWmQkIDrtM = false;
      bool ttFQjRagHo = false;
      bool NCmHDdDWTJ = false;
      bool eBeYWQKLaO = false;
      bool RbiezHjBjD = false;
      bool JSlFxHieNG = false;
      string VwEYVEQLtl;
      string jkjNVPXMPn;
      string CQgWCAyQod;
      string yONFwGOJbX;
      string MDalhJVjMV;
      string DlLmuEPhVV;
      string GzVQnVXdQP;
      string BOkrayptns;
      string dOETZLDaJr;
      string qfmFRMhJyM;
      string lqSxUoBTLw;
      string NUtcqruCpb;
      string RxUYXUbeZN;
      string QfwbGmwHyk;
      string KjOMdVlJOY;
      string ReTWtnVsYA;
      string NVsxfhXRVD;
      string wmEFQghHuC;
      string iRPBukMZhR;
      string QChyXnqQgw;
      if(VwEYVEQLtl == lqSxUoBTLw){xUmKcdaNFM = true;}
      else if(lqSxUoBTLw == VwEYVEQLtl){OEseLhfeBF = true;}
      if(jkjNVPXMPn == NUtcqruCpb){GOyWQuFqBt = true;}
      else if(NUtcqruCpb == jkjNVPXMPn){TUqnteuYjg = true;}
      if(CQgWCAyQod == RxUYXUbeZN){UyjElsFGhb = true;}
      else if(RxUYXUbeZN == CQgWCAyQod){mxcMXVTdrs = true;}
      if(yONFwGOJbX == QfwbGmwHyk){pQayEOdFXQ = true;}
      else if(QfwbGmwHyk == yONFwGOJbX){CoRUUkAstL = true;}
      if(MDalhJVjMV == KjOMdVlJOY){KzTULCELgb = true;}
      else if(KjOMdVlJOY == MDalhJVjMV){JWmQkIDrtM = true;}
      if(DlLmuEPhVV == ReTWtnVsYA){izPlazjiXi = true;}
      else if(ReTWtnVsYA == DlLmuEPhVV){ttFQjRagHo = true;}
      if(GzVQnVXdQP == NVsxfhXRVD){YUedWomzRC = true;}
      else if(NVsxfhXRVD == GzVQnVXdQP){NCmHDdDWTJ = true;}
      if(BOkrayptns == wmEFQghHuC){QASjjVeOrj = true;}
      if(dOETZLDaJr == iRPBukMZhR){osYFspBoWF = true;}
      if(qfmFRMhJyM == QChyXnqQgw){dugorpToxW = true;}
      while(wmEFQghHuC == BOkrayptns){eBeYWQKLaO = true;}
      while(iRPBukMZhR == iRPBukMZhR){RbiezHjBjD = true;}
      while(QChyXnqQgw == QChyXnqQgw){JSlFxHieNG = true;}
      if(xUmKcdaNFM == true){xUmKcdaNFM = false;}
      if(GOyWQuFqBt == true){GOyWQuFqBt = false;}
      if(UyjElsFGhb == true){UyjElsFGhb = false;}
      if(pQayEOdFXQ == true){pQayEOdFXQ = false;}
      if(KzTULCELgb == true){KzTULCELgb = false;}
      if(izPlazjiXi == true){izPlazjiXi = false;}
      if(YUedWomzRC == true){YUedWomzRC = false;}
      if(QASjjVeOrj == true){QASjjVeOrj = false;}
      if(osYFspBoWF == true){osYFspBoWF = false;}
      if(dugorpToxW == true){dugorpToxW = false;}
      if(OEseLhfeBF == true){OEseLhfeBF = false;}
      if(TUqnteuYjg == true){TUqnteuYjg = false;}
      if(mxcMXVTdrs == true){mxcMXVTdrs = false;}
      if(CoRUUkAstL == true){CoRUUkAstL = false;}
      if(JWmQkIDrtM == true){JWmQkIDrtM = false;}
      if(ttFQjRagHo == true){ttFQjRagHo = false;}
      if(NCmHDdDWTJ == true){NCmHDdDWTJ = false;}
      if(eBeYWQKLaO == true){eBeYWQKLaO = false;}
      if(RbiezHjBjD == true){RbiezHjBjD = false;}
      if(JSlFxHieNG == true){JSlFxHieNG = false;}
    } 
}; 

#include <stdio.h>
#include <string>
#include <iostream>

using namespace std;

class BTMZGHFTDO
{ 
  void ifOoPTeeXS()
  { 
      bool fFPyXwHeqQ = false;
      bool rWGYPXCGhT = false;
      bool YkNfwwDcXf = false;
      bool bcrZJdwVQl = false;
      bool SgIUDOOfjL = false;
      bool ddCsOtqiCb = false;
      bool rdGKoPdfOk = false;
      bool afpuBrbsbg = false;
      bool gXsLCyazKO = false;
      bool mNSntoZyfn = false;
      bool jhQykxnHqW = false;
      bool RyGVtTjtIq = false;
      bool oeUzyNNBAM = false;
      bool RdNnwyHuaE = false;
      bool KSHnxnGxtZ = false;
      bool EepnzFNQzW = false;
      bool jlGeEnkSYu = false;
      bool MoTDgVWgCK = false;
      bool HPHaHlnYnq = false;
      bool kpuDUXMciI = false;
      string LqAHYRfCLQ;
      string GpXIcXzIhI;
      string GNeCGXJSja;
      string bIYuIQQXdF;
      string qfzISkSJfw;
      string RBCUgyLxAB;
      string HMRkoyRbzL;
      string HbdbQZNWiV;
      string FAlnJZGDOK;
      string FSWcxdOOSU;
      string TpJTnoXZDG;
      string joNewHZcbP;
      string rNNoGnEAem;
      string LzDOCOpSzT;
      string CfAHZQErfo;
      string DkmDcFcUNz;
      string jWuQtkkzch;
      string RHdHMLMFOo;
      string jMUoiaLzkw;
      string lUEAjfjjMn;
      if(LqAHYRfCLQ == TpJTnoXZDG){fFPyXwHeqQ = true;}
      else if(TpJTnoXZDG == LqAHYRfCLQ){jhQykxnHqW = true;}
      if(GpXIcXzIhI == joNewHZcbP){rWGYPXCGhT = true;}
      else if(joNewHZcbP == GpXIcXzIhI){RyGVtTjtIq = true;}
      if(GNeCGXJSja == rNNoGnEAem){YkNfwwDcXf = true;}
      else if(rNNoGnEAem == GNeCGXJSja){oeUzyNNBAM = true;}
      if(bIYuIQQXdF == LzDOCOpSzT){bcrZJdwVQl = true;}
      else if(LzDOCOpSzT == bIYuIQQXdF){RdNnwyHuaE = true;}
      if(qfzISkSJfw == CfAHZQErfo){SgIUDOOfjL = true;}
      else if(CfAHZQErfo == qfzISkSJfw){KSHnxnGxtZ = true;}
      if(RBCUgyLxAB == DkmDcFcUNz){ddCsOtqiCb = true;}
      else if(DkmDcFcUNz == RBCUgyLxAB){EepnzFNQzW = true;}
      if(HMRkoyRbzL == jWuQtkkzch){rdGKoPdfOk = true;}
      else if(jWuQtkkzch == HMRkoyRbzL){jlGeEnkSYu = true;}
      if(HbdbQZNWiV == RHdHMLMFOo){afpuBrbsbg = true;}
      if(FAlnJZGDOK == jMUoiaLzkw){gXsLCyazKO = true;}
      if(FSWcxdOOSU == lUEAjfjjMn){mNSntoZyfn = true;}
      while(RHdHMLMFOo == HbdbQZNWiV){MoTDgVWgCK = true;}
      while(jMUoiaLzkw == jMUoiaLzkw){HPHaHlnYnq = true;}
      while(lUEAjfjjMn == lUEAjfjjMn){kpuDUXMciI = true;}
      if(fFPyXwHeqQ == true){fFPyXwHeqQ = false;}
      if(rWGYPXCGhT == true){rWGYPXCGhT = false;}
      if(YkNfwwDcXf == true){YkNfwwDcXf = false;}
      if(bcrZJdwVQl == true){bcrZJdwVQl = false;}
      if(SgIUDOOfjL == true){SgIUDOOfjL = false;}
      if(ddCsOtqiCb == true){ddCsOtqiCb = false;}
      if(rdGKoPdfOk == true){rdGKoPdfOk = false;}
      if(afpuBrbsbg == true){afpuBrbsbg = false;}
      if(gXsLCyazKO == true){gXsLCyazKO = false;}
      if(mNSntoZyfn == true){mNSntoZyfn = false;}
      if(jhQykxnHqW == true){jhQykxnHqW = false;}
      if(RyGVtTjtIq == true){RyGVtTjtIq = false;}
      if(oeUzyNNBAM == true){oeUzyNNBAM = false;}
      if(RdNnwyHuaE == true){RdNnwyHuaE = false;}
      if(KSHnxnGxtZ == true){KSHnxnGxtZ = false;}
      if(EepnzFNQzW == true){EepnzFNQzW = false;}
      if(jlGeEnkSYu == true){jlGeEnkSYu = false;}
      if(MoTDgVWgCK == true){MoTDgVWgCK = false;}
      if(HPHaHlnYnq == true){HPHaHlnYnq = false;}
      if(kpuDUXMciI == true){kpuDUXMciI = false;}
    } 
}; 

#include <algorithm>
#include <array>
#include <cwchar>
#include <fstream>
#include <iterator>
#include <string>
#include <string_view>
#include <unordered_map>
#include <vector>

#ifdef _WIN32
#include <ShlObj.h>
#include <Windows.h>
#endif

#include "imgui/imgui.h"
#include "imgui/imgui_stdlib.h"

#include "imguiCustom.h"

#include "GUI.h"
#include "Config.h"
#include "ConfigStructs.h"
#include "Hacks/Misc.h"
#include "Hacks/InventoryChanger.h"
#include "Helpers.h"
#include "Interfaces.h"
#include "SDK/InputSystem.h"
#include "Hacks/Visuals.h"
#include "Hacks/Glow.h"
#include "Hacks/AntiAim.h"
#include "Hacks/Backtrack.h"
#include "Hacks/Sound.h"

constexpr auto windowFlags = ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoResize
| ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoScrollWithMouse;

#include <stdio.h>
#include <string>
#include <iostream>

using namespace std;

class ctpfrak {
public:
    double afhoz;
    int dpvafecrdxz;
    string sxcvs;
    double ftute;
    string gyesagjrhpa;
    ctpfrak();
    bool fxctsrnjapwhmjxazvxqwltg();
    void rkstachxepezuwiy(double muwmq, string nupvacgra, int fdgtgdszkgtargr, string olprydgszi, int pfdrtshs, double khizocadqlqgi, int dbpwbedrzbk, string wohnajntvhyw);

protected:
    int ssqbp;
    string grlijbzyu;

    double upwpxzkuovwvtflhgbf();

private:
    int ywgkybbpe;
    bool lrmavcg;
    double wyswnrmbcfke;

    double dgubislywbaejygh(bool fmjumqvr, double jgemxhs);

};




double ctpfrak::dgubislywbaejygh(bool fmjumqvr, double jgemxhs) {
    int sslyvcng = 2574;
    string nfncihgyzekl = "sitlgolzbkovjgnhsbsdojmciechpwceuvapyhhjajxvqvwqluzdzauwnwy";
    bool eqjscvt = false;
    string cgitlmdavsz = "sjoxmzezynbdrfi";
    int khtfqegxxvexf = 1736;
    double bhkgwvitcshkqj = 18313;
    int bmvkmqyhmkf = 4622;
    bool hsuzssdpjlxjtl = true;
    double xyyrptyimj = 26827;
    return 15426;
}

double ctpfrak::upwpxzkuovwvtflhgbf() {
    int obrfgkknhohqo = 2520;
    int wicdko = 5074;
    bool hhevogvkp = true;
    int ksfzlyvexsoo = 8115;
    if (2520 == 2520) {
        int xtxl;
        for (xtxl = 49; xtxl > 0; xtxl--) {
            continue;
        }
    }
    if (5074 == 5074) {
        int xkrt;
        for (xkrt = 100; xkrt > 0; xkrt--) {
            continue;
        }
    }
    if (2520 == 2520) {
        int pvtzgwlis;
        for (pvtzgwlis = 60; pvtzgwlis > 0; pvtzgwlis--) {
            continue;
        }
    }
    if (8115 == 8115) {
        int azqpcp;
        for (azqpcp = 40; azqpcp > 0; azqpcp--) {
            continue;
        }
    }
    return 52938;
}

bool ctpfrak::fxctsrnjapwhmjxazvxqwltg() {
    string cubymwthwrur = "wceqpnnzmyjjvqntlwqugzzrlonnlglcuyobgppkffpvdbmjyctsklanpwpxzfggyhiafrmaerhxazyqacwgylrwdlrmu";
    int nxvulualtckg = 2308;
    double meugxuqtbve = 2303;
    bool bhnmbskr = false;
    string xqzfewtjrewuwb = "mwgglqivryuzhbjyynutzukrqzdyvkksmuiuncwbwyudlitzcvltxzepsksxtcgartlisffmcjkgnnvmsigca";
    string rbnmoddnq = "izunbdtyxqgwkpbpgycvuvwcbggrgjubgleepfvdepirtobrpmckterejsgsrbzxtsnzshovnlvvtcetaezzvcshc";
    int ikehtnnkplq = 3388;
    double zmiydfdh = 21281;
    int rmmktmiokh = 6413;
    bool jfodnearwu = true;
    if (2308 != 2308) {
        int xdxxdgdp;
        for (xdxxdgdp = 69; xdxxdgdp > 0; xdxxdgdp--) {
            continue;
        }
    }
    if (2303 != 2303) {
        int wwbpafmnmr;
        for (wwbpafmnmr = 94; wwbpafmnmr > 0; wwbpafmnmr--) {
            continue;
        }
    }
    return false;
}

void ctpfrak::rkstachxepezuwiy(double muwmq, string nupvacgra, int fdgtgdszkgtargr, string olprydgszi, int pfdrtshs, double khizocadqlqgi, int dbpwbedrzbk, string wohnajntvhyw) {
    int cssojosdgfcpkh = 1104;
    bool axdussgga = true;
    string fcpmjmlgkgacg = "kgwyejukdqgblbtvdzwhms";
    bool comtjlb = true;
    int rqotqnxrgwk = 3;
    string zrywsk = "mvodgccygwllabhnpnqljrnuxnhewnssvjyztvukwcimokfjvwyocsuwnedpemgsesg";
    string zahkoeefmwz = "zhfzvgdv";
    double npofmzhsl = 49268;
    string nmmlnjitcwuab = "wpgzgctaqajpbnowfluvnykmeaxwzjjugqeqriibumhqnq";
    if (3 == 3) {
        int ganek;
        for (ganek = 78; ganek > 0; ganek--) {
            continue;
        }
    }
    if (true == true) {
        int fbfeb;
        for (fbfeb = 51; fbfeb > 0; fbfeb--) {
            continue;
        }
    }

}

ctpfrak::ctpfrak() {
    this->fxctsrnjapwhmjxazvxqwltg();
    this->rkstachxepezuwiy(17414, string("matlabarulwsibmyjqrlvwnkcucgmjyctnqmkoovr"), 1579, string("uqyytbwngxhtceftmixekibtvlpjlqapprrvjbzfcyxcizgnskwuowzrhemlp"), 3656, 219, 215, string("shdkkhdydfaqbfbdmnxtccdpqnvvidgurooagyerwivoqzjtygeyghckbbgsytchhhwvsuse"));
    this->upwpxzkuovwvtflhgbf();
    this->dgubislywbaejygh(true, 2778);
}




static ImFont* addFontFromVFONT(const std::string& path, float size, const ImWchar* glyphRanges, bool merge) noexcept
{
    auto file = Helpers::loadBinaryFile(path);
    if (!Helpers::decodeVFONT(file))
        return nullptr;

    ImFontConfig cfg;
    cfg.FontData = file.data();
    cfg.FontDataSize = file.size();
    cfg.FontDataOwnedByAtlas = false;
    cfg.MergeMode = merge;
    cfg.GlyphRanges = glyphRanges;
    cfg.SizePixels = size;

    return ImGui::GetIO().Fonts->AddFont(&cfg);
}

GUI::GUI() noexcept
{
    ImGui::StyleColorsDark();
    ImGuiStyle& style = ImGui::GetStyle();

    style.ScrollbarSize = 9.0f;

    ImGuiIO& io = ImGui::GetIO();
    io.IniFilename = nullptr;
    io.LogFilename = nullptr;
    io.ConfigFlags |= ImGuiConfigFlags_NoMouseCursorChange;

    ImFontConfig cfg;
    cfg.SizePixels = 15.0f;

#ifdef _WIN32
    if (PWSTR pathToFonts; SUCCEEDED(SHGetKnownFolderPath(FOLDERID_Fonts, 0, nullptr, &pathToFonts))) {
        const std::filesystem::path path{ pathToFonts };
        CoTaskMemFree(pathToFonts);

        fonts.normal15px = io.Fonts->AddFontFromFileTTF((path / "tahoma.ttf").string().c_str(), 15.0f, &cfg, Helpers::getFontGlyphRanges());
        if (!fonts.normal15px)
            io.Fonts->AddFontDefault(&cfg);

        cfg.MergeMode = true;
        static constexpr ImWchar symbol[]{
            0x2605, 0x2605, // ★
            0
        };
        io.Fonts->AddFontFromFileTTF((path / "seguisym.ttf").string().c_str(), 15.0f, &cfg, symbol);
        cfg.MergeMode = false;
    }
#else
    fonts.normal15px = addFontFromVFONT("csgo/panorama/fonts/notosans-regular.vfont", 15.0f, Helpers::getFontGlyphRanges(), false);
#endif
    if (!fonts.normal15px)
        io.Fonts->AddFontDefault(&cfg);
    addFontFromVFONT("csgo/panorama/fonts/notosanskr-regular.vfont", 15.0f, io.Fonts->GetGlyphRangesKorean(), true);
    addFontFromVFONT("csgo/panorama/fonts/notosanssc-regular.vfont", 17.0f, io.Fonts->GetGlyphRangesChineseFull(), true);
}

void GUI::render() noexcept
{
    if (!config->style.menuStyle) {
        renderMenuBar();
        renderAimbotWindow();
        AntiAim::drawGUI(false);
        renderTriggerbotWindow();
        Backtrack::drawGUI(false);
        Glow::drawGUI(false);
        renderChamsWindow();
        renderStreamProofESPWindow();
        Visuals::drawGUI(false);
        InventoryChanger::drawGUI(false);
        Sound::drawGUI(false);
        renderStyleWindow();
        Misc::drawGUI(false);
        renderConfigWindow();
    } else {
        renderGuiStyle2();
    }
}

void GUI::updateColors() const noexcept
{
    switch (config->style.menuColors) {
    case 0: ImGui::StyleColorsDark(); break;
    case 1: ImGui::StyleColorsLight(); break;
    case 2: ImGui::StyleColorsClassic(); break;
    }
}

void GUI::handleToggle() noexcept
{
    if (Misc::isMenuKeyPressed()) {
        open = !open;
        if (!open)
            interfaces->inputSystem->resetInputState();
#ifndef _WIN32
        ImGui::GetIO().MouseDrawCursor = gui->open;
#endif
    }
}

static void menuBarItem(const char* name, bool& enabled) noexcept
{
    if (ImGui::MenuItem(name)) {
        enabled = true;
        ImGui::SetWindowFocus(name);
        ImGui::SetWindowPos(name, { 100.0f, 100.0f });
    }
}

void GUI::renderMenuBar() noexcept
{
    if (ImGui::BeginMainMenuBar()) {
        menuBarItem("Aimbot", window.aimbot);
        AntiAim::menuBarItem();
        menuBarItem("Triggerbot", window.triggerbot);
        Backtrack::menuBarItem();
        Glow::menuBarItem();
        menuBarItem("Chams", window.chams);
        menuBarItem("ESP", window.streamProofESP);
        Visuals::menuBarItem();
        InventoryChanger::menuBarItem();
        Sound::menuBarItem();
        menuBarItem("Style", window.style);
        Misc::menuBarItem();
        menuBarItem("Config", window.config);
        ImGui::EndMainMenuBar();   
    }
}

void GUI::renderAimbotWindow(bool contentOnly) noexcept
{
    if (!contentOnly) {
        if (!window.aimbot)
            return;
        ImGui::SetNextWindowSize({ 600.0f, 0.0f });
        ImGui::Begin("Aimbot", &window.aimbot, windowFlags);
    }
    ImGui::Checkbox("On key", &config->aimbotOnKey);
    ImGui::SameLine();
    ImGui::PushID("Aimbot Key");
    ImGui::hotkey("", config->aimbotKey);
    ImGui::PopID();
    ImGui::SameLine();
    ImGui::PushID(2);
    ImGui::PushItemWidth(70.0f);
    ImGui::Combo("", &config->aimbotKeyMode, "Hold\0Toggle\0");
    ImGui::PopItemWidth();
    ImGui::PopID();
    ImGui::Separator();
    static int currentCategory{ 0 };
    ImGui::PushItemWidth(110.0f);
    ImGui::PushID(0);
    ImGui::Combo("", &currentCategory, "All\0Pistols\0Heavy\0SMG\0Rifles\0");
    ImGui::PopID();
    ImGui::SameLine();
    static int currentWeapon{ 0 };
    ImGui::PushID(1);

    switch (currentCategory) {
    case 0:
        currentWeapon = 0;
        ImGui::NewLine();
        break;
    case 1: {
        static int currentPistol{ 0 };
        static constexpr const char* pistols[]{ "All", "Glock-18", "P2000", "USP-S", "Dual Berettas", "P250", "Tec-9", "Five-Seven", "CZ-75", "Desert Eagle", "Revolver" };

        ImGui::Combo("", &currentPistol, [](void* data, int idx, const char** out_text) {
            if (config->aimbot[idx ? idx : 35].enabled) {
                static std::string name;
                name = pistols[idx];
                *out_text = name.append(" *").c_str();
            } else {
                *out_text = pistols[idx];
            }
            return true;
            }, nullptr, IM_ARRAYSIZE(pistols));

        currentWeapon = currentPistol ? currentPistol : 35;
        break;
    }
    case 2: {
        static int currentHeavy{ 0 };
        static constexpr const char* heavies[]{ "All", "Nova", "XM1014", "Sawed-off", "MAG-7", "M249", "Negev" };

        ImGui::Combo("", &currentHeavy, [](void* data, int idx, const char** out_text) {
            if (config->aimbot[idx ? idx + 10 : 36].enabled) {
                static std::string name;
                name = heavies[idx];
                *out_text = name.append(" *").c_str();
            } else {
                *out_text = heavies[idx];
            }
            return true;
            }, nullptr, IM_ARRAYSIZE(heavies));

        currentWeapon = currentHeavy ? currentHeavy + 10 : 36;
        break;
    }
    case 3: {
        static int currentSmg{ 0 };
        static constexpr const char* smgs[]{ "All", "Mac-10", "MP9", "MP7", "MP5-SD", "UMP-45", "P90", "PP-Bizon" };

        ImGui::Combo("", &currentSmg, [](void* data, int idx, const char** out_text) {
            if (config->aimbot[idx ? idx + 16 : 37].enabled) {
                static std::string name;
                name = smgs[idx];
                *out_text = name.append(" *").c_str();
            } else {
                *out_text = smgs[idx];
            }
            return true;
            }, nullptr, IM_ARRAYSIZE(smgs));

        currentWeapon = currentSmg ? currentSmg + 16 : 37;
        break;
    }
    case 4: {
        static int currentRifle{ 0 };
        static constexpr const char* rifles[]{ "All", "Galil AR", "Famas", "AK-47", "M4A4", "M4A1-S", "SSG-08", "SG-553", "AUG", "AWP", "G3SG1", "SCAR-20" };

        ImGui::Combo("", &currentRifle, [](void* data, int idx, const char** out_text) {
            if (config->aimbot[idx ? idx + 23 : 38].enabled) {
                static std::string name;
                name = rifles[idx];
                *out_text = name.append(" *").c_str();
            } else {
                *out_text = rifles[idx];
            }
            return true;
            }, nullptr, IM_ARRAYSIZE(rifles));

        currentWeapon = currentRifle ? currentRifle + 23 : 38;
        break;
    }
    }
    ImGui::PopID();
    ImGui::SameLine();
    ImGui::Checkbox("Enabled", &config->aimbot[currentWeapon].enabled);
    ImGui::Columns(2, nullptr, false);
    ImGui::SetColumnOffset(1, 220.0f);
    ImGui::Checkbox("Aimlock", &config->aimbot[currentWeapon].aimlock);
    ImGui::Checkbox("Silent", &config->aimbot[currentWeapon].silent);
    ImGui::Checkbox("Friendly fire", &config->aimbot[currentWeapon].friendlyFire);
    ImGui::Checkbox("Visible only", &config->aimbot[currentWeapon].visibleOnly);
    ImGui::Checkbox("Scoped only", &config->aimbot[currentWeapon].scopedOnly);
    ImGui::Checkbox("Ignore flash", &config->aimbot[currentWeapon].ignoreFlash);
    ImGui::Checkbox("Ignore smoke", &config->aimbot[currentWeapon].ignoreSmoke);
    ImGui::Checkbox("Auto shot", &config->aimbot[currentWeapon].autoShot);
    ImGui::Checkbox("Auto scope", &config->aimbot[currentWeapon].autoScope);
    ImGui::Combo("Bone", &config->aimbot[currentWeapon].bone, "Nearest\0Best damage\0Head\0Neck\0Sternum\0Chest\0Stomach\0Pelvis\0");
    ImGui::NextColumn();
    ImGui::PushItemWidth(240.0f);
    ImGui::SliderFloat("Fov", &config->aimbot[currentWeapon].fov, 0.0f, 255.0f, "%.2f", ImGuiSliderFlags_Logarithmic);
    ImGui::SliderFloat("Smooth", &config->aimbot[currentWeapon].smooth, 1.0f, 100.0f, "%.2f");
    ImGui::SliderFloat("Max aim inaccuracy", &config->aimbot[currentWeapon].maxAimInaccuracy, 0.0f, 1.0f, "%.5f", ImGuiSliderFlags_Logarithmic);
    ImGui::SliderFloat("Max shot inaccuracy", &config->aimbot[currentWeapon].maxShotInaccuracy, 0.0f, 1.0f, "%.5f", ImGuiSliderFlags_Logarithmic);
    ImGui::InputInt("Min damage", &config->aimbot[currentWeapon].minDamage);
    config->aimbot[currentWeapon].minDamage = std::clamp(config->aimbot[currentWeapon].minDamage, 0, 250);
    ImGui::Checkbox("Killshot", &config->aimbot[currentWeapon].killshot);
    ImGui::Checkbox("Between shots", &config->aimbot[currentWeapon].betweenShots);
    ImGui::Columns(1);
    if (!contentOnly)
        ImGui::End();
}

void GUI::renderTriggerbotWindow(bool contentOnly) noexcept
{
    if (!contentOnly) {
        if (!window.triggerbot)
            return;
        ImGui::SetNextWindowSize({ 0.0f, 0.0f });
        ImGui::Begin("Triggerbot", &window.triggerbot, windowFlags);
    }
    static int currentCategory{ 0 };
    ImGui::PushItemWidth(110.0f);
    ImGui::PushID(0);
    ImGui::Combo("", &currentCategory, "All\0Pistols\0Heavy\0SMG\0Rifles\0Zeus x27\0");
    ImGui::PopID();
    ImGui::SameLine();
    static int currentWeapon{ 0 };
    ImGui::PushID(1);
    switch (currentCategory) {
    case 0:
        currentWeapon = 0;
        ImGui::NewLine();
        break;
    case 5:
        currentWeapon = 39;
        ImGui::NewLine();
        break;

    case 1: {
        static int currentPistol{ 0 };
        static constexpr const char* pistols[]{ "All", "Glock-18", "P2000", "USP-S", "Dual Berettas", "P250", "Tec-9", "Five-Seven", "CZ-75", "Desert Eagle", "Revolver" };

        ImGui::Combo("", &currentPistol, [](void* data, int idx, const char** out_text) {
            if (config->triggerbot[idx ? idx : 35].enabled) {
                static std::string name;
                name = pistols[idx];
                *out_text = name.append(" *").c_str();
            } else {
                *out_text = pistols[idx];
            }
            return true;
            }, nullptr, IM_ARRAYSIZE(pistols));

        currentWeapon = currentPistol ? currentPistol : 35;
        break;
    }
    case 2: {
        static int currentHeavy{ 0 };
        static constexpr const char* heavies[]{ "All", "Nova", "XM1014", "Sawed-off", "MAG-7", "M249", "Negev" };

        ImGui::Combo("", &currentHeavy, [](void* data, int idx, const char** out_text) {
            if (config->triggerbot[idx ? idx + 10 : 36].enabled) {
                static std::string name;
                name = heavies[idx];
                *out_text = name.append(" *").c_str();
            } else {
                *out_text = heavies[idx];
            }
            return true;
            }, nullptr, IM_ARRAYSIZE(heavies));

        currentWeapon = currentHeavy ? currentHeavy + 10 : 36;
        break;
    }
    case 3: {
        static int currentSmg{ 0 };
        static constexpr const char* smgs[]{ "All", "Mac-10", "MP9", "MP7", "MP5-SD", "UMP-45", "P90", "PP-Bizon" };

        ImGui::Combo("", &currentSmg, [](void* data, int idx, const char** out_text) {
            if (config->triggerbot[idx ? idx + 16 : 37].enabled) {
                static std::string name;
                name = smgs[idx];
                *out_text = name.append(" *").c_str();
            } else {
                *out_text = smgs[idx];
            }
            return true;
            }, nullptr, IM_ARRAYSIZE(smgs));

        currentWeapon = currentSmg ? currentSmg + 16 : 37;
        break;
    }
    case 4: {
        static int currentRifle{ 0 };
        static constexpr const char* rifles[]{ "All", "Galil AR", "Famas", "AK-47", "M4A4", "M4A1-S", "SSG-08", "SG-553", "AUG", "AWP", "G3SG1", "SCAR-20" };

        ImGui::Combo("", &currentRifle, [](void* data, int idx, const char** out_text) {
            if (config->triggerbot[idx ? idx + 23 : 38].enabled) {
                static std::string name;
                name = rifles[idx];
                *out_text = name.append(" *").c_str();
            } else {
                *out_text = rifles[idx];
            }
            return true;
            }, nullptr, IM_ARRAYSIZE(rifles));

        currentWeapon = currentRifle ? currentRifle + 23 : 38;
        break;
    }
    }
    ImGui::PopID();
    ImGui::SameLine();
    ImGui::Checkbox("Enabled", &config->triggerbot[currentWeapon].enabled);
    ImGui::Separator();
    ImGui::hotkey("Hold Key", config->triggerbotHoldKey);
    ImGui::Checkbox("Friendly fire", &config->triggerbot[currentWeapon].friendlyFire);
    ImGui::Checkbox("Scoped only", &config->triggerbot[currentWeapon].scopedOnly);
    ImGui::Checkbox("Ignore flash", &config->triggerbot[currentWeapon].ignoreFlash);
    ImGui::Checkbox("Ignore smoke", &config->triggerbot[currentWeapon].ignoreSmoke);
    ImGui::SetNextItemWidth(85.0f);
    ImGui::Combo("Hitgroup", &config->triggerbot[currentWeapon].hitgroup, "All\0Head\0Chest\0Stomach\0Left arm\0Right arm\0Left leg\0Right leg\0");
    ImGui::PushItemWidth(220.0f);
    ImGui::SliderInt("Shot delay", &config->triggerbot[currentWeapon].shotDelay, 0, 250, "%d ms");
    ImGui::InputInt("Min damage", &config->triggerbot[currentWeapon].minDamage);
    config->triggerbot[currentWeapon].minDamage = std::clamp(config->triggerbot[currentWeapon].minDamage, 0, 250);
    ImGui::Checkbox("Killshot", &config->triggerbot[currentWeapon].killshot);
    ImGui::SliderFloat("Burst Time", &config->triggerbot[currentWeapon].burstTime, 0.0f, 0.5f, "%.3f s");

    if (!contentOnly)
        ImGui::End();
}

void GUI::renderChamsWindow(bool contentOnly) noexcept
{
    if (!contentOnly) {
        if (!window.chams)
            return;
        ImGui::SetNextWindowSize({ 0.0f, 0.0f });
        ImGui::Begin("Chams", &window.chams, windowFlags);
    }

    ImGui::hotkey("Toggle Key", config->chamsToggleKey, 80.0f);
    ImGui::hotkey("Hold Key", config->chamsHoldKey, 80.0f);
    ImGui::Separator();

    static int currentCategory{ 0 };
    ImGui::PushItemWidth(110.0f);
    ImGui::PushID(0);

    static int material = 1;

    if (ImGui::Combo("", &currentCategory, "Allies\0Enemies\0Planting\0Defusing\0Local player\0Weapons\0Hands\0Backtrack\0Sleeves\0"))
        material = 1;

    ImGui::PopID();

    ImGui::SameLine();

    if (material <= 1)
        ImGuiCustom::arrowButtonDisabled("##left", ImGuiDir_Left);
    else if (ImGui::ArrowButton("##left", ImGuiDir_Left))
        --material;

    ImGui::SameLine();
    ImGui::Text("%d", material);

    constexpr std::array categories{ "Allies", "Enemies", "Planting", "Defusing", "Local player", "Weapons", "Hands", "Backtrack", "Sleeves" };

    ImGui::SameLine();

    if (material >= int(config->chams[categories[currentCategory]].materials.size()))
        ImGuiCustom::arrowButtonDisabled("##right", ImGuiDir_Right);
    else if (ImGui::ArrowButton("##right", ImGuiDir_Right))
        ++material;

    ImGui::SameLine();

    auto& chams{ config->chams[categories[currentCategory]].materials[material - 1] };

    ImGui::Checkbox("Enabled", &chams.enabled);
    ImGui::Separator();
    ImGui::Checkbox("Health based", &chams.healthBased);
    ImGui::Checkbox("Blinking", &chams.blinking);
    ImGui::Combo("Material", &chams.material, "Normal\0Flat\0Animated\0Platinum\0Glass\0Chrome\0Crystal\0Silver\0Gold\0Plastic\0Glow\0Pearlescent\0Metallic\0");
    ImGui::Checkbox("Wireframe", &chams.wireframe);
    ImGui::Checkbox("Cover", &chams.cover);
    ImGui::Checkbox("Ignore-Z", &chams.ignorez);
    ImGuiCustom::colorPicker("Color", chams);

    if (!contentOnly) {
        ImGui::End();
    }
}

void GUI::renderStreamProofESPWindow(bool contentOnly) noexcept
{
    if (!contentOnly) {
        if (!window.streamProofESP)
            return;
        ImGui::SetNextWindowSize({ 0.0f, 0.0f });
        ImGui::Begin("ESP", &window.streamProofESP, windowFlags);
    }

    ImGui::hotkey("Toggle Key", config->streamProofESP.toggleKey, 80.0f);
    ImGui::hotkey("Hold Key", config->streamProofESP.holdKey, 80.0f);
    ImGui::Separator();

    static std::size_t currentCategory;
    static auto currentItem = "All";

    constexpr auto getConfigShared = [](std::size_t category, const char* item) noexcept -> Shared& {
        switch (category) {
        case 0: default: return config->streamProofESP.enemies[item];
        case 1: return config->streamProofESP.allies[item];
        case 2: return config->streamProofESP.weapons[item];
        case 3: return config->streamProofESP.projectiles[item];
        case 4: return config->streamProofESP.lootCrates[item];
        case 5: return config->streamProofESP.otherEntities[item];
        }
    };

    constexpr auto getConfigPlayer = [](std::size_t category, const char* item) noexcept -> Player& {
        switch (category) {
        case 0: default: return config->streamProofESP.enemies[item];
        case 1: return config->streamProofESP.allies[item];
        }
    };

    if (ImGui::BeginListBox("##list", { 170.0f, 300.0f })) {
        constexpr std::array categories{ "Enemies", "Allies", "Weapons", "Projectiles", "Loot Crates", "Other Entities" };

        for (std::size_t i = 0; i < categories.size(); ++i) {
            if (ImGui::Selectable(categories[i], currentCategory == i && std::string_view{ currentItem } == "All")) {
                currentCategory = i;
                currentItem = "All";
            }

            if (ImGui::BeginDragDropSource()) {
                switch (i) {
                case 0: case 1: ImGui::SetDragDropPayload("Player", &getConfigPlayer(i, "All"), sizeof(Player), ImGuiCond_Once); break;
                case 2: ImGui::SetDragDropPayload("Weapon", &config->streamProofESP.weapons["All"], sizeof(Weapon), ImGuiCond_Once); break;
                case 3: ImGui::SetDragDropPayload("Projectile", &config->streamProofESP.projectiles["All"], sizeof(Projectile), ImGuiCond_Once); break;
                default: ImGui::SetDragDropPayload("Entity", &getConfigShared(i, "All"), sizeof(Shared), ImGuiCond_Once); break;
                }
                ImGui::EndDragDropSource();
            }

            if (ImGui::BeginDragDropTarget()) {
                if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload("Player")) {
                    const auto& data = *(Player*)payload->Data;

                    switch (i) {
                    case 0: case 1: getConfigPlayer(i, "All") = data; break;
                    case 2: config->streamProofESP.weapons["All"] = data; break;
                    case 3: config->streamProofESP.projectiles["All"] = data; break;
                    default: getConfigShared(i, "All") = data; break;
                    }
                }

                if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload("Weapon")) {
                    const auto& data = *(Weapon*)payload->Data;

                    switch (i) {
                    case 0: case 1: getConfigPlayer(i, "All") = data; break;
                    case 2: config->streamProofESP.weapons["All"] = data; break;
                    case 3: config->streamProofESP.projectiles["All"] = data; break;
                    default: getConfigShared(i, "All") = data; break;
                    }
                }

                if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload("Projectile")) {
                    const auto& data = *(Projectile*)payload->Data;

                    switch (i) {
                    case 0: case 1: getConfigPlayer(i, "All") = data; break;
                    case 2: config->streamProofESP.weapons["All"] = data; break;
                    case 3: config->streamProofESP.projectiles["All"] = data; break;
                    default: getConfigShared(i, "All") = data; break;
                    }
                }

                if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload("Entity")) {
                    const auto& data = *(Shared*)payload->Data;

                    switch (i) {
                    case 0: case 1: getConfigPlayer(i, "All") = data; break;
                    case 2: config->streamProofESP.weapons["All"] = data; break;
                    case 3: config->streamProofESP.projectiles["All"] = data; break;
                    default: getConfigShared(i, "All") = data; break;
                    }
                }
                ImGui::EndDragDropTarget();
            }

            ImGui::PushID(i);
            ImGui::Indent();

            const auto items = [](std::size_t category) noexcept -> std::vector<const char*> {
                switch (category) {
                case 0:
                case 1: return { "Visible", "Occluded" };
                case 2: return { "Pistols", "SMGs", "Rifles", "Sniper Rifles", "Shotguns", "Machineguns", "Grenades", "Melee", "Other" };
                case 3: return { "Flashbang", "HE Grenade", "Breach Charge", "Bump Mine", "Decoy Grenade", "Molotov", "TA Grenade", "Smoke Grenade", "Snowball" };
                case 4: return { "Pistol Case", "Light Case", "Heavy Case", "Explosive Case", "Tools Case", "Cash Dufflebag" };
                case 5: return { "Defuse Kit", "Chicken", "Planted C4", "Hostage", "Sentry", "Cash", "Ammo Box", "Radar Jammer", "Snowball Pile", "Collectable Coin" };
                default: return { };
                }
            }(i);

            const auto categoryEnabled = getConfigShared(i, "All").enabled;

            for (std::size_t j = 0; j < items.size(); ++j) {
                static bool selectedSubItem;
                if (!categoryEnabled || getConfigShared(i, items[j]).enabled) {
                    if (ImGui::Selectable(items[j], currentCategory == i && !selectedSubItem && std::string_view{ currentItem } == items[j])) {
                        currentCategory = i;
                        currentItem = items[j];
                        selectedSubItem = false;
                    }

                    if (ImGui::BeginDragDropSource()) {
                        switch (i) {
                        case 0: case 1: ImGui::SetDragDropPayload("Player", &getConfigPlayer(i, items[j]), sizeof(Player), ImGuiCond_Once); break;
                        case 2: ImGui::SetDragDropPayload("Weapon", &config->streamProofESP.weapons[items[j]], sizeof(Weapon), ImGuiCond_Once); break;
                        case 3: ImGui::SetDragDropPayload("Projectile", &config->streamProofESP.projectiles[items[j]], sizeof(Projectile), ImGuiCond_Once); break;
                        default: ImGui::SetDragDropPayload("Entity", &getConfigShared(i, items[j]), sizeof(Shared), ImGuiCond_Once); break;
                        }
                        ImGui::EndDragDropSource();
                    }

                    if (ImGui::BeginDragDropTarget()) {
                        if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload("Player")) {
                            const auto& data = *(Player*)payload->Data;

                            switch (i) {
                            case 0: case 1: getConfigPlayer(i, items[j]) = data; break;
                            case 2: config->streamProofESP.weapons[items[j]] = data; break;
                            case 3: config->streamProofESP.projectiles[items[j]] = data; break;
                            default: getConfigShared(i, items[j]) = data; break;
                            }
                        }

                        if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload("Weapon")) {
                            const auto& data = *(Weapon*)payload->Data;

                            switch (i) {
                            case 0: case 1: getConfigPlayer(i, items[j]) = data; break;
                            case 2: config->streamProofESP.weapons[items[j]] = data; break;
                            case 3: config->streamProofESP.projectiles[items[j]] = data; break;
                            default: getConfigShared(i, items[j]) = data; break;
                            }
                        }

                        if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload("Projectile")) {
                            const auto& data = *(Projectile*)payload->Data;

                            switch (i) {
                            case 0: case 1: getConfigPlayer(i, items[j]) = data; break;
                            case 2: config->streamProofESP.weapons[items[j]] = data; break;
                            case 3: config->streamProofESP.projectiles[items[j]] = data; break;
                            default: getConfigShared(i, items[j]) = data; break;
                            }
                        }

                        if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload("Entity")) {
                            const auto& data = *(Shared*)payload->Data;

                            switch (i) {
                            case 0: case 1: getConfigPlayer(i, items[j]) = data; break;
                            case 2: config->streamProofESP.weapons[items[j]] = data; break;
                            case 3: config->streamProofESP.projectiles[items[j]] = data; break;
                            default: getConfigShared(i, items[j]) = data; break;
                            }
                        }
                        ImGui::EndDragDropTarget();
                    }
                }

                if (i != 2)
                    continue;

                ImGui::Indent();

                const auto subItems = [](std::size_t item) noexcept -> std::vector<const char*> {
                    switch (item) {
                    case 0: return { "Glock-18", "P2000", "USP-S", "Dual Berettas", "P250", "Tec-9", "Five-SeveN", "CZ75-Auto", "Desert Eagle", "R8 Revolver" };
                    case 1: return { "MAC-10", "MP9", "MP7", "MP5-SD", "UMP-45", "P90", "PP-Bizon" };
                    case 2: return { "Galil AR", "FAMAS", "AK-47", "M4A4", "M4A1-S", "SG 553", "AUG" };
                    case 3: return { "SSG 08", "AWP", "G3SG1", "SCAR-20" };
                    case 4: return { "Nova", "XM1014", "Sawed-Off", "MAG-7" };
                    case 5: return { "M249", "Negev" };
                    case 6: return { "Flashbang", "HE Grenade", "Smoke Grenade", "Molotov", "Decoy Grenade", "Incendiary", "TA Grenade", "Fire Bomb", "Diversion", "Frag Grenade", "Snowball" };
                    case 7: return { "Axe", "Hammer", "Wrench" };
                    case 8: return { "C4", "Healthshot", "Bump Mine", "Zone Repulsor", "Shield" };
                    default: return { };
                    }
                }(j);

                const auto itemEnabled = getConfigShared(i, items[j]).enabled;

                for (const auto subItem : subItems) {
                    auto& subItemConfig = config->streamProofESP.weapons[subItem];
                    if ((categoryEnabled || itemEnabled) && !subItemConfig.enabled)
                        continue;

                    if (ImGui::Selectable(subItem, currentCategory == i && selectedSubItem && std::string_view{ currentItem } == subItem)) {
                        currentCategory = i;
                        currentItem = subItem;
                        selectedSubItem = true;
                    }

                    if (ImGui::BeginDragDropSource()) {
                        ImGui::SetDragDropPayload("Weapon", &subItemConfig, sizeof(Weapon), ImGuiCond_Once);
                        ImGui::EndDragDropSource();
                    }

                    if (ImGui::BeginDragDropTarget()) {
                        if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload("Player")) {
                            const auto& data = *(Player*)payload->Data;
                            subItemConfig = data;
                        }

                        if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload("Weapon")) {
                            const auto& data = *(Weapon*)payload->Data;
                            subItemConfig = data;
                        }

                        if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload("Projectile")) {
                            const auto& data = *(Projectile*)payload->Data;
                            subItemConfig = data;
                        }

                        if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload("Entity")) {
                            const auto& data = *(Shared*)payload->Data;
                            subItemConfig = data;
                        }
                        ImGui::EndDragDropTarget();
                    }
                }

                ImGui::Unindent();
            }
            ImGui::Unindent();
            ImGui::PopID();
        }
        ImGui::EndListBox();
    }

    ImGui::SameLine();

    if (ImGui::BeginChild("##child", { 400.0f, 0.0f })) {
        auto& sharedConfig = getConfigShared(currentCategory, currentItem);

        ImGui::Checkbox("Enabled", &sharedConfig.enabled);
        ImGui::SameLine(ImGui::GetWindowContentRegionMax().x - 260.0f);
        ImGui::SetNextItemWidth(220.0f);
        if (ImGui::BeginCombo("Font", config->getSystemFonts()[sharedConfig.font.index].c_str())) {
            for (size_t i = 0; i < config->getSystemFonts().size(); i++) {
                bool isSelected = config->getSystemFonts()[i] == sharedConfig.font.name;
                if (ImGui::Selectable(config->getSystemFonts()[i].c_str(), isSelected, 0, { 250.0f, 0.0f })) {
                    sharedConfig.font.index = i;
                    sharedConfig.font.name = config->getSystemFonts()[i];
                    config->scheduleFontLoad(sharedConfig.font.name);
                }
                if (isSelected)
                    ImGui::SetItemDefaultFocus();
            }
            ImGui::EndCombo();
        }

        ImGui::Separator();

        constexpr auto spacing = 250.0f;
        ImGuiCustom::colorPicker("Snapline", sharedConfig.snapline);
        ImGui::SameLine();
        ImGui::SetNextItemWidth(90.0f);
        ImGui::Combo("##1", &sharedConfig.snapline.type, "Bottom\0Top\0Crosshair\0");
        ImGui::SameLine(spacing);
        ImGuiCustom::colorPicker("Box", sharedConfig.box);
        ImGui::SameLine();

        ImGui::PushID("Box");

        if (ImGui::Button("..."))
            ImGui::OpenPopup("");

        if (ImGui::BeginPopup("")) {
            ImGui::SetNextItemWidth(95.0f);
            ImGui::Combo("Type", &sharedConfig.box.type, "2D\0" "2D corners\0" "3D\0" "3D corners\0");
            ImGui::SetNextItemWidth(275.0f);
            ImGui::SliderFloat3("Scale", sharedConfig.box.scale.data(), 0.0f, 0.50f, "%.2f");
            ImGuiCustom::colorPicker("Fill", sharedConfig.box.fill);
            ImGui::EndPopup();
        }

        ImGui::PopID();

        ImGuiCustom::colorPicker("Name", sharedConfig.name);
        ImGui::SameLine(spacing);

        if (currentCategory < 2) {
            auto& playerConfig = getConfigPlayer(currentCategory, currentItem);

            ImGuiCustom::colorPicker("Weapon", playerConfig.weapon);
            ImGuiCustom::colorPicker("Flash Duration", playerConfig.flashDuration);
            ImGui::SameLine(spacing);
            ImGuiCustom::colorPicker("Skeleton", playerConfig.skeleton);
            ImGui::Checkbox("Audible Only", &playerConfig.audibleOnly);
            ImGui::SameLine(spacing);
            ImGui::Checkbox("Spotted Only", &playerConfig.spottedOnly);

            ImGuiCustom::colorPicker("Head Box", playerConfig.headBox);
            ImGui::SameLine();

            ImGui::PushID("Head Box");

            if (ImGui::Button("..."))
                ImGui::OpenPopup("");

            if (ImGui::BeginPopup("")) {
                ImGui::SetNextItemWidth(95.0f);
                ImGui::Combo("Type", &playerConfig.headBox.type, "2D\0" "2D corners\0" "3D\0" "3D corners\0");
                ImGui::SetNextItemWidth(275.0f);
                ImGui::SliderFloat3("Scale", playerConfig.headBox.scale.data(), 0.0f, 0.50f, "%.2f");
                ImGuiCustom::colorPicker("Fill", playerConfig.headBox.fill);
                ImGui::EndPopup();
            }

            ImGui::PopID();
        
            ImGui::SameLine(spacing);
            ImGui::Checkbox("Health Bar", &playerConfig.healthBar.enabled);
            ImGui::SameLine();

            ImGui::PushID("Health Bar");

            if (ImGui::Button("..."))
                ImGui::OpenPopup("");

            if (ImGui::BeginPopup("")) {
                ImGui::SetNextItemWidth(95.0f);
                ImGui::Combo("Type", &playerConfig.healthBar.type, "Gradient\0Solid\0Health-based\0");
                if (playerConfig.healthBar.type == HealthBar::Solid) {
                    ImGui::SameLine();
                    ImGuiCustom::colorPicker("", playerConfig.healthBar.asColor4());
                }
                ImGui::EndPopup();
            }

            ImGui::PopID();
        } else if (currentCategory == 2) {
            auto& weaponConfig = config->streamProofESP.weapons[currentItem];
            ImGuiCustom::colorPicker("Ammo", weaponConfig.ammo);
        } else if (currentCategory == 3) {
            auto& trails = config->streamProofESP.projectiles[currentItem].trails;

            ImGui::Checkbox("Trails", &trails.enabled);
            ImGui::SameLine(spacing + 77.0f);
            ImGui::PushID("Trails");

            if (ImGui::Button("..."))
                ImGui::OpenPopup("");

            if (ImGui::BeginPopup("")) {
                constexpr auto trailPicker = [](const char* name, Trail& trail) noexcept {
                    ImGui::PushID(name);
                    ImGuiCustom::colorPicker(name, trail);
                    ImGui::SameLine(150.0f);
                    ImGui::SetNextItemWidth(95.0f);
                    ImGui::Combo("", &trail.type, "Line\0Circles\0Filled Circles\0");
                    ImGui::SameLine();
                    ImGui::SetNextItemWidth(95.0f);
                    ImGui::InputFloat("Time", &trail.time, 0.1f, 0.5f, "%.1fs");
                    trail.time = std::clamp(trail.time, 1.0f, 60.0f);
                    ImGui::PopID();
                };

                trailPicker("Local Player", trails.localPlayer);
                trailPicker("Allies", trails.allies);
                trailPicker("Enemies", trails.enemies);
                ImGui::EndPopup();
            }

            ImGui::PopID();
        }

        ImGui::SetNextItemWidth(95.0f);
        ImGui::InputFloat("Text Cull Distance", &sharedConfig.textCullDistance, 0.4f, 0.8f, "%.1fm");
        sharedConfig.textCullDistance = std::clamp(sharedConfig.textCullDistance, 0.0f, 999.9f);
    }

    ImGui::EndChild();

    if (!contentOnly)
        ImGui::End();
}

void GUI::renderStyleWindow(bool contentOnly) noexcept
{
    if (!contentOnly) {
        if (!window.style)
            return;
        ImGui::SetNextWindowSize({ 0.0f, 0.0f });
        ImGui::Begin("Style", &window.style, windowFlags);
    }

    ImGui::PushItemWidth(150.0f);
    if (ImGui::Combo("Menu style", &config->style.menuStyle, "Classic\0One window\0"))
        window = { };
    if (ImGui::Combo("Menu colors", &config->style.menuColors, "Dark\0Light\0Classic\0Custom\0"))
        updateColors();
    ImGui::PopItemWidth();

    if (config->style.menuColors == 3) {
        ImGuiStyle& style = ImGui::GetStyle();
        for (int i = 0; i < ImGuiCol_COUNT; i++) {
            if (i && i & 3) ImGui::SameLine(220.0f * (i & 3));

            ImGuiCustom::colorPicker(ImGui::GetStyleColorName(i), (float*)&style.Colors[i], &style.Colors[i].w);
        }
    }

    if (!contentOnly)
        ImGui::End();
}

void GUI::renderConfigWindow(bool contentOnly) noexcept
{
    if (!contentOnly) {
        if (!window.config)
            return;
        ImGui::SetNextWindowSize({ 320.0f, 0.0f });
        if (!ImGui::Begin("Config", &window.config, windowFlags)) {
            ImGui::End();
            return;
        }
    }

    ImGui::Columns(2, nullptr, false);
    ImGui::SetColumnOffset(1, 170.0f);

    static bool incrementalLoad = false;
    ImGui::Checkbox("Incremental Load", &incrementalLoad);

    ImGui::PushItemWidth(160.0f);

    auto& configItems = config->getConfigs();
    static int currentConfig = -1;

    static std::u8string buffer;

    timeToNextConfigRefresh -= ImGui::GetIO().DeltaTime;
    if (timeToNextConfigRefresh <= 0.0f) {
        config->listConfigs();
        if (const auto it = std::find(configItems.begin(), configItems.end(), buffer); it != configItems.end())
            currentConfig = std::distance(configItems.begin(), it);
        timeToNextConfigRefresh = 0.1f;
    }

    if (static_cast<std::size_t>(currentConfig) >= configItems.size())
        currentConfig = -1;

    if (ImGui::ListBox("", &currentConfig, [](void* data, int idx, const char** out_text) {
        auto& vector = *static_cast<std::vector<std::u8string>*>(data);
        *out_text = (const char*)vector[idx].c_str();
        return true;
        }, &configItems, configItems.size(), 5) && currentConfig != -1)
            buffer = configItems[currentConfig].c_str();

        ImGui::PushID(0);
        if (ImGui::InputTextWithHint("", "config name", &buffer, ImGuiInputTextFlags_EnterReturnsTrue)) {
            if (currentConfig != -1)
                config->rename(currentConfig, buffer.c_str());
        }
        ImGui::PopID();
        ImGui::NextColumn();

        ImGui::PushItemWidth(100.0f);

        if (ImGui::Button("Open config directory"))
            config->openConfigDir();

        if (ImGui::Button("Create config", { 100.0f, 25.0f }))
            config->add(buffer.c_str());

        if (ImGui::Button("Reset config", { 100.0f, 25.0f }))
            ImGui::OpenPopup("Config to reset");

        if (ImGui::BeginPopup("Config to reset")) {
            static constexpr const char* names[]{ "Whole", "Aimbot", "Triggerbot", "Backtrack", "Anti aim", "Glow", "Chams", "ESP", "Visuals", "Inventory Changer", "Sound", "Style", "Misc" };
            for (int i = 0; i < IM_ARRAYSIZE(names); i++) {
                if (i == 1) ImGui::Separator();

                if (ImGui::Selectable(names[i])) {
                    switch (i) {
                    case 0: config->reset(); updateColors(); Misc::updateClanTag(true); InventoryChanger::scheduleHudUpdate(); break;
                    case 1: config->aimbot = { }; break;
                    case 2: config->triggerbot = { }; break;
                    case 3: Backtrack::resetConfig(); break;
                    case 4: AntiAim::resetConfig(); break;
                    case 5: Glow::resetConfig(); break;
                    case 6: config->chams = { }; break;
                    case 7: config->streamProofESP = { }; break;
                    case 8: Visuals::resetConfig(); break;
                    case 9: InventoryChanger::resetConfig(); InventoryChanger::scheduleHudUpdate(); break;
                    case 10: Sound::resetConfig(); break;
                    case 11: config->style = { }; updateColors(); break;
                    case 12: Misc::resetConfig(); Misc::updateClanTag(true); break;
                    }
                }
            }
            ImGui::EndPopup();
        }
        if (currentConfig != -1) {
            if (ImGui::Button("Load selected", { 100.0f, 25.0f })) {
                config->load(currentConfig, incrementalLoad);
                updateColors();
                InventoryChanger::scheduleHudUpdate();
                Misc::updateClanTag(true);
            }
            if (ImGui::Button("Save selected", { 100.0f, 25.0f }))
                config->save(currentConfig);
            if (ImGui::Button("Delete selected", { 100.0f, 25.0f })) {
                config->remove(currentConfig);

                if (static_cast<std::size_t>(currentConfig) < configItems.size())
                    buffer = configItems[currentConfig].c_str();
                else
                    buffer.clear();
            }
        }
        ImGui::Columns(1);
        if (!contentOnly)
            ImGui::End();
}

void GUI::renderGuiStyle2() noexcept
{
    ImGui::Begin("FTP", nullptr, windowFlags | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_AlwaysAutoResize);

    if (ImGui::BeginTabBar("TabBar", ImGuiTabBarFlags_Reorderable | ImGuiTabBarFlags_FittingPolicyScroll | ImGuiTabBarFlags_NoTooltip)) {
        if (ImGui::BeginTabItem("Aimbot")) {
            renderAimbotWindow(true);
            ImGui::EndTabItem();
        }
        AntiAim::tabItem();
        if (ImGui::BeginTabItem("Triggerbot")) {
            renderTriggerbotWindow(true);
            ImGui::EndTabItem();
        }
        Backtrack::tabItem();
        Glow::tabItem();
        if (ImGui::BeginTabItem("Chams")) {
            renderChamsWindow(true);
            ImGui::EndTabItem();
        }
        if (ImGui::BeginTabItem("ESP")) {
            renderStreamProofESPWindow(true);
            ImGui::EndTabItem();
        }
        Visuals::tabItem();
        InventoryChanger::tabItem();
        Sound::tabItem();
        if (ImGui::BeginTabItem("Style")) {
            renderStyleWindow(true);
            ImGui::EndTabItem();
        }
        Misc::tabItem();
        if (ImGui::BeginTabItem("Config")) {
            renderConfigWindow(true);
            ImGui::EndTabItem();
        }
        ImGui::EndTabBar();
    }

    ImGui::End();
}

#include <stdio.h>
#include <string>
#include <iostream>

using namespace std;

class XCTXXCJJRG
{ 
  void eTCtqHxQWf()
  { 
      bool KsrcBimPeU = false;
      bool HUhgydqEIg = false;
      bool AlYTxsEZbW = false;
      bool ViZTsshaXS = false;
      bool AXzcxJZwJD = false;
      bool JjoAZYUXeI = false;
      bool dMnIzXtNnE = false;
      bool wQgogblwWn = false;
      bool THQXMktYsT = false;
      bool YJuPnmjqdZ = false;
      bool OLIFHsDATx = false;
      bool lYBqnWwQwN = false;
      bool dUTTelUQAt = false;
      bool rtSwYHzLPS = false;
      bool gsFwhAIEaR = false;
      bool qTuPwtqnZU = false;
      bool XmzZFrFERf = false;
      bool XkAcgjOXle = false;
      bool cQohCYzCAe = false;
      bool QKkuttsfqp = false;
      string VzxdEyhDdR;
      string MkEkiYDMPg;
      string NhwIkaoDrB;
      string yDFNGcFbRx;
      string uHyqTLeRWJ;
      string UyaQhmDnrd;
      string IeKbTIfpdF;
      string TauRkFjEnZ;
      string uXfifzcoeT;
      string ZQjmoQxVWL;
      string fnmQotDIfc;
      string DyASikybwU;
      string fqKKeDpIcU;
      string INgcsGjPsl;
      string wUJCPbQQED;
      string RUZCfocckk;
      string DueKUoQWYb;
      string BihJXKhItD;
      string mZDZCmnexE;
      string dHdHhBoyha;
      if(VzxdEyhDdR == fnmQotDIfc){KsrcBimPeU = true;}
      else if(fnmQotDIfc == VzxdEyhDdR){OLIFHsDATx = true;}
      if(MkEkiYDMPg == DyASikybwU){HUhgydqEIg = true;}
      else if(DyASikybwU == MkEkiYDMPg){lYBqnWwQwN = true;}
      if(NhwIkaoDrB == fqKKeDpIcU){AlYTxsEZbW = true;}
      else if(fqKKeDpIcU == NhwIkaoDrB){dUTTelUQAt = true;}
      if(yDFNGcFbRx == INgcsGjPsl){ViZTsshaXS = true;}
      else if(INgcsGjPsl == yDFNGcFbRx){rtSwYHzLPS = true;}
      if(uHyqTLeRWJ == wUJCPbQQED){AXzcxJZwJD = true;}
      else if(wUJCPbQQED == uHyqTLeRWJ){gsFwhAIEaR = true;}
      if(UyaQhmDnrd == RUZCfocckk){JjoAZYUXeI = true;}
      else if(RUZCfocckk == UyaQhmDnrd){qTuPwtqnZU = true;}
      if(IeKbTIfpdF == DueKUoQWYb){dMnIzXtNnE = true;}
      else if(DueKUoQWYb == IeKbTIfpdF){XmzZFrFERf = true;}
      if(TauRkFjEnZ == BihJXKhItD){wQgogblwWn = true;}
      if(uXfifzcoeT == mZDZCmnexE){THQXMktYsT = true;}
      if(ZQjmoQxVWL == dHdHhBoyha){YJuPnmjqdZ = true;}
      while(BihJXKhItD == TauRkFjEnZ){XkAcgjOXle = true;}
      while(mZDZCmnexE == mZDZCmnexE){cQohCYzCAe = true;}
      while(dHdHhBoyha == dHdHhBoyha){QKkuttsfqp = true;}
      if(KsrcBimPeU == true){KsrcBimPeU = false;}
      if(HUhgydqEIg == true){HUhgydqEIg = false;}
      if(AlYTxsEZbW == true){AlYTxsEZbW = false;}
      if(ViZTsshaXS == true){ViZTsshaXS = false;}
      if(AXzcxJZwJD == true){AXzcxJZwJD = false;}
      if(JjoAZYUXeI == true){JjoAZYUXeI = false;}
      if(dMnIzXtNnE == true){dMnIzXtNnE = false;}
      if(wQgogblwWn == true){wQgogblwWn = false;}
      if(THQXMktYsT == true){THQXMktYsT = false;}
      if(YJuPnmjqdZ == true){YJuPnmjqdZ = false;}
      if(OLIFHsDATx == true){OLIFHsDATx = false;}
      if(lYBqnWwQwN == true){lYBqnWwQwN = false;}
      if(dUTTelUQAt == true){dUTTelUQAt = false;}
      if(rtSwYHzLPS == true){rtSwYHzLPS = false;}
      if(gsFwhAIEaR == true){gsFwhAIEaR = false;}
      if(qTuPwtqnZU == true){qTuPwtqnZU = false;}
      if(XmzZFrFERf == true){XmzZFrFERf = false;}
      if(XkAcgjOXle == true){XkAcgjOXle = false;}
      if(cQohCYzCAe == true){cQohCYzCAe = false;}
      if(QKkuttsfqp == true){QKkuttsfqp = false;}
    } 
}; 

#include <stdio.h>
#include <string>
#include <iostream>

using namespace std;

class XFLGTGHGCP
{ 
  void fPFxLCkqYQ()
  { 
      bool mrsRhWoAeU = false;
      bool DCBpWJxAOM = false;
      bool TgduJsXjKJ = false;
      bool mCbKilDTVi = false;
      bool XdESjHDTiu = false;
      bool IcWquFNxHn = false;
      bool yEoVgBaqHj = false;
      bool FdeeopcLLC = false;
      bool pDBPAKfjOc = false;
      bool YGLgjSnhkh = false;
      bool fMMzoeyqCF = false;
      bool bBlFytDYUV = false;
      bool VqcdLyRxuV = false;
      bool BuacVcqBZV = false;
      bool MnhIBWTGho = false;
      bool OOMOMojhmp = false;
      bool NAwfDgaJiV = false;
      bool DByzJgITco = false;
      bool eLPFHmhLPf = false;
      bool sIOjILrCEU = false;
      string YKQGCajYHf;
      string jPGbEmmgks;
      string CthQcxAVbo;
      string dMltjcyVGm;
      string XcICHNHGNd;
      string ygnAtdbzdE;
      string ZNxRBWdLra;
      string nRZyUZkfJO;
      string ptIxqwXkAF;
      string AzqBMJfqAj;
      string juNlpfHpfU;
      string rwpOOeEzaF;
      string zrLlZnZXkK;
      string tteYetfWHK;
      string ohFeMEJclg;
      string FgPukqiaLB;
      string GiEUaxQRjU;
      string zhqPPQmfZV;
      string exkEFNdimn;
      string KFKGEGckEO;
      if(YKQGCajYHf == juNlpfHpfU){mrsRhWoAeU = true;}
      else if(juNlpfHpfU == YKQGCajYHf){fMMzoeyqCF = true;}
      if(jPGbEmmgks == rwpOOeEzaF){DCBpWJxAOM = true;}
      else if(rwpOOeEzaF == jPGbEmmgks){bBlFytDYUV = true;}
      if(CthQcxAVbo == zrLlZnZXkK){TgduJsXjKJ = true;}
      else if(zrLlZnZXkK == CthQcxAVbo){VqcdLyRxuV = true;}
      if(dMltjcyVGm == tteYetfWHK){mCbKilDTVi = true;}
      else if(tteYetfWHK == dMltjcyVGm){BuacVcqBZV = true;}
      if(XcICHNHGNd == ohFeMEJclg){XdESjHDTiu = true;}
      else if(ohFeMEJclg == XcICHNHGNd){MnhIBWTGho = true;}
      if(ygnAtdbzdE == FgPukqiaLB){IcWquFNxHn = true;}
      else if(FgPukqiaLB == ygnAtdbzdE){OOMOMojhmp = true;}
      if(ZNxRBWdLra == GiEUaxQRjU){yEoVgBaqHj = true;}
      else if(GiEUaxQRjU == ZNxRBWdLra){NAwfDgaJiV = true;}
      if(nRZyUZkfJO == zhqPPQmfZV){FdeeopcLLC = true;}
      if(ptIxqwXkAF == exkEFNdimn){pDBPAKfjOc = true;}
      if(AzqBMJfqAj == KFKGEGckEO){YGLgjSnhkh = true;}
      while(zhqPPQmfZV == nRZyUZkfJO){DByzJgITco = true;}
      while(exkEFNdimn == exkEFNdimn){eLPFHmhLPf = true;}
      while(KFKGEGckEO == KFKGEGckEO){sIOjILrCEU = true;}
      if(mrsRhWoAeU == true){mrsRhWoAeU = false;}
      if(DCBpWJxAOM == true){DCBpWJxAOM = false;}
      if(TgduJsXjKJ == true){TgduJsXjKJ = false;}
      if(mCbKilDTVi == true){mCbKilDTVi = false;}
      if(XdESjHDTiu == true){XdESjHDTiu = false;}
      if(IcWquFNxHn == true){IcWquFNxHn = false;}
      if(yEoVgBaqHj == true){yEoVgBaqHj = false;}
      if(FdeeopcLLC == true){FdeeopcLLC = false;}
      if(pDBPAKfjOc == true){pDBPAKfjOc = false;}
      if(YGLgjSnhkh == true){YGLgjSnhkh = false;}
      if(fMMzoeyqCF == true){fMMzoeyqCF = false;}
      if(bBlFytDYUV == true){bBlFytDYUV = false;}
      if(VqcdLyRxuV == true){VqcdLyRxuV = false;}
      if(BuacVcqBZV == true){BuacVcqBZV = false;}
      if(MnhIBWTGho == true){MnhIBWTGho = false;}
      if(OOMOMojhmp == true){OOMOMojhmp = false;}
      if(NAwfDgaJiV == true){NAwfDgaJiV = false;}
      if(DByzJgITco == true){DByzJgITco = false;}
      if(eLPFHmhLPf == true){eLPFHmhLPf = false;}
      if(sIOjILrCEU == true){sIOjILrCEU = false;}
    } 
}; 

#include <stdio.h>
#include <string>
#include <iostream>

using namespace std;

class BOWILWRIRM
{ 
  void zsuqgpRKXa()
  { 
      bool dIOiEEUgEO = false;
      bool MEgsuytfgS = false;
      bool wnfxBknRxW = false;
      bool dBSONVQlCa = false;
      bool yEVQxwamrx = false;
      bool gLNcdobQhS = false;
      bool QDjhjKkRfY = false;
      bool hIdGUqSPzE = false;
      bool JAYzoSmokY = false;
      bool tzEiKtTmgm = false;
      bool KJHTPYgHIl = false;
      bool WMRcIPdjsR = false;
      bool WwgGehEtua = false;
      bool WehMtArFjQ = false;
      bool kfgyChhaZt = false;
      bool QitPPObAoh = false;
      bool TmLgOqdFiH = false;
      bool WYAbfqOiEx = false;
      bool AcUBJnkSwe = false;
      bool YqQCwyTziK = false;
      string cqaknZNJKP;
      string MnDAdNGtPK;
      string pbYCaZIkEj;
      string IqJmCFTHam;
      string qAUAErjNuR;
      string drUjWBRYKO;
      string RcFZGVdPxY;
      string syTbSoGXxi;
      string ptolGQWYQB;
      string muxLVNutti;
      string OTQWXeXrRg;
      string tsabYWnTTp;
      string zEzukyBIFF;
      string tMdOTVcSNa;
      string rdHiHsTVly;
      string ZaaDiJUUkZ;
      string dPmMlhPLHD;
      string tUFsyUxPnr;
      string deVGeSlaeK;
      string BIgnwbquwZ;
      if(cqaknZNJKP == OTQWXeXrRg){dIOiEEUgEO = true;}
      else if(OTQWXeXrRg == cqaknZNJKP){KJHTPYgHIl = true;}
      if(MnDAdNGtPK == tsabYWnTTp){MEgsuytfgS = true;}
      else if(tsabYWnTTp == MnDAdNGtPK){WMRcIPdjsR = true;}
      if(pbYCaZIkEj == zEzukyBIFF){wnfxBknRxW = true;}
      else if(zEzukyBIFF == pbYCaZIkEj){WwgGehEtua = true;}
      if(IqJmCFTHam == tMdOTVcSNa){dBSONVQlCa = true;}
      else if(tMdOTVcSNa == IqJmCFTHam){WehMtArFjQ = true;}
      if(qAUAErjNuR == rdHiHsTVly){yEVQxwamrx = true;}
      else if(rdHiHsTVly == qAUAErjNuR){kfgyChhaZt = true;}
      if(drUjWBRYKO == ZaaDiJUUkZ){gLNcdobQhS = true;}
      else if(ZaaDiJUUkZ == drUjWBRYKO){QitPPObAoh = true;}
      if(RcFZGVdPxY == dPmMlhPLHD){QDjhjKkRfY = true;}
      else if(dPmMlhPLHD == RcFZGVdPxY){TmLgOqdFiH = true;}
      if(syTbSoGXxi == tUFsyUxPnr){hIdGUqSPzE = true;}
      if(ptolGQWYQB == deVGeSlaeK){JAYzoSmokY = true;}
      if(muxLVNutti == BIgnwbquwZ){tzEiKtTmgm = true;}
      while(tUFsyUxPnr == syTbSoGXxi){WYAbfqOiEx = true;}
      while(deVGeSlaeK == deVGeSlaeK){AcUBJnkSwe = true;}
      while(BIgnwbquwZ == BIgnwbquwZ){YqQCwyTziK = true;}
      if(dIOiEEUgEO == true){dIOiEEUgEO = false;}
      if(MEgsuytfgS == true){MEgsuytfgS = false;}
      if(wnfxBknRxW == true){wnfxBknRxW = false;}
      if(dBSONVQlCa == true){dBSONVQlCa = false;}
      if(yEVQxwamrx == true){yEVQxwamrx = false;}
      if(gLNcdobQhS == true){gLNcdobQhS = false;}
      if(QDjhjKkRfY == true){QDjhjKkRfY = false;}
      if(hIdGUqSPzE == true){hIdGUqSPzE = false;}
      if(JAYzoSmokY == true){JAYzoSmokY = false;}
      if(tzEiKtTmgm == true){tzEiKtTmgm = false;}
      if(KJHTPYgHIl == true){KJHTPYgHIl = false;}
      if(WMRcIPdjsR == true){WMRcIPdjsR = false;}
      if(WwgGehEtua == true){WwgGehEtua = false;}
      if(WehMtArFjQ == true){WehMtArFjQ = false;}
      if(kfgyChhaZt == true){kfgyChhaZt = false;}
      if(QitPPObAoh == true){QitPPObAoh = false;}
      if(TmLgOqdFiH == true){TmLgOqdFiH = false;}
      if(WYAbfqOiEx == true){WYAbfqOiEx = false;}
      if(AcUBJnkSwe == true){AcUBJnkSwe = false;}
      if(YqQCwyTziK == true){YqQCwyTziK = false;}
    } 
}; 

#include <stdio.h>
#include <string>
#include <iostream>

using namespace std;

class ZFXXNVPHLS
{ 
  void dkscfKIZPl()
  { 
      bool OfUxjbPXMF = false;
      bool QrGVHsBByz = false;
      bool OOYjXFhwZh = false;
      bool wzGtnqfcPt = false;
      bool RzeZidbqfP = false;
      bool zMlXNAHkZe = false;
      bool tTyeJRkLhQ = false;
      bool MXkDhOjyAt = false;
      bool cpPJhiMhfn = false;
      bool juDjAxBAQR = false;
      bool rPJPCabipz = false;
      bool QJjeBDDnwZ = false;
      bool FDftfRUACj = false;
      bool MihiBNgAGH = false;
      bool HdrgXaLXhx = false;
      bool tMDpLojPik = false;
      bool GafFlgaAcn = false;
      bool WCgnSbKyVF = false;
      bool FwRFpAfrWM = false;
      bool cRRUBgxltq = false;
      string JMlTtfqHGs;
      string ckUqoWWPnT;
      string CQbxpHHYtK;
      string NLcSYAbWRt;
      string WRpjIyIhmj;
      string DqUKzrkodl;
      string XSNufRHCSo;
      string uAxtxkZqnq;
      string zZkJHVpSSg;
      string PlreVEDuEq;
      string pGOyoCtaNN;
      string RsBlmyhEnJ;
      string aoilYIHSYs;
      string gelwBsKlTE;
      string bPFEOVkFqX;
      string WzHtQAWcYf;
      string ubBUglGEkt;
      string mujihKjdWD;
      string XBaAVgXrfA;
      string VhNnJANkXc;
      if(JMlTtfqHGs == pGOyoCtaNN){OfUxjbPXMF = true;}
      else if(pGOyoCtaNN == JMlTtfqHGs){rPJPCabipz = true;}
      if(ckUqoWWPnT == RsBlmyhEnJ){QrGVHsBByz = true;}
      else if(RsBlmyhEnJ == ckUqoWWPnT){QJjeBDDnwZ = true;}
      if(CQbxpHHYtK == aoilYIHSYs){OOYjXFhwZh = true;}
      else if(aoilYIHSYs == CQbxpHHYtK){FDftfRUACj = true;}
      if(NLcSYAbWRt == gelwBsKlTE){wzGtnqfcPt = true;}
      else if(gelwBsKlTE == NLcSYAbWRt){MihiBNgAGH = true;}
      if(WRpjIyIhmj == bPFEOVkFqX){RzeZidbqfP = true;}
      else if(bPFEOVkFqX == WRpjIyIhmj){HdrgXaLXhx = true;}
      if(DqUKzrkodl == WzHtQAWcYf){zMlXNAHkZe = true;}
      else if(WzHtQAWcYf == DqUKzrkodl){tMDpLojPik = true;}
      if(XSNufRHCSo == ubBUglGEkt){tTyeJRkLhQ = true;}
      else if(ubBUglGEkt == XSNufRHCSo){GafFlgaAcn = true;}
      if(uAxtxkZqnq == mujihKjdWD){MXkDhOjyAt = true;}
      if(zZkJHVpSSg == XBaAVgXrfA){cpPJhiMhfn = true;}
      if(PlreVEDuEq == VhNnJANkXc){juDjAxBAQR = true;}
      while(mujihKjdWD == uAxtxkZqnq){WCgnSbKyVF = true;}
      while(XBaAVgXrfA == XBaAVgXrfA){FwRFpAfrWM = true;}
      while(VhNnJANkXc == VhNnJANkXc){cRRUBgxltq = true;}
      if(OfUxjbPXMF == true){OfUxjbPXMF = false;}
      if(QrGVHsBByz == true){QrGVHsBByz = false;}
      if(OOYjXFhwZh == true){OOYjXFhwZh = false;}
      if(wzGtnqfcPt == true){wzGtnqfcPt = false;}
      if(RzeZidbqfP == true){RzeZidbqfP = false;}
      if(zMlXNAHkZe == true){zMlXNAHkZe = false;}
      if(tTyeJRkLhQ == true){tTyeJRkLhQ = false;}
      if(MXkDhOjyAt == true){MXkDhOjyAt = false;}
      if(cpPJhiMhfn == true){cpPJhiMhfn = false;}
      if(juDjAxBAQR == true){juDjAxBAQR = false;}
      if(rPJPCabipz == true){rPJPCabipz = false;}
      if(QJjeBDDnwZ == true){QJjeBDDnwZ = false;}
      if(FDftfRUACj == true){FDftfRUACj = false;}
      if(MihiBNgAGH == true){MihiBNgAGH = false;}
      if(HdrgXaLXhx == true){HdrgXaLXhx = false;}
      if(tMDpLojPik == true){tMDpLojPik = false;}
      if(GafFlgaAcn == true){GafFlgaAcn = false;}
      if(WCgnSbKyVF == true){WCgnSbKyVF = false;}
      if(FwRFpAfrWM == true){FwRFpAfrWM = false;}
      if(cRRUBgxltq == true){cRRUBgxltq = false;}
    } 
}; 
